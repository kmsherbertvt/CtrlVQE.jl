<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic Implementations · CtrlVQE.jl</title><meta name="title" content="Basic Implementations · CtrlVQE.jl"/><meta property="og:title" content="Basic Implementations · CtrlVQE.jl"/><meta property="twitter:title" content="Basic Implementations · CtrlVQE.jl"/><meta name="description" content="Documentation for CtrlVQE.jl."/><meta property="og:description" content="Documentation for CtrlVQE.jl."/><meta property="twitter:description" content="Documentation for CtrlVQE.jl."/><meta property="og:url" content="https://kmsherbertvt.github.io/CtrlVQE.jl/basics/"/><meta property="twitter:url" content="https://kmsherbertvt.github.io/CtrlVQE.jl/basics/"/><link rel="canonical" href="https://kmsherbertvt.github.io/CtrlVQE.jl/basics/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CtrlVQE.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">CtrlVQE</a></li><li class="is-active"><a class="tocitem" href>Basic Implementations</a><ul class="internal"><li><a class="tocitem" href="#Integrations"><span>Integrations</span></a></li><li><a class="tocitem" href="#Signals"><span>Signals</span></a></li><li><a class="tocitem" href="#Devices"><span>Devices</span></a></li><li><a class="tocitem" href="#Evolutions"><span>Evolutions</span></a></li><li><a class="tocitem" href="#Cost-Functions"><span>Cost Functions</span></a></li></ul></li><li><a class="tocitem" href="../core/">Core Interface</a></li><li><a class="tocitem" href="../enums/">Enumerations</a></li><li><a class="tocitem" href="../modulars/">Modular Framework</a></li><li><a class="tocitem" href="../utils/">Utilities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Basic Implementations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basic Implementations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/kmsherbertvt/CtrlVQE.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/main/docs/src/basics.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Basic-Implementations"><a class="docs-heading-anchor" href="#Basic-Implementations">Basic Implementations</a><a id="Basic-Implementations-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Implementations" title="Permalink"></a></h1><ul><li><a href="#Integrations">Integrations</a></li><li><a href="#Signals">Signals</a></li><li><a href="#Devices">Devices</a></li><li><a href="#Evolutions">Evolutions</a></li><li><a href="#Cost-Functions">Cost Functions</a></li></ul><h2 id="Integrations"><a class="docs-heading-anchor" href="#Integrations">Integrations</a><a id="Integrations-1"></a><a class="docs-heading-anchor-permalink" href="#Integrations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.TrapezoidalIntegrations.TrapezoidalIntegration" href="#CtrlVQE.TrapezoidalIntegrations.TrapezoidalIntegration"><code>CtrlVQE.TrapezoidalIntegrations.TrapezoidalIntegration</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TrapezoidalIntegration(t0::F, tf::F, r::Int)</code></pre><p>First-order grid using a trapezoidal rule time integration.</p><p><strong>Arguments</strong></p><ul><li><code>t0</code>, <code>tf</code>: lower and upper bounds of the integral</li><li><code>r</code>: the number of time steps (remember number of lattice points is <code>r+1</code>)</li></ul><p><strong>Explanation</strong></p><p>This grid gives a first-order quadrature,     meaning every step takes you forward in time.</p><p>Additionally, this grid uses uniform spacing. You&#39;d <em>think</em> that would mean <code>stepat(grid, i)</code> would give <span>$τ_i = τ$</span> for every <code>i</code>,     where <span>$τ ≡ T / r$</span> and <span>$T ≡ t_f - t_0$</span>. But careful! The sum of all <code>τ_i</code> must match the length of the integral, ie. <code>T</code>. But there are <code>r+1</code> points, and <code>(r+1)⋅τ &gt; T</code>. How do we reconcile this? A &quot;Left Hand Sum&quot; would omit <code>t=T</code> from the time points;     a &quot;Right Hand Sum&quot; would omit <code>t=0</code>. The trapezoidal rule omits half a point from each.</p><p>That sounds awfully strange, but it&#39;s mathematically sound! We only integrate through <em>half</em> of each boundary time point <code>t=0</code> and <code>t=T</code>. Thus, those points, and only those points, have a spacing of <code>τ/2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Integrations/TrapezoidalIntegrations.jl#L7-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.TrapezoidalIntegrations.TemporalLattice-Tuple{Real, Int64}" href="#CtrlVQE.TrapezoidalIntegrations.TemporalLattice-Tuple{Real, Int64}"><code>CtrlVQE.TrapezoidalIntegrations.TemporalLattice</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TemporalLattice(T::Real, r::Int)</code></pre><p>Convenience constructor to make a trapezoidal time grid from t=0.0 to <code>T</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; grid = TemporalLattice(20.0, 400);

julia&gt; validate(grid);

julia&gt; Integrations.duration(grid)
20.0
julia&gt; Integrations.nsteps(grid)
400</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Integrations/TrapezoidalIntegrations.jl#L61-L77">source</a></section></article><h2 id="Signals"><a class="docs-heading-anchor" href="#Signals">Signals</a><a id="Signals-1"></a><a class="docs-heading-anchor-permalink" href="#Signals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ConstantSignals.ComplexConstantSignal" href="#CtrlVQE.ConstantSignals.ComplexConstantSignal"><code>CtrlVQE.ConstantSignals.ComplexConstantSignal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ComplexConstantSignal(A::F, B::F) where {F&lt;:AbstractFloat}</code></pre><p>The constant complex signal <span>$Ω(t) = A + iB$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Signals/ConstantSignals.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ConstantSignals.ConstantSignal" href="#CtrlVQE.ConstantSignals.ConstantSignal"><code>CtrlVQE.ConstantSignals.ConstantSignal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConstantSignal(A::AbstractFloat)</code></pre><p>The constant real signal <span>$Ω(t) = A$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Signals/ConstantSignals.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ConstantSignals.Constant" href="#CtrlVQE.ConstantSignals.Constant"><code>CtrlVQE.ConstantSignals.Constant</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Constant(A)
Constant(A, B)</code></pre><p>Convenience constructors for a constant signal.</p><p>The single argument form constructs a <code>ConstantSignal</code> when given a real number,     or a <code>ComplexConstantSignal</code> when given a complex number. The two-argument form constructs a <code>ComplexConstantSignal</code>,     taking <code>A</code> as the real part and <code>B</code> as the imaginary part.</p><pre><code class="language-julia-repl hljs">julia&gt; grid = TemporalLattice(20.0, 400);

julia&gt; realonly = Constant(2.0);

julia&gt; validate(realonly; grid=grid, t=10.0, rms=1e-6);

julia&gt; valueat(realonly, 10.0)
2.0
julia&gt; Parameters.names(realonly)
1-element Vector{String}:
 &quot;A&quot;

julia&gt; complex = Constant(2.0, 1.0);

julia&gt; validate(complex; grid=grid, t=10.0, rms=1e-6);

julia&gt; valueat(complex, 10.0)
2.0 + 1.0im
julia&gt; Parameters.names(complex)
2-element Vector{String}:
 &quot;A&quot;
 &quot;B&quot;

julia&gt; alsocomplex = Constant(2.0 + 1.0im);

julia&gt; validate(alsocomplex; grid=grid, t=10.0, rms=1e-6);

julia&gt; typeof(alsocomplex) == typeof(complex)
true
julia&gt; valueat(alsocomplex, 10.0) == valueat(complex, 10.0)
true
julia&gt; Parameters.names(alsocomplex) == Parameters.names(complex)
true

julia&gt; imagfrozen = Constrained(complex, :B);

julia&gt; validate(imagfrozen; grid=grid, t=10.0, rms=1e-6);

julia&gt; valueat(imagfrozen, 10.0) == valueat(complex, 10.0)
true
julia&gt; Parameters.names(imagfrozen) == Parameters.names(realonly)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Signals/ConstantSignals.jl#L44-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.CompositeSignals.CompositeSignal" href="#CtrlVQE.CompositeSignals.CompositeSignal"><code>CtrlVQE.CompositeSignals.CompositeSignal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CompositeSignal(components::AbstractVector{&lt;:SignalType{P,R}})</code></pre><p>A signal which is the sum of each sub-signal in <code>components</code>.</p><p>Each component should be the same type of signal, for type stability. If you need to compose different types of signals,     you should probably implement your own custom <code>SignalType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Signals/CompositeSignals.jl#L7-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.CompositeSignals.Composed-Union{Tuple{Vararg{CtrlVQE.Signals.SignalType{P, R}}}, Tuple{R}, Tuple{P}} where {P, R}" href="#CtrlVQE.CompositeSignals.Composed-Union{Tuple{Vararg{CtrlVQE.Signals.SignalType{P, R}}}, Tuple{R}, Tuple{P}} where {P, R}"><code>CtrlVQE.CompositeSignals.Composed</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Composed(components::SignalType...)</code></pre><p>Convenience constructor to combine multiple signals into a <code>CompositeSignal</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; grid = TemporalLattice(20.0, 400);

julia&gt; realpart = Constrained(Constant(2.0+0.0im), :B);

julia&gt; imagpart = Constrained(Constant(0.0+1.0im), :A);

julia&gt; signal = Composed(realpart, imagpart);

julia&gt; validate(signal; grid=grid, t=10.0, rms=1e-6);

julia&gt; Parameters.names(signal)
2-element Vector{String}:
 &quot;A.1&quot;
 &quot;B.2&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Signals/CompositeSignals.jl#L109-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.WindowedSignals.WindowedSignal" href="#CtrlVQE.WindowedSignals.WindowedSignal"><code>CtrlVQE.WindowedSignals.WindowedSignal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WindowedSignal(windows, starttimes)</code></pre><p>A signal which applies a different function for each window.</p><p><strong>Arguments</strong></p><ul><li>windows: a vector of signals</li><li>starttimes: a vector of times transitioning each window</li></ul><p>Both <code>windows</code> and <code>starttimes</code> have the same length;     <code>starttimes[i]</code> indicates when <code>windows[i]</code> begins.</p><p>This signal is undefined for times <code>t &lt; starttimes[1]</code>. Normally, <code>starttimes[1] == 0</code>.</p><p>Windows with dynamically changing numbers of parameters are unsupported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Signals/WindowedSignals.jl#L29-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.WindowedSignals.Windowed" href="#CtrlVQE.WindowedSignals.Windowed"><code>CtrlVQE.WindowedSignals.Windowed</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Windowed(signal, starttimes)
Windowed(signal, T, W)</code></pre><p>Convenience constructors to segment a single <code>signal</code> into a <code>WindowedSignal</code>.</p><p>Feed in <code>starttimes</code> directly,     or make <code>W</code> uniformly spaced windows up to maximum time <code>T</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; grid = TemporalLattice(20.0, 400);

julia&gt; signal = Windowed(Constant(2.0), 20.0, 5);

julia&gt; validate(signal; grid=grid, t=10.0, rms=1e-6);

julia&gt; Parameters.names(signal)
5-element Vector{String}:
 &quot;A.1&quot;
 &quot;A.2&quot;
 &quot;A.3&quot;
 &quot;A.4&quot;
 &quot;A.5&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Signals/WindowedSignals.jl#L221-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.WindowedSignals.get_window_from_parameter-Tuple{WindowedSignal, Int64}" href="#CtrlVQE.WindowedSignals.get_window_from_parameter-Tuple{WindowedSignal, Int64}"><code>CtrlVQE.WindowedSignals.get_window_from_parameter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_window_from_parameter(signal::WindowedSignal, i::Int)</code></pre><p>Identify the window index given a parameter index (by counting parameters in <code>windows</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Signals/WindowedSignals.jl#L91-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.WindowedSignals.get_window_from_time-Tuple{WindowedSignal, Real}" href="#CtrlVQE.WindowedSignals.get_window_from_time-Tuple{WindowedSignal, Real}"><code>CtrlVQE.WindowedSignals.get_window_from_time</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_window_from_time(signal::WindowedSignal, t::Real)</code></pre><p>Identify the window index given the time (by inspecting <code>starttimes</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Signals/WindowedSignals.jl#L79-L84">source</a></section></article><h2 id="Devices"><a class="docs-heading-anchor" href="#Devices">Devices</a><a id="Devices-1"></a><a class="docs-heading-anchor-permalink" href="#Devices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.RealWindowedResonantTransmonDevices.RealWindowedResonantTransmonDevice" href="#CtrlVQE.RealWindowedResonantTransmonDevices.RealWindowedResonantTransmonDevice"><code>CtrlVQE.RealWindowedResonantTransmonDevices.RealWindowedResonantTransmonDevice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RealWindowedResonantTransmonDevice{m}(ω, δ, g, quples, T, Ω)</code></pre><p>A minimalist transmon device with real-valued constant windows driven on resonance.</p><p>Windows are always equally spaced. Drives are approximated with RWA.</p><p><strong>Type Parameters</strong></p><ul><li><code>F</code>: (inferred from arguments) the float type of this device</li><li><code>m</code>: the integer number of levels per transmon</li></ul><p><strong>Parameters</strong></p><ul><li><code>ω</code>: an (abstract) vector of qubit resonance frequencies</li><li><code>δ</code>: an (abstract) vector of qubit anharmonicities</li><li><code>g</code>: an (abstract) vector of qubit coupling strengths</li><li><code>quples</code>: an (abstract) vector of quples identifying each coupling</li><li><code>T</code>: the total pulse duration applied on this device</li><li><code>Ω</code>: a matrix of complex amplitudes.   <code>Ω[w,q]</code> is the amplitude applied on qubit <code>q</code> in the time-window indexed by <code>w</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Devices/RealWindowedResonantTransmonDevices.jl#L14-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.RealWindowedResonantTransmonDevices.RealWindowedResonantTransmonDevice-Union{Tuple{m}, Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{Quple}, Real, Int64}} where m" href="#CtrlVQE.RealWindowedResonantTransmonDevices.RealWindowedResonantTransmonDevice-Union{Tuple{m}, Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{Quple}, Real, Int64}} where m"><code>CtrlVQE.RealWindowedResonantTransmonDevices.RealWindowedResonantTransmonDevice</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RealWindowedResonantTransmonDevice{m}(ω, δ, g, quples, T, W::Int)</code></pre><p>Convenience constructor where <code>Ω</code> is initialized to zero, with <code>W</code> time windows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Devices/RealWindowedResonantTransmonDevices.jl#L83-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Prototypes.Prototype-Union{Tuple{Type{CtrlVQE.RealWindowedResonantTransmonDevices.RealWindowedResonantTransmonDevice{F, m}}}, Tuple{m}, Tuple{F}} where {F, m}" href="#CtrlVQE.Prototypes.Prototype-Union{Tuple{Type{CtrlVQE.RealWindowedResonantTransmonDevices.RealWindowedResonantTransmonDevice{F, m}}}, Tuple{m}, Tuple{F}} where {F, m}"><code>CtrlVQE.Prototypes.Prototype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Prototype(::Type{RealWindowedResonantTransmonDevice{F,m}}, n::Int; kwargs...)</code></pre><p>A prototypical <code>RealWindowedResonantTransmonDevice</code> with the following decisions:</p><ul><li>All anharmonicities are constant.</li><li>Couplings are linear.</li><li>Each coupling strength equals the difference in resonance frequencies   of the coupled qubits.</li><li>By default, all resonance frequencies are equally spaced   (so, coupling strengths are constant)   but this can be controlled through kwargs.</li></ul><p>Default parameters are vaguely reminiscent of IBM devices circa 2021,     although the default behavior of linearly-spaced resonance frequencies     is not realistic and should be avoided outside of testing/benchmarking.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>ω0=4.82</code>: resonance frequency of first qubit.</li><li><code>Δω=0.02</code>: the spacing in resonance frequencies between adjacent qubits.   When passed as a float (including the default),       resonance frequencies are linearly spaced.   Instead, you can pass this as an explicit vector with <code>n-1</code> elements.</li><li><code>δ0=0.30</code>: the constant anharmonicity.</li><li><code>T=10.0</code>: total pulse duration.</li><li><code>W=1</code>: number of window segments.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; grid = TemporalLattice(20.0, 400);

julia&gt; device = Prototype(RWRTDevice{Float64,3}; n=2);

julia&gt; validate(device; grid=grid, t=10.0);

julia&gt; nlevels(device)
3
julia&gt; nqubits(device)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Devices/RealWindowedResonantTransmonDevices.jl#L263-L302">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.RealWindowedResonantTransmonDevices.__windowindex-Tuple{CtrlVQE.RealWindowedResonantTransmonDevices.RealWindowedResonantTransmonDevice, Real}" href="#CtrlVQE.RealWindowedResonantTransmonDevices.__windowindex-Tuple{CtrlVQE.RealWindowedResonantTransmonDevices.RealWindowedResonantTransmonDevice, Real}"><code>CtrlVQE.RealWindowedResonantTransmonDevices.__windowindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">__windowindex(device, t)</code></pre><p>Infer the column index of <code>device.Ω</code> i which time <code>t</code> falls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Devices/RealWindowedResonantTransmonDevices.jl#L250-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.WindowedResonantTransmonDevices.WindowedResonantTransmonDevice" href="#CtrlVQE.WindowedResonantTransmonDevices.WindowedResonantTransmonDevice"><code>CtrlVQE.WindowedResonantTransmonDevices.WindowedResonantTransmonDevice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WindowedResonantTransmonDevice{m}(ω, δ, g, quples, T, Ω)</code></pre><p>A minimalist transmon device with complex-constant windows driven on resonance.</p><p>Windows are always equally spaced. Drives are approximated with RWA.</p><p><strong>Type Parameters</strong></p><ul><li><code>F</code>: (inferred from arguments) the float type of this device</li><li><code>m</code>: the integer number of levels per transmon</li></ul><p><strong>Parameters</strong></p><ul><li><code>ω</code>: an (abstract) vector of qubit resonance frequencies</li><li><code>δ</code>: an (abstract) vector of qubit anharmonicities</li><li><code>g</code>: an (abstract) vector of qubit coupling strengths</li><li><code>quples</code>: an (abstract) vector of quples identifying each coupling</li><li><code>T</code>: the total pulse duration applied on this device</li><li><code>Ω</code>: a matrix of complex amplitudes.   <code>Ω[w,q]</code> is the amplitude applied on qubit <code>q</code> in the time-window indexed by <code>w</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Devices/WindowedResonantTransmonDevices.jl#L14-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.WindowedResonantTransmonDevices.WindowedResonantTransmonDevice-Union{Tuple{m}, Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{Quple}, Real, Int64}} where m" href="#CtrlVQE.WindowedResonantTransmonDevices.WindowedResonantTransmonDevice-Union{Tuple{m}, Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{Quple}, Real, Int64}} where m"><code>CtrlVQE.WindowedResonantTransmonDevices.WindowedResonantTransmonDevice</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WindowedResonantTransmonDevice{m}(ω, δ, g, quples, T, W::Int)</code></pre><p>Convenience constructor where <code>Ω</code> is initialized to zero, with <code>W</code> time windows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Devices/WindowedResonantTransmonDevices.jl#L83-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Prototypes.Prototype-Union{Tuple{Type{CtrlVQE.WindowedResonantTransmonDevices.WindowedResonantTransmonDevice{F, m}}}, Tuple{m}, Tuple{F}} where {F, m}" href="#CtrlVQE.Prototypes.Prototype-Union{Tuple{Type{CtrlVQE.WindowedResonantTransmonDevices.WindowedResonantTransmonDevice{F, m}}}, Tuple{m}, Tuple{F}} where {F, m}"><code>CtrlVQE.Prototypes.Prototype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Prototype(::Type{WindowedResonantTransmonDevice{F,m}}, n::Int; kwargs...)</code></pre><p>A prototypical <code>WindowedResonantTransmonDevice</code> with the following decisions:</p><ul><li>All anharmonicities are constant.</li><li>Couplings are linear.</li><li>Each coupling strength equals the difference in resonance frequencies   of the coupled qubits.</li><li>By default, all resonance frequencies are equally spaced   (so, coupling strengths are constant)   but this can be controlled through kwargs.</li></ul><p>Default parameters are vaguely reminiscent of IBM devices circa 2021,     although the default behavior of linearly-spaced resonance frequencies     is not realistic and should be avoided outside of testing/benchmarking.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>ω0=4.82</code>: resonance frequency of first qubit.</li><li><code>Δω=0.02</code>: the spacing in resonance frequencies between adjacent qubits.   When passed as a float (including the default),       resonance frequencies are linearly spaced.   Instead, you can pass this as an explicit vector with <code>n-1</code> elements.</li><li><code>δ0=0.30</code>: the constant anharmonicity.</li><li><code>T=10.0</code>: total pulse duration.</li><li><code>W=1</code>: number of window segments.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; grid = TemporalLattice(20.0, 400);

julia&gt; device = Prototype(CWRTDevice{Float64,3}; n=2);

julia&gt; validate(device; grid=grid, t=10.0);

julia&gt; nlevels(device)
3
julia&gt; nqubits(device)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Devices/WindowedResonantTransmonDevices.jl#L267-L306">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.WindowedResonantTransmonDevices.__windowindex-Tuple{CtrlVQE.WindowedResonantTransmonDevices.WindowedResonantTransmonDevice, Real}" href="#CtrlVQE.WindowedResonantTransmonDevices.__windowindex-Tuple{CtrlVQE.WindowedResonantTransmonDevices.WindowedResonantTransmonDevice, Real}"><code>CtrlVQE.WindowedResonantTransmonDevices.__windowindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">__windowindex(device, t)</code></pre><p>Infer the column index of <code>device.Ω</code> i which time <code>t</code> falls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Devices/WindowedResonantTransmonDevices.jl#L254-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.TransmonDevices.TransmonDevice" href="#CtrlVQE.TransmonDevices.TransmonDevice"><code>CtrlVQE.TransmonDevices.TransmonDevice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TransmonDevice{m}(ω, δ, g, quples, q, Ω, Δ)</code></pre><p>A transmon device where control signals and drive frequencies are signals.</p><p>Drives are approximated with RWA.</p><p><strong>Type Parameters</strong></p><ul><li><code>F</code>: (inferred from arguments) the float type of this device</li><li><code>m</code>: the integer number of levels per transmon</li></ul><p><strong>Parameters</strong></p><ul><li><code>ω</code>: an (abstract) vector of qubit resonance frequencies</li><li><code>δ</code>: an (abstract) vector of qubit anharmonicities</li><li><code>g</code>: an (abstract) vector of qubit coupling strengths</li><li><code>quples</code>: an (abstract) vector of quples identifying each coupling</li><li><code>q</code>: the qubits corresponding to each drive.</li><li><code>Ω</code>: an (abstract) vector of control signals for each drive. May be real or complex.</li><li><code>Δ</code>: an (abstract) vector of detunings for each drive frequency. Must be real.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Devices/TransmonDevices.jl#L16-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.TransmonDevices.TransmonDevice-Union{Tuple{m}, Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{Quple}}} where m" href="#CtrlVQE.TransmonDevices.TransmonDevice-Union{Tuple{m}, Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{Quple}}} where m"><code>CtrlVQE.TransmonDevices.TransmonDevice</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TransmonDevice{m}(ω, δ, g, quples; kwargs...)</code></pre><p>Convenience constructor allowing a more semantic approach to inputting signals.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>q</code>: may be a an (abstract) vector of <code>Int</code>.       Defaults to one drive for each qubit (i.e. <code>1:length(ω)</code>)</li><li><code>Ω</code>: may be a <code>SignalType</code> or an (abstract) vector of <code>SignalTypes</code>.       If a single <code>SignalType</code> is provided, it is duplicated for each drive.</li><li><code>Δ</code>: may be a <code>Bool</code> or a <code>SignalType</code> or an (abstract) vector of <code>SignalTypes</code>.       If a single <code>SignalType</code> is provided, it is duplicated for each drive.       If <code>Δ=true</code>, drive frequencies are constant signals initialized on resonance.       If <code>Δ=false</code> (the default), drive frequencies are <em>frozen</em> on resonance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Devices/TransmonDevices.jl#L98-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Prototypes.Prototype-Union{Tuple{Type{TransmonDevice{F, m}}}, Tuple{m}, Tuple{F}} where {F, m}" href="#CtrlVQE.Prototypes.Prototype-Union{Tuple{Type{TransmonDevice{F, m}}}, Tuple{m}, Tuple{F}} where {F, m}"><code>CtrlVQE.Prototypes.Prototype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Prototype(::Type{TransmonDevice{F,m}}, n::Int; kwargs...)</code></pre><p>A prototypical <code>TransmonDevice</code> with the following decisions:</p><ul><li>All anharmonicities are constant.</li><li>Couplings are linear.</li><li>Each coupling strength equals the difference in resonance frequencies   of the coupled qubits.</li><li>By default, all resonance frequencies are equally spaced   (so, coupling strengths are constant)   but this can be controlled through kwargs.</li><li>Drives match those of the defaults when using the kwarg constructor.</li></ul><p>Default parameters are vaguely reminiscent of IBM devices circa 2021,     although the default behavior of linearly-spaced resonance frequencies     is not realistic and should be avoided outside of testing/benchmarking.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>ω0=4.82</code>: resonance frequency of first qubit.</li><li><code>Δω=0.02</code>: the spacing in resonance frequencies between adjacent qubits.   When passed as a float (including the default),       resonance frequencies are linearly spaced.   Instead, you can pass this as an explicit vector with <code>n-1</code> elements.</li><li><code>δ0=0.30</code>: the constant anharmonicity.</li><li><code>T=10.0</code>: the pulse duration,   but this has no effect since the default signals are constant.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; grid = TemporalLattice(20.0, 400);

julia&gt; device = Prototype(TransmonDevice{Float64,3}; n=2);

julia&gt; validate(device; grid=grid, t=10.0);

julia&gt; nlevels(device)
3
julia&gt; nqubits(device)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Devices/TransmonDevices.jl#L341-L381">source</a></section></article><h2 id="Evolutions"><a class="docs-heading-anchor" href="#Evolutions">Evolutions</a><a id="Evolutions-1"></a><a class="docs-heading-anchor-permalink" href="#Evolutions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.RotatingFrameEvolutions.RotatingFrameEvolution" href="#CtrlVQE.RotatingFrameEvolutions.RotatingFrameEvolution"><code>CtrlVQE.RotatingFrameEvolutions.RotatingFrameEvolution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ROTATING_FRAME</code></pre><p>A Trotterization method calculating drive terms in the rotating frame of the device.</p><p>The work basis for this algorithm is <code>Bases.DRESSED</code>. This ensures the rotating-frame evolution <span>$U_t ≡ exp(-itH_0)$</span> is quite cheap. Even so, this algorithm exponentiates the matrix <span>$U_t&#39; V(t) U_t$</span> at each time step,     so it is not terribly efficient.</p><p>A <code>gradientsignals</code> method is not currently supported for this evolution algorithm.</p><pre><code class="language-julia-repl hljs">julia&gt; grid = TemporalLattice(20.0, 400);

julia&gt; device = Prototype(TransmonDevice{Float64,2}; n=2);

julia&gt; evolution = ROTATING_FRAME;

julia&gt; validate(evolution; grid=grid, device=device, skipgradient=true);

julia&gt; workbasis(evolution)
CtrlVQE.Bases.Dressed()
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Evolutions/RotatingFrameEvolutions.jl#L14-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.QubitFrameEvolutions.QubitFrameEvolution" href="#CtrlVQE.QubitFrameEvolutions.QubitFrameEvolution"><code>CtrlVQE.QubitFrameEvolutions.QubitFrameEvolution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QUBIT_FRAME</code></pre><p>A Trotterization method alternately propagating static and drive terms.</p><p>The work basis for this algorithm is <code>Bases.BARE</code>. The static term propagator is expensive but only computed once. If the drive terms are local (as for a <code>LocallyDrivenDevice</code>),     the drive propagator is relatively cheap.</p><p>Beware that this algorithm implicitly employs a trapezoidal rule,     irrespective of the <code>grid</code> passed to evolution functions.</p><pre><code class="language-julia-repl hljs">julia&gt; grid = TemporalLattice(20.0, 400);

julia&gt; device = Prototype(TransmonDevice{Float64,2}; n=2);

julia&gt; evolution = QUBIT_FRAME;

julia&gt; validate(evolution; grid=grid, device=device, skipgradient=true);

julia&gt; workbasis(evolution)
CtrlVQE.Bases.Bare()
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/Evolutions/QubitFrameEvolutions.jl#L14-L41">source</a></section></article><h2 id="Cost-Functions"><a class="docs-heading-anchor" href="#Cost-Functions">Cost Functions</a><a id="Cost-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Cost-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.DenseLeakageFunctions.DenseLeakage" href="#CtrlVQE.DenseLeakageFunctions.DenseLeakage"><code>CtrlVQE.DenseLeakageFunctions.DenseLeakage</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DenseLeakage(reference, device, basis, frame, grid, evolution)</code></pre><p>Calculate leakage of a reference state after evolution.</p><p>Leakage is the probability of finding any qubit outside the |0⟩,|1⟩ subspace.</p><p><strong>Parameters</strong></p><ul><li><code>reference</code>: the initial statevector before evolution.</li><li><code>device</code>: the device under which the state evolves.</li><li><code>basis</code>: the basis that <code>reference</code> is input as,   and the basis which for which leakage is defined.</li><li><code>frame</code>: the rotating frame for which leakage is defined.</li><li><code>grid</code>: the time grid on which the state evolves.</li><li><code>evolution</code>: the algorithm to calculate the time evolution.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; grid = TemporalLattice(20.0, 400);

julia&gt; device = Prototype(TransmonDevice{Float64,2}; n=2);

julia&gt; ψ0 = LAT.basisvector(Complex{eltype(device)}, nstates(device), 1);

julia&gt; costfn = DenseLeakage(ψ0, device, Bases.DRESSED, Operators.STATIC, grid, QUBIT_FRAME);

julia&gt; validate(costfn; rms=1e-6, grid=grid, device=device);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/CostFunctions/DenseLeakageFunctions.jl#L10-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.DenseObservableFunctions.DenseObservable" href="#CtrlVQE.DenseObservableFunctions.DenseObservable"><code>CtrlVQE.DenseObservableFunctions.DenseObservable</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DenseObservable(observable, reference, device, basis, frame, grid, evolution)</code></pre><p>Calculate the expectation value of an observable after evolution of a reference state.</p><p><strong>Parameters</strong></p><ul><li><code>observable</code>: the matrix (defined on the whole Hilbert space) to measure.</li><li><code>reference</code>: the initial statevector before evolution.</li><li><code>device</code>: the device under which the state evolves.</li><li><code>basis</code>: the basis that <code>observable</code> and <code>reference</code> are input as.</li><li><code>frame</code>: the rotating frame in which <code>observable</code> is to be measured.</li><li><code>grid</code>: the time grid on which the state evolves.</li><li><code>evolution</code>: the algorithm to calculate the time evolution.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; grid = TemporalLattice(20.0, 400);

julia&gt; device = Prototype(TransmonDevice{Float64,2}; n=2);

julia&gt; ψ0 = LAT.basisvector(Complex{eltype(device)}, nstates(device), 1);

julia&gt; O = LAT.basisvectors(Complex{eltype(device)}, nstates(device));

julia&gt; costfn = DenseObservable(O, ψ0, device, Bases.DRESSED, Operators.STATIC, grid, QUBIT_FRAME);

julia&gt; validate(costfn; rms=1e-6, grid=grid, device=device);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/CostFunctions/DenseObservableFunctions.jl#L8-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.CompositeCostFunctions.CompositeCostFunction" href="#CtrlVQE.CompositeCostFunctions.CompositeCostFunction"><code>CtrlVQE.CompositeCostFunctions.CompositeCostFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CompositeCostFunction(components::AbstractVector{CostFunctionType})</code></pre><p>The sum of several cost-functions, with matching <code>length</code> and float type.</p><p>Use this eg. to combine an energy function with one or more penalty functions.</p><p>This struct records the last values computed (value or gradient)     for each cost function in its <code>values</code> and <code>gradients</code> fields.</p><p>Beware that the <code>components</code> field is a vector with abstract eltype. This is a relatively mild form of type instability;     certain compiled code could hypothetically be sub-optimal. But it does not appear to cause any noticeable disadvantage;     see <code>Examples/CompositeCostFunctions</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/CostFunctions/CompositeCostFunctions.jl#L5-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.CompositeCostFunctions.CompositeCostFunction-Union{Tuple{Vararg{CtrlVQE.CostFunctions.CostFunctionType{F}}}, Tuple{F}} where F" href="#CtrlVQE.CompositeCostFunctions.CompositeCostFunction-Union{Tuple{Vararg{CtrlVQE.CostFunctions.CostFunctionType{F}}}, Tuple{F}} where F"><code>CtrlVQE.CompositeCostFunctions.CompositeCostFunction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CompositeCostFunction(components::CostFunctionType{F}...)</code></pre><p>Alternate constructor, letting each function be passed as its own argument.</p><pre><code class="language-julia-repl hljs">julia&gt; grid = TemporalLattice(20.0, 400);

julia&gt; device = Prototype(CWRTDevice{Float64,2}; n=2);

julia&gt; ψ0 = LAT.basisvector(Complex{eltype(device)}, nstates(device), 1);

julia&gt; O = LAT.basisvectors(Complex{eltype(device)}, nstates(device));

julia&gt; energyfn = DenseObservable(O, ψ0, device, Bases.DRESSED, Operators.STATIC, grid, QUBIT_FRAME);

julia&gt; penaltyfn = WindowedResonantPenalty(device; A=0.8);

julia&gt; costfn = CompositeCostFunction(energyfn, penaltyfn);

julia&gt; validate(costfn; rms=1e-6);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/CostFunctions/CompositeCostFunctions.jl#L48-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.WindowedResonantPenalties.WindowedResonantPenalty" href="#CtrlVQE.WindowedResonantPenalties.WindowedResonantPenalty"><code>CtrlVQE.WindowedResonantPenalties.WindowedResonantPenalty</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WindowedResonantPenalty(device, A::Vector, σ::Vector, λ::Vector)</code></pre><p>Compute penalties for exceeding the maximum amplitude of a device.</p><p>Let <span>$u=rac{|Ω|-A}{σ}$</span>. When <span>$u&gt;0$</span> the penalty is computed as <span>$Λ = λ xp(u - 1/u)$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>device</code>: a compatible device (see below).</li><li><code>A</code>: the maximum modulus of any amplitude, on each drive.</li><li><code>σ</code>: the steepness parameter of the penalty function, on each drive.</li><li><code>λ</code>: the strength parameter of the penalty function, on each drive</li></ul><p><strong>Device Compatibility</strong></p><p>Intended for use with the <code>RWRTDevice</code> and <code>CWRTDevice</code> provided in the basics,     this type should work if:</p><ul><li><code>device</code> has a field <code>Ω</code></li><li><code>Ω</code> is a matrix of (potentially complex) amplitudes, with <code>n</code> columns,   where <code>n = Devices.nqubits(device)</code>.</li><li><code>Parameters.values(x)</code> is a vectorization of <code>Ω</code> (and nothing else),   reinterpreted as a vector of floats when <code>Ω</code> is complex.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/CostFunctions/WindowedResonantPenalties.jl#L12-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.WindowedResonantPenalties.WindowedResonantPenalty-Union{Tuple{CtrlVQE.Devices.DeviceType{F}}, Tuple{F}} where F" href="#CtrlVQE.WindowedResonantPenalties.WindowedResonantPenalty-Union{Tuple{CtrlVQE.Devices.DeviceType{F}}, Tuple{F}} where F"><code>CtrlVQE.WindowedResonantPenalties.WindowedResonantPenalty</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WindowedResonantPenalty(device; A=1.0, σ=A, λ=1.0)</code></pre><p>Alternate constructor, with kwargs and sensible defaults.</p><p>Each parameter may be provided as a vector or as a scalar,     in which case it is automatically expanded to a vector     where the given value is assigned to each qubit.</p><p>We have selected σ defaulting to A because heuristically it seems to work well. Don&#39;t feel too attached to that choice.</p><pre><code class="language-julia-repl hljs">julia&gt; device = Prototype(CWRTDevice{Float64,2}; n=2);

julia&gt; costfn = WindowedResonantPenalty(device; A=0.8);

julia&gt; x = collect(range(0.0, 1.0, length(costfn)))
4-element Vector{Float64}:
 0.0
 0.3333333333333333
 0.6666666666666666
 1.0

julia&gt; validate(costfn; x=x, rms=1e-6);

julia&gt; costfn(x)
0.22571605879846993
julia&gt; grad_function(costfn)(x)
4-element Vector{Float64}:
 0.0
 0.0
 0.7767775331625435
 1.1651662997438155
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/CostFunctions/WindowedResonantPenalties.jl#L44-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.SignalStrengthPenalties.SignalStrengthPenalty" href="#CtrlVQE.SignalStrengthPenalties.SignalStrengthPenalty"><code>CtrlVQE.SignalStrengthPenalties.SignalStrengthPenalty</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SignalStrengthPenalty(grid, signal, A, σ, λ)</code></pre><p>Compute penalties for a signal exceeding a maximum absolute value over a time interval.</p><p>Let <span>$u(t)=\frac{|Ω(t)|-A}{σ}$</span>, where <code>Ω(t)</code> is defined by <code>signal</code>. When <span>$u&gt;0$</span> the instantaneous penalty is computed as <span>$Λ(t) = λ⋅\exp[u(t) - 1/u(t)]$</span>. The total penalty is <span>$\frac{1}{T}⋅\int_0^T Λ(t)⋅dt$</span>,     where the integration is defined by <code>grid</code>.</p><p><strong>Parameters</strong></p><ul><li><code>grid</code>: defines the integration (including time bounds) over which to penalize.</li><li><code>signal</code>: the signal to penalize.</li><li><code>A</code>: the maximum modulus of the signal.</li><li><code>σ</code>: the steepness parameter of the penalty function.</li><li><code>λ</code>: the strength parameter of the penalty function.</li></ul><p>Note that, if you do not wish the penalty to be normalized per unit time,     <code>λ</code> should be selected to be proportional to the duration of <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/CostFunctions/SignalStrengthPenalties.jl#L13-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.SignalStrengthPenalties.SignalStrengthPenalty-Union{Tuple{R}, Tuple{F}, Tuple{CtrlVQE.Integrations.IntegrationType{F}, CtrlVQE.Signals.SignalType{F, R}}} where {F, R}" href="#CtrlVQE.SignalStrengthPenalties.SignalStrengthPenalty-Union{Tuple{R}, Tuple{F}, Tuple{CtrlVQE.Integrations.IntegrationType{F}, CtrlVQE.Signals.SignalType{F, R}}} where {F, R}"><code>CtrlVQE.SignalStrengthPenalties.SignalStrengthPenalty</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SignalStrengthPenalty(device; A=1.0, σ=A, λ=1.0)</code></pre><p>Alternate constructor, with kwargs and sensible defaults.</p><p>We have selected σ defaulting to A because heuristically it seems to work well. Don&#39;t feel too attached to that choice.</p><pre><code class="language-julia-repl hljs">julia&gt; grid = TemporalLattice(20.0, 400);

julia&gt; signal = Windowed(Constant(2.0), 20.0, 5);

julia&gt; costfn = SignalStrengthPenalty(grid, signal; A=0.8);

julia&gt; x = collect(range(0.0, 1.0, length(costfn)))
5-element Vector{Float64}:
 0.0
 0.25
 0.5
 0.75
 1.0

julia&gt; validate(costfn; x=x, rms=1e-6);

julia&gt; costfn(x)
0.00473294635352182
julia&gt; grad_function(costfn)(x)
5-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0
 0.10057511001233899
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/CostFunctions/SignalStrengthPenalties.jl#L47-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.AmplitudePenalties.AmplitudePenalty" href="#CtrlVQE.AmplitudePenalties.AmplitudePenalty"><code>CtrlVQE.AmplitudePenalties.AmplitudePenalty</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AmplitudePenalty(device::DeviceType, penalties::AbstractVector{&lt;:CostFunctionType})</code></pre><p>The sum of several penalty functions acting on a device&#39;s amplitude signals.</p><p>In order for this type to be usable,     each penalty in <code>penalties</code> must act on parameters corresponding to     the signals contained in <code>device.Ω</code>,     and parameters in <code>device</code> must be disjoint,     listing parameters for each <code>device.Ω</code> then each <code>device.ν</code>. This interface is suitable for the basic <code>TransmonDevice</code>.</p><p>This struct records the last values computed (value or gradient)     for each cost function in its <code>values</code> and <code>gradients</code> fields.</p><p>Beware that the <code>components</code> field is a vector with abstract eltype. This is a relatively mild form of type instability;     certain compiled code could hypothetically be sub-optimal. But it does not appear to cause any noticeable disadvantage;     see <code>Examples/CompositeCostFunctions</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; grid = TemporalLattice(20.0, 400);

julia&gt; device = Prototype(TransmonDevice{Float64,2}; n=2);

julia&gt; penalties = [SignalStrengthPenalty(grid, signal; A=0.8) for signal in device.Ω];

julia&gt; costfn = AmplitudePenalty(device, penalties);

julia&gt; x = collect(range(0.0, 1.0, length(costfn)))
4-element Vector{Float64}:
 0.0
 0.3333333333333333
 0.6666666666666666
 1.0

julia&gt; validate(costfn; x=x, rms=1e-6);

julia&gt; costfn(x)
0.22571605879846895
julia&gt; grad_function(costfn)(x)
4-element Vector{Float64}:
 0.0
 0.0
 0.7767775331625492
 1.165166299743822
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/CostFunctions/AmplitudePenalties.jl#L7-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.DetuningPenalties.DetuningPenalty" href="#CtrlVQE.DetuningPenalties.DetuningPenalty"><code>CtrlVQE.DetuningPenalties.DetuningPenalty</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DetuningPenalty(device::DeviceType, penalties::AbstractVector{&lt;:CostFunctionType})</code></pre><p>The sum of several penalty functions acting on a device&#39;s detuning signals.</p><p>In order for this type to be usable,     each penalty in <code>penalties</code> must act on parameters corresponding to     the signals contained in <code>device.Δ</code>,     and parameters in <code>device</code> must be disjoint,     listing parameters for each <code>device.Ω</code> then each <code>device.Δ</code>. This interface is suitable for the basic <code>TransmonDevice</code>.</p><p>This struct records the last values computed (value or gradient)     for each cost function in its <code>values</code> and <code>gradients</code> fields.</p><p>Beware that the <code>components</code> field is a vector with abstract eltype. This is a relatively mild form of type instability;     certain compiled code could hypothetically be sub-optimal. But it does not appear to cause any noticeable disadvantage;     see <code>Examples/CompositeCostFunctions</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; grid = TemporalLattice(20.0, 400);

julia&gt; device = TransmonDevice{2}([4.82, 4.84], [0.00, 0.00], [0.02], [Quple(1,2)]; Ω=Constrained(Constant(zero(ComplexF64)), :B), Δ=Constant(zero(Float64)));

julia&gt; penalties = [SignalStrengthPenalty(grid, signal; A=0.8) for signal in device.Δ];

julia&gt; costfn = DetuningPenalty(device, penalties);

julia&gt; x = collect(range(0.0, 1.0, length(costfn)))
4-element Vector{Float64}:
 0.0
 0.3333333333333333
 0.6666666666666666
 1.0

julia&gt; validate(costfn; x=x, rms=1e-6);

julia&gt; costfn(x)
0.02351774585600897
julia&gt; grad_function(costfn)(x)
4-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.4997520994401937
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/basics/CostFunctions/DetuningPenalties.jl#L7-L57">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« CtrlVQE</a><a class="docs-footer-nextpage" href="../core/">Core Interface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Monday 17 March 2025 05:30">Monday 17 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
