var documenterSearchIndex = {"docs":
[{"location":"core/","page":"Core Interface","title":"Core Interface","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"core/#Core-Interface","page":"Core Interface","title":"Core Interface","text":"","category":"section"},{"location":"core/","page":"Core Interface","title":"Core Interface","text":"Pages = [\"core.md\"]\nDepth = 2:5","category":"page"},{"location":"core/#Integrations","page":"Core Interface","title":"Integrations","text":"","category":"section"},{"location":"core/","page":"Core Interface","title":"Core Interface","text":"Modules = [Integrations]","category":"page"},{"location":"core/#CtrlVQE.Integrations","page":"Core Interface","title":"CtrlVQE.Integrations","text":"Integrations\n\nEverything you need to know how to integrate over time.\n\n\n\n\n\n","category":"module"},{"location":"core/#CtrlVQE.Integrations.IntegrationType","page":"Core Interface","title":"CtrlVQE.Integrations.IntegrationType","text":"IntegrationType{F}\n\nEncapsulates a time-grid, used to decide how to integrate over time.\n\nType Parameters\n\nF denotes the type for time values. Must be a real float.\n\nImplementation\n\nAny concrete sub-type G must implement the Prototypes interface.\n\nIn addition, the following methods must be implemented.\n\nnsteps(::G): the total number of finite jumps within this time grid.\nThis is the maximum index of the timeat and stepat functions,       but it is NOT the length of the lattice, since the minimum index is 0.\ntimeat(::G, i::Int): time at index i (which may be zero)\nstepat(::G, i::Int): stepsize at index i (which may be zero)\nLet r be the number of steps, T be the duration,       and τ_i the step at index i.   Then _i=0^r τ_i = T.\nPrototype(::Type{G}, r::Int; T, kwargs...):   construct a prototypical grid of type G with r steps.\n\nAbstractVector Interface\n\nThis type implements the AbstractVector interface,     defined so that grid[i] == timeat(grid, i), where grid is the IntegrationType. Note that i here starts from 0. The collect function produces a concrete vector, in which i starts from 1. The lattice function does the same thing, but permits an allocation-free signature.\n\n\n\n\n\n","category":"type"},{"location":"core/#CtrlVQE.Integrations.duration-Tuple{CtrlVQE.Integrations.IntegrationType}","page":"Core Interface","title":"CtrlVQE.Integrations.duration","text":"duration(grid::IntegrationType)\n\nThe total duration, ie. the last time point minus the first.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Integrations.endtime-Tuple{CtrlVQE.Integrations.IntegrationType}","page":"Core Interface","title":"CtrlVQE.Integrations.endtime","text":"endtime(grid::IntegrationType)\n\nUpper bound of a time integral.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Integrations.integrate","page":"Core Interface","title":"CtrlVQE.Integrations.integrate","text":"integrate(grid::IntegrationType{F}, Φ)\n\nCompute the integral _0^T Φ(t)dt. Φ is a univariate scalar function of time, returning type F.\n\nintegrate(grid::IntegrationType, f̄::AbstractVector)\n\nTreat the elements of f̄ as the function evaluations Φ(t) above. The length of f̄ must be length(grid) and its eltype must be real.\n\nintegrate(grid::IntegrationType, Φ, f̄s::AbstractVector...)\n\nCompute the integral _0^T Φ(t f1 f2)dt,     where f1 is the value of f̄s[1] at the index corresponding to time t, etc. Φ is a multivariate scalar function,     of time and one argument for each f̄, returning type F. The length of each element in f̄s must be length(grid).\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Integrations.lattice-Tuple{CtrlVQE.Integrations.IntegrationType}","page":"Core Interface","title":"CtrlVQE.Integrations.lattice","text":"lattice(grid::IntegrationType; result=nothing)\n\nA vector of all time points.\n\nThis is equivalent to collect(grid) except for the result kwarg,     which allows the caller to provide a pre-allocated array.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Integrations.nsteps","page":"Core Interface","title":"CtrlVQE.Integrations.nsteps","text":"nsteps(grid::IntegrationType)::Int\n\nThe total number of finite jumps within this time grid.\n\nThis is the maximum index of the timeat and stepat functions,     but it is NOT the length of the lattice, since the minimum index is 0.\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Integrations.starttime-Tuple{CtrlVQE.Integrations.IntegrationType}","page":"Core Interface","title":"CtrlVQE.Integrations.starttime","text":"starttime(grid::IntegrationType)\n\nLower bound of a time integral.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Integrations.stepat","page":"Core Interface","title":"CtrlVQE.Integrations.stepat","text":"stepat(grid::IntegrationType{F}, i::Int)::F\n\nThe stepsize at index i (which may be zero).\n\nLet r be the number of steps, T be the duration,     and τ_i the step at index i. Then _i=0^r τ_i = T.\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Integrations.stepsize-Tuple{CtrlVQE.Integrations.IntegrationType}","page":"Core Interface","title":"CtrlVQE.Integrations.stepsize","text":"stepsize(grid::IntegrationType)\n\nThe average step size, ie. duration divided by number of steps.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Integrations.timeat","page":"Core Interface","title":"CtrlVQE.Integrations.timeat","text":"timeat(grid::IntegrationType{F}, i::Int)::F\n\nThe time at index i (which may be zero).\n\n\n\n\n\n","category":"function"},{"location":"core/#Signals","page":"Core Interface","title":"Signals","text":"","category":"section"},{"location":"core/","page":"Core Interface","title":"Core Interface","text":"Modules = [Signals]","category":"page"},{"location":"core/#CtrlVQE.Signals","page":"Core Interface","title":"CtrlVQE.Signals","text":"Signals\n\nTime-dependent functions suitable for control signals with variational parameters.\n\nThe main motivation of this module     is to provide a common interface for analytical gradients and optimization.\n\n\n\n\n\n","category":"module"},{"location":"core/#CtrlVQE.Signals.ConstrainedSignal","page":"Core Interface","title":"CtrlVQE.Signals.ConstrainedSignal","text":"ConstrainedSignal(template::<:ParametricSignal, constraints::Vector{Symbol})\n\nThe parametric signal template, freezing all fields specified by constraints.\n\nFrozen parameters are omitted from the Parameters interface. In other words, they do not appear in Parameters.names or Parameters.values,     and they are not mutated by Parameters.bind!.\n\nExample\n\nSay you have a Trigonometric signal sub-typing ParametricSignal,     where all fields amplitude A, phase ϕ, and frequency ν     are registered as variational parameters. You want to run an optimization where the frequency ν is fixed to 4.608. Rather than implementing a whole new ParametricSignal     identical except for a different implementation of the parameters function,     use a ConstrainedSignal:\n\ntemplate = Trigonometric(0.0, 0.0, 4.608)   # Initialize A and ϕ to 0.0\nsignal = Constrained(template, :ν)\n\nNote that the Constrained constructor above is just syntactic sugar for:\n\nsignal = ConstrainedSignal(template, [:ν])\n\n\n\n\n\n","category":"type"},{"location":"core/#CtrlVQE.Signals.ParametricSignal","page":"Core Interface","title":"CtrlVQE.Signals.ParametricSignal","text":"ParametricSignal{P,R}\n\nThe super-type for simple user-defined SignalTypes.\n\nType Parameters\n\nP denotes the type of all variational parameters. Must be a real float.\nR denotes the type of Ω(t) itself. May be any number type.\n\nImplementation\n\nConcrete sub-types S must be mutable structs,     and all of its variational parameters     (as indicated by the parameters function) must have type P.\n\nThe following methods must be implemented:\n\nSignals.parameters(Ω::S):       returns a tuple of the fields in S treated as variational parameters.\nSignals.valueat(Ω::S, t::Real):       the actual function Ω(t). Must return a number of type R.\nSignals.partial(k::Int, Ω::S, t::Real):       the partial derivative Ωx_k evaluated at time t,       where x_k is Ω's k-th variational parameter       (ie. Parameters.names(Ω)[k]).       Must return a number of type R.\nBase.string(Ω::S, names::AbstractVector{String}):       a human-readable description of the signal,       inserting each element of names in the place of the corresponding parameter.   For example, complex constant signals may return a description like \"A + i B\",       where A and B are the \"names\" given by the names argument.\n\n\n\n\n\n","category":"type"},{"location":"core/#CtrlVQE.Signals.SignalType","page":"Core Interface","title":"CtrlVQE.Signals.SignalType","text":"SignalType{P,R}\n\nEncapsulates a parametric and differntiable scalar function Ω(t).\n\nType Parameters\n\nP denotes the type of all variational parameters. Must be a real float.\nR denotes the type of Ω(t) itself. May be any number type.\n\nImplementation\n\nAny concrete sub-type S must implement all the Parameters interface.\n\nIn particular, Parameters.values(Ω::S) must return a vector of type P.\nIf you are trying to create your own signal type,   you probably want to implement a ParametricSignal,   which already has an implementation for the Parameters interface.\n\nIn addition, the following methods must be implemented:\n\nvalueat(Ω::S, t::Real):       the actual function Ω(t). Must return a number of type R.\npartial(i::Int, Ω::S, t::Real):       the partial derivative Ωx_i evaluated at time t,       where x_i is Ω's i-th variational parameter (ie. Parameters.names(Ω)[i]).       Must return a number of type R.\nBase.string(Ω::S, names::AbstractVector{String}):       a human-readable description of the signal,       inserting each element of names in the place of the corresponding parameter.   For example, a complex constant signal might return a description like \"A + i B\",       where A and B are the \"names\" given by the names argument.\n\n\n\n\n\n","category":"type"},{"location":"core/#CtrlVQE.Signals.SignalType-Tuple{Any}","page":"Core Interface","title":"CtrlVQE.Signals.SignalType","text":"(signal::SignalType{P,R})(t)\n\nSyntactic sugar: if Ω is a SignalType, then Ω(t) gives valueat(Ω,t).\n\nThe time t may be a scalar time, (abstract) vector of times, or an IntegrationType.\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.string-Tuple{CtrlVQE.Signals.SignalType, AbstractVector{String}}","page":"Core Interface","title":"Base.string","text":"Base.string(Ω::SignalType, names::AbstractVector{String})::String\n\nSubstitutes the default name of each variational parameter for the ones in names.\n\nNote that this is not the usual signature for Base.string!\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.string-Tuple{CtrlVQE.Signals.SignalType}","page":"Core Interface","title":"Base.string","text":"Base.string(Ω::SignalType)\n\nA human-readable string description of the signal.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Signals.Constrained-Tuple{CtrlVQE.Signals.ParametricSignal, Vararg{Symbol}}","page":"Core Interface","title":"CtrlVQE.Signals.Constrained","text":"Constrained(template::ParametricSignal, constraints::Symbol...)\n\nConstruct a ConstrainedSignal from a ParametricSignal and the fields to freeze.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Signals.parameters","page":"Core Interface","title":"CtrlVQE.Signals.parameters","text":"parameters(::S<:ParametricSignal{P,R})::Tuple{Symbol...}\n\nReturns a tuple of the fields in S treated as variational parameters.\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Signals.parametertype-Union{Tuple{CtrlVQE.Signals.SignalType{P, R}}, Tuple{R}, Tuple{P}} where {P, R}","page":"Core Interface","title":"CtrlVQE.Signals.parametertype","text":"parametertype(signal)\n\nReturns the number type for parameters in signal.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Signals.partial","page":"Core Interface","title":"CtrlVQE.Signals.partial","text":"partial(k::Int, signal::SignalType{P,R}, t::Real)::R\n\nThe partial derivative Ωx_k_t.\n\nHere x_k is the signal's k-th variational parameter     (ie. Parameters.names(signal)[k]).\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Signals.partial-Union{Tuple{R}, Tuple{P}, Tuple{Int64, CtrlVQE.Signals.SignalType{P, R}, CtrlVQE.Integrations.IntegrationType}} where {P, R}","page":"Core Interface","title":"CtrlVQE.Signals.partial","text":"partial(i, signal, t̄; result=nothing)\n\nEvaluate the partial at each point in the time lattice defined by an integration.\n\nParameters\n\ni: indexes which parameter to take the partial derivative with respect to\nsignal: the SignalType.\ngrid: an IntegrationType.\n\nKeyword Arguments\n\nresult: if provided, a pre-allocated array to store the returned vector\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Signals.returntype-Union{Tuple{CtrlVQE.Signals.SignalType{P, R}}, Tuple{R}, Tuple{P}} where {P, R}","page":"Core Interface","title":"CtrlVQE.Signals.returntype","text":"returntype(signal)\n\nReturns the number type for function values of signal.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Signals.valueat","page":"Core Interface","title":"CtrlVQE.Signals.valueat","text":"valueat(signal::SignalType{P,R}, t::Real)::R\n\nThe signal at time t, ie. Ω(t).\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Signals.valueat-Union{Tuple{R}, Tuple{P}, Tuple{CtrlVQE.Signals.SignalType{P, R}, CtrlVQE.Integrations.IntegrationType}} where {P, R}","page":"Core Interface","title":"CtrlVQE.Signals.valueat","text":"valueat(signal, grid; result=nothing)\n\nEvaluate the signal at each point in the time lattice defined by an integration.\n\nParameters\n\nsignal: the SignalType.\ngrid: an IntegrationType.\n\nKeyword Arguments\n\nresult: if provided, a pre-allocated array to store the returned vector\n\n\n\n\n\n","category":"method"},{"location":"core/#Devices","page":"Core Interface","title":"Devices","text":"","category":"section"},{"location":"core/","page":"Core Interface","title":"Core Interface","text":"Modules = [Devices]","category":"page"},{"location":"core/#CtrlVQE.Devices","page":"Core Interface","title":"CtrlVQE.Devices","text":"Devices\n\nIn silico representation of quantum devices, in which quantum states evolve in time.\n\nIn this package,     the \"static\" components (e.g., qubit frequencies, couplings, etc.)     and the \"drive\" components (e.g., control signal, variational parameters, etc.)     are all integrated into a single DeviceType object. All you need to know how a quantum state ψ evolves up time T is in the device.\n\n\n\n\n\n","category":"module"},{"location":"core/#CtrlVQE.Devices.DeviceType","page":"Core Interface","title":"CtrlVQE.Devices.DeviceType","text":"DeviceType{F}\n\nEncapuslates a device Hamiltonian, under which quantum computational states evolve.\n\nType Parameters\n\nF: the float type associated with a device\n\nImplementation\n\nAny concrete sub-type D must implement the Prototypes and Parameters interfaces.\n\nIn particular, if any static operators in your device depend on variational parameters,   you should consult the \"Note on Caching\" below.\n\nIn addition, all methods in the following sections must be implemented.\n\nCounting methods\nAlgebra methods\nOperator methods\nGradient methods\nBenchmarking methods\n\nIf your device's drive channels are all local (acting on one qubit at a time),     you should implement a LocallyDrivenDevice,     which has a few extra requirements.\n\nCounting methods:\n\nnqubits(::D): the number of qubits in the device - call this n.\nnlevels(::D): the number of physical levels in each \"qubit\" - call this m.\nndrives(::D): the number of distinct drive channels.\nngrades(::D): the number of distinct gradient operators.\nnoperators(::D): the number of operators used to define an algebra for each \"qubit\".\n\nEach of these methods returns an integer.\n\nAlgebra methods:\n\nlocalalgebra(::D): a 4d array ā   where ā[:,:,σ,q] is the σ'th algebraic operator on qubit q, in the bare basis.\n\nThis method should define result=nothing as a keyword argument;     when passed, use it as the array to store your result in.\n\nOperator methods:\n\nqubithamiltonian(::D, ā, q::Int):       the static components of the device Hamiltonian local to qubit q.\nstaticcoupling(::D, ā):       the static components of the device Hamiltonian nonlocal to any one qubit.\ndriveoperator(::D, ā, i::Int, t::Real):       the distinct drive operator for channel i at time t\ngradeoperator(::D, ā, j::Int, t::Real):       the distinct gradient operator indexed by j at time t\n\nEach of these methods should define result=nothing as a keyword argument;     when passed, use it as the array to store your result in. When result is not passed, you should return a new array of type Complex{eltype(D)}. Aside from this, do your best to minimize allocations.\n\nEach of these methods takes a 4darray ā, indexed as described in localalgebra. For example, for an algebra defined in terms of bosonic ladder operators,     hat a_q might be accessed with ā[:,:,1,q]     and hat a_q^dagger with ā[:,:,1,q]'. For an algebra defined in terms of Pauli operators,     X_q might be accessed with ā[:,:,1,q],     Y_q with ā[:,:,2,q], and Z_q with ā[:,:,3,q].\n\nUsually, each ā[:,:,σ,q] is defined on the full Hilbert space (ie. m^n × m^n),     but sometimes the code exploits a simple tensor structure     by passing in local m × m operators instead,     so do not assume a specific size a priori. Do NOT modify these operators, as they are usually drawn from a cache.\n\nGradient methods:\n\ngradient(::D, grid::Integrations.IntegrationType, ϕ̄):       the gradient vector for each variational parameter in the device.\n\nEach partial is generally an integral over at least one gradient signal. The argument grid identifies the temporal lattice on which ϕ̄ is defined. The argument ϕ̄ is a 2d array; ϕ̄[:,:,j] contains the jth gradient signal     ϕ_j(t) evaluated at each point in grid.\n\nThis method should define result=nothing as a keyword argument;     when passed, use it as the array to store your result in.\n\nNotes on Caching\n\nThis module uses the Memoization package to cache some arrays as they are calculated.\n\nThis does not apply to any method which depends on an absolute time t,     though it does apply to methods depending only on a relative time τ. For example, the propagator for a static Hamiltonian is cached,     but not one for a drive Hamiltonian.\n\nUsually, variational parameters only affect time-dependent methods,     but if any of your device's static operators do depend on a variational parameter,     you should be careful to empty the cache when Parameters.bind! is called.\n\nYou can completely clear everything in the cache with:\n\nMemoization.empty_all_caches!()\n\nAlternatively, selectively clear caches for affected functions via:\n\nMemoization.empty_cache!(fn)\n\nI don't know if it's possible to selectively clear cached values for specific methods. If it can be done, it would require obtaining the actual Dict     being used as a cache for a particular function,     figuring out exactly how that cache is indexed,     and manually removing elements matching your targeted method signature.\n\n\n\n\n\n","category":"type"},{"location":"core/#CtrlVQE.Devices.LocallyDrivenDevice","page":"Core Interface","title":"CtrlVQE.Devices.LocallyDrivenDevice","text":"LocallyDrivenDevice\n\nSuper-type for device objects whose drive channels act locally on individual qubits.\n\nInherit from this type if your driveoperator and gradeoperator methods     depend only on a single qubit, i.e. ā[:,:,:,q]. This enables more efficient propagation methods which exploit a tensor product structure.\n\nImplementation\n\nAny concrete sub-type D must implement     everything required in the DeviceType interface,     so consult the documentation for DeviceType carefully.\n\nIn addition, the following methods must be implemented:\n\ndrivequbit(::D, i::Int): index of the qubit on which channel i is applied.\ngradequbit(::D, j::Int): index of the qubit associated with the jth gradient operator.\n\nIt's usually trivial to infer the channel index i associated with each gradient operator,     in which case gradequbit(device, j) = drivequbit(device, i),     but this is left as an implementation detail.\n\n\n\n\n\n","category":"type"},{"location":"core/#CtrlVQE.Devices.basisrotation-Tuple{CtrlVQE.Bases.BasisType, CtrlVQE.Bases.BasisType, CtrlVQE.Devices.DeviceType}","page":"Core Interface","title":"CtrlVQE.Devices.basisrotation","text":"basisrotation(tgt::Bases.BasisType, src::Bases.BasisType, device::DeviceType)\n\nCalculate the basis rotation U which transforms ψ_src  ψ_tgt = Uψ_src.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Devices.braket-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, AbstractVector, AbstractVector}","page":"Core Interface","title":"CtrlVQE.Devices.braket","text":"braket(op, device[, basis], ψ1, ψ2)\n\nThe braket of an operator describing a device with respect to states ψ1 and ψ2.\n\nIf A is the operator specified by op, this method calculates ψ1Aψ2.\n\nArguments\n\nop::Operators.OperatorType: which operator to estimate (eg. static, drive, etc.).\ndevice::DeviceType: which device is being described.\nbasis::Bases.BasisType: which basis the state ψ is represented in.       Defaults to Bases.BARE when omitted.\nψ1, ψ2: Statevectors defined over the full Hilbert space of the device.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Devices.dress-Tuple{CtrlVQE.Devices.DeviceType}","page":"Core Interface","title":"CtrlVQE.Devices.dress","text":"dress(device::DeviceType)\n\nDiagonalize the static Hamiltonian and apply some post-processing     to define the so-called DRESSED basis.\n\nCompute the vector of eigenvalues Λ and the rotation matrix U for a given basis.\n\nU is an operator acting on the global Hilbert space of the device.\n\nThe result is packed into a LinearAlgebra.Eigen object. It may be unpacked directly into a vector eigenvalues Λ and a matrix of eigenvectors U by\n\nΛ, U = dress(device)\n\nAlternatively:\n\nΛU = dress(device)\nΛ = ΛU.values\nU = ΛU.vectors\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Devices.driveoperator","page":"Core Interface","title":"CtrlVQE.Devices.driveoperator","text":"driveoperator(device::DeviceType, ā, i::Int, t::Real; result=nothing)\n\nThe distinct drive operator for channel i at time t.\n\nThis method is a function of algebraic operators given by ā[:,:,σ,q],     constructed the globalalgebra method. If device is a LocallyDrivenDevice,     ā may also have been constructed from the localalgebra method.\n\nThe array is stored in result if provided. If result is not provided, the array is of type Complex{eltype(device)}.\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Devices.drivequbit","page":"Core Interface","title":"CtrlVQE.Devices.drivequbit","text":"drivequbit(device, i::Int)::Int\n\nIndex of the qubit on which channel i is applied.\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Devices.evolve!-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, Real, AbstractVecOrMat{<:Complex{<:AbstractFloat}}}","page":"Core Interface","title":"CtrlVQE.Devices.evolve!","text":"evolve!(op, device[, basis], t, ψ)\n\nPropagate a state ψ by a time t under the Hermitian op describing a device.\n\nThis function is identical to propagate!,     except that the cache is not used for intermediate propagator matrices,     and that it is undefined for time-dependent operators. Look to the Evolutions module for algorithms compatible with time-dependence!\n\nArguments\n\nop::Operators.OperatorType: which operator to evolve under (eg. static, drive, etc.).\ndevice::DeviceType: which device is being described.\nbasis::Bases.BasisType: which basis the state ψ is represented in.       Defaults to Bases.BARE when omitted.\nt::Real: the amount to move forward in time by.\nψ: Either a vector or a matrix, defined over the full Hilbert space of the device.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Devices.evolver-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, Real}","page":"Core Interface","title":"CtrlVQE.Devices.evolver","text":"evolver(op, device[, basis], t; kwargs...)\n\nA unitary propagator describing evolution under a Hermitian operator for a time t.\n\nThis function is identical to propagator,     except that the argument t is considered an absolute time so it is never cached,     and that it is undefined for time-dependent operators. It exists solely to perform rotating-frame rotations at every time-step     without worrying about over-caching.\n\nArguments\n\nop::Operators.OperatorType: which operator to evolve under (eg. static, drive, etc.).\ndevice::DeviceType: which device is being described.\nbasis::Bases.BasisType: which basis the operator will be represented in.       Defaults to Bases.BARE when omitted.\nt::Real: the amount to move forward in time by.\n\nKeyword Arguments\n\nresult: a pre-allocated array of compatible type and shape, used to store the result.\nOmitting result returns an array of type Complex{eltype(device)}.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Devices.expectation-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, AbstractVector}","page":"Core Interface","title":"CtrlVQE.Devices.expectation","text":"expectation(op, device[, basis], ψ)\n\nThe expectation value of an operator describing a device with respect to the state ψ.\n\nIf A is the operator specified by op, this method calculates ψAψ.\n\nArguments\n\nop::Operators.OperatorType: which operator to estimate (eg. static, drive, etc.).\ndevice::DeviceType: which device is being described.\nbasis::Bases.BasisType: which basis the state ψ is represented in.       Defaults to Bases.BARE when omitted.\nψ: A statevector defined over the full Hilbert space of the device.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Devices.globalalgebra","page":"Core Interface","title":"CtrlVQE.Devices.globalalgebra","text":"globalalgebra(device::DeviceType[, basis::Bases.BasisType])\n\nA globalized version of the matrix list defined by localalgebra.\n\nThat is, each operator ā[:,:,q,σ] is an N⨯N matrix acting on the whole Hilbert space,     rather than an m⨯m matrix acting on the space of a single qubit.\n\n(N is used throughout the docs for nstates(device) and m for nlevels(device).)\n\nThe array is stored in result or, if not provided, returned from a cache.\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Devices.gradeoperator","page":"Core Interface","title":"CtrlVQE.Devices.gradeoperator","text":"gradeoperator(device::DeviceType, ā, j::Int, t::Real; result=nothing)\n\nThe distinct gradient operator indexed by j at time t.\n\nI have defined the \"gradient operator\" A_j as the Hermitian operator     for which the jth gradient signal is ϕ_j = λ(iA_j)ψ + ht.\n\nThis method is a function of algebraic operators given by ā[:,:,σ,q],     constructed the globalalgebra method. If device is a LocallyDrivenDevice,     ā may also have been constructed from the localalgebra method.\n\nThe array is stored in result if provided. If result is not provided, the array is of type Complex{eltype(device)}.\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Devices.gradequbit","page":"Core Interface","title":"CtrlVQE.Devices.gradequbit","text":"gradequbit(device, j::Int)::Int\n\nIndex of the qubit associated with the jth gradient operator.\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Devices.gradient","page":"Core Interface","title":"CtrlVQE.Devices.gradient","text":"gradient(::DeviceType, grid::Integrations.IntegrationType, ϕ; result=nothing)\n\nThe gradient vector of partials for each variational parameter in the device.\n\nEach partial is generally an integral over at least one gradient signal. The argument grid identifies the temporal lattice on which ϕ is defined. The argument ϕ is a 2d array; ϕ[:,j] contains the jth gradient signal     ϕ_j(t) evaluated at each point in grid.\n\nThe array is stored in result if provided.\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Devices.localalgebra","page":"Core Interface","title":"CtrlVQE.Devices.localalgebra","text":"localalgebra(::DeviceType; result=nothing)\n\nConstruct a 4d array ā representing all operators defining an algebra for all qubits.\n\nThe matrix ā[:,:,σ,q] is a local operator acting on the space of a single qubit     (meaning it is an m⨯m matrix, if m is the result of nlevels(device)).\n\nThe array is stored in result or, if not provided, returned from a cache. If result is not provided, the array is of type Complex{eltype(device)}.\n\nImplementation\n\nTo use the cache, simply include as the first line:\n\nisnothing(result) && return _localalgebra(device)\n\nIf there is nothing yet in the cache,     the _localalgebra function will simply call your method again,     but with an empty array passed as result.\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Devices.localdriveoperators-Tuple{CtrlVQE.Devices.LocallyDrivenDevice, Real}","page":"Core Interface","title":"CtrlVQE.Devices.localdriveoperators","text":"localdriveoperators(device, t; kwargs...)\n\nA matrix list v̄, where v̄[:,:,q] represents     a sum of all drives acting on qubit q in the bare basis.\n\nArguments\n\ndevice::LocallyDrivenDevice: which device is being described.\nt::Real: the time each drive operator is evaluated at.\n\nKeyword Arguments\n\nresult: a pre-allocated array of compatible type and shape, used to store the result.\nOmitting result will return an array with type Complex{eltype(device)}.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Devices.localdrivepropagators-Tuple{CtrlVQE.Devices.LocallyDrivenDevice, Real, Real}","page":"Core Interface","title":"CtrlVQE.Devices.localdrivepropagators","text":"localdrivepropagators(device, τ, t; kwargs...)\n\nA matrix list ū, where ū[:,:,q] is the propagator for a local drive term.\n\nArguments\n\ndevice::LocallyDrivenDevice: which device is being described.\nτ::Real: the amount to move forward in time by.       Note that the propagation is only approximate for time-dependent operators.       The smaller τ is, the more accurate the approximation.\nt::Real: the time each drive operator is evaluated at.\n\nKeyword Arguments\n\nresult: a pre-allocated array of compatible type and shape, used to store the result.\nOmitting result will return an array with type Complex{eltype(device)}.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Devices.localqubitevolvers-Tuple{CtrlVQE.Devices.DeviceType, Real}","page":"Core Interface","title":"CtrlVQE.Devices.localqubitevolvers","text":"localqubitevolvers(device, τ; kwargs...)\n\nA matrix list ū, where each ū[:,:,q] is a propagator for a local qubit hamiltonian.\n\nThis function is identical to localqubitevolvers,     except that the argument t is considered an absolute time so it is never cached.\n\nArguments\n\ndevice::DeviceType: which device is being described.\nτ::Real: the amount to move forward in time by.       Note that the propagation is only approximate for time-dependent operators.       The smaller τ is, the more accurate the approximation.\n\nKeyword Arguments\n\nresult: a pre-allocated array of compatible type and shape, used to store the result.\nOmitting result will return an array of type Complex{eltype(device)}.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Devices.localqubitoperators-Tuple{CtrlVQE.Devices.DeviceType}","page":"Core Interface","title":"CtrlVQE.Devices.localqubitoperators","text":"localqubitoperators(device[, basis]; kwargs...)\n\nA matrix list h̄, where each h̄[:,:,q] represents     a local qubit hamiltonian in the bare basis.\n\nArguments\n\ndevice::DeviceType: which device is being described.\n\nKeyword Arguments\n\nresult: a pre-allocated array of compatible type and shape, used to store the result.\nOmitting result will return a cached result, with type Complex{eltype(device)}.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Devices.localqubitpropagators-Tuple{CtrlVQE.Devices.DeviceType, Real}","page":"Core Interface","title":"CtrlVQE.Devices.localqubitpropagators","text":"localqubitpropagators(device, τ; kwargs...)\n\nA matrix list ū, where each ū[:,:,q] is a propagator     for a local qubit hamiltonian in the bare basis.\n\nArguments\n\ndevice::DeviceType: which device is being described.\nτ::Real: the amount to move forward in time by.\n\nKeyword Arguments\n\nresult: a pre-allocated array of compatible type and shape, used to store the result.\nOmitting result will return a cached result, with type Complex{eltype(device)}.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Devices.ndrives","page":"Core Interface","title":"CtrlVQE.Devices.ndrives","text":"ndrives(device::DeviceType)::Int\n\nThe number of distinct drive channels.\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Devices.ngrades","page":"Core Interface","title":"CtrlVQE.Devices.ngrades","text":"ngrades(device::DeviceType)::Int\n\nThe number of distinct gradient operators.\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Devices.nlevels","page":"Core Interface","title":"CtrlVQE.Devices.nlevels","text":"nlevels(device::DeviceType)::Int\n\nThe number of physical levels in each \"qubit\".\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Devices.noperators","page":"Core Interface","title":"CtrlVQE.Devices.noperators","text":"noperators(device::DeviceType)::Int\n\nThe number of operators used to define an algebra for each \"qubit\".\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Devices.nqubits","page":"Core Interface","title":"CtrlVQE.Devices.nqubits","text":"nqubits(device::DeviceType)::Int\n\nThe number of qubits in the device.\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Devices.nstates-Tuple{CtrlVQE.Devices.DeviceType}","page":"Core Interface","title":"CtrlVQE.Devices.nstates","text":"nstates(device::DeviceType)\n\nThe total number of states in the physical Hilbert space of the device.\n\n(This is as opposed to nlevels(device),     the number of states in the physical Hilbert space of a single independent qubit.)\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Devices.operator-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType}","page":"Core Interface","title":"CtrlVQE.Devices.operator","text":"operator(op, device[, basis]; kwargs...)\n\nA Hermitian operator describing a device, represented in the given basis.\n\nFor example, to construct the static Hamiltonian of a device in the dressed basis,     call operator(Operators.STATIC, device, Bases.DRESSED).\n\nArguments\n\nop::Operators.OperatorType: which operator to construct (eg. static, drive, etc.).\ndevice::DeviceType: which device is being described.\nbasis::Bases.BasisType: which basis the operator will be represented in.       Defaults to Bases.BARE when omitted.\n\nKeyword Arguments\n\nresult: a pre-allocated array of compatible type and shape, used to store the result.\nOmitting result returns an array of type Complex{eltype(device)}.   For static operators only, omitting result will return a cached result.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Devices.propagate!-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, Real, AbstractVecOrMat{<:Complex{<:AbstractFloat}}}","page":"Core Interface","title":"CtrlVQE.Devices.propagate!","text":"propagate!(op, device[, basis], τ, ψ)\n\nPropagate a state ψ by a small time τ under the Hermitian op describing a device.\n\nArguments\n\nop::Operators.OperatorType: which operator to evolve under (eg. static, drive, etc.).\ndevice::DeviceType: which device is being described.\nbasis::Bases.BasisType: which basis the state ψ is represented in.       Defaults to Bases.BARE when omitted.\nτ::Real: the amount to move forward in time by.       Note that the propagation is only approximate for time-dependent operators.       The smaller τ is, the more accurate the approximation.\nψ: Either a vector or a matrix, defined over the full Hilbert space of the device.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Devices.propagator-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, Real}","page":"Core Interface","title":"CtrlVQE.Devices.propagator","text":"propagator(op, device[, basis], τ; kwargs...)\n\nA unitary propagator describing evolution under a Hermitian operator for a small time τ.\n\nArguments\n\nop::Operators.OperatorType: which operator to evolve under (eg. static, drive, etc.).\ndevice::DeviceType: which device is being described.\nbasis::Bases.BasisType: which basis the operator will be represented in.       Defaults to Bases.BARE when omitted.\nτ::Real: the amount to move forward in time by.       Note that the propagation is only approximate for time-dependent operators.       The smaller τ is, the more accurate the approximation.\n\nKeyword Arguments\n\nresult: a pre-allocated array of compatible type and shape, used to store the result.\nOmitting result returns an array of type Complex{eltype(device)}.   For static operators only, omitting result will return a cached result.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.Devices.qubithamiltonian","page":"Core Interface","title":"CtrlVQE.Devices.qubithamiltonian","text":"qubithamiltonian(device::DeviceType, ā, q::Int; result=nothing)\n\nThe static components of the device Hamiltonian local to qubit q.\n\nThis method is a function of algebraic operators given by ā[:,:,σ,q],     constructed by either the localalgebra or globalalgebra methods.\n\nThe array is stored in result if provided. If result is not provided, the array is of type Complex{eltype(device)}.\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Devices.staticcoupling","page":"Core Interface","title":"CtrlVQE.Devices.staticcoupling","text":"staticcoupling(device::DeviceType, ā, q::Int; result=nothing)\n\nThe static components of the device Hamiltonian nonlocal to any one qubit.\n\nThis method is a function of algebraic operators given by ā[:,:,σ,q],     constructed the globalalgebra method.\n\nThe array is stored in result if provided. If result is not provided, the array is of type Complex{eltype(device)}.\n\n\n\n\n\n","category":"function"},{"location":"core/#Evolutions","page":"Core Interface","title":"Evolutions","text":"","category":"section"},{"location":"core/","page":"Core Interface","title":"Core Interface","text":"Modules = [Evolutions]","category":"page"},{"location":"core/#CtrlVQE.Evolutions","page":"Core Interface","title":"CtrlVQE.Evolutions","text":"Evolutions\n\nAlgorithms to run time evolution, and related constructs like gradient signals.\n\n\n\n\n\n","category":"module"},{"location":"core/#CtrlVQE.Evolutions.EvolutionType","page":"Core Interface","title":"CtrlVQE.Evolutions.EvolutionType","text":"EvolutionType\n\nDefines a particular algorithm for performing time evolution.\n\nImplementation\n\nAny concrete sub-type A must implement the following methods:\n\nworkbasis(::A): which Bases.BasisType the evolution algorithm uses\nevolve!(::A, device, grid, ψ; callback=nothing):   evolve a state ψ in-place on a time grid\n\nIf possible, it should also implement:\n\n`gradientsignals(::A, device, basis, grid, ψ0, r, Ō; kwargs...):   compute the gradient signals of a device corresponding to multiple observables\n\n\n\n\n\n","category":"type"},{"location":"core/#CtrlVQE.Evolutions.evolve","page":"Core Interface","title":"CtrlVQE.Evolutions.evolve","text":"evolve(evolution, device, grid, ψ0; result=nothing, kwargs...)\nevolve(evolution, device, basis, grid, ψ0; result=nothing, kwargs...)\n\nEvolve a quantum computational state under a device Hamiltonian.\n\nIf basis is provided, ψ0 is taken to be represented in that basis. Otherwise, the workbasis of evolution is assumed.\n\nThis method simply copies ψ0 (to result if provided, or else to a new array),     then calls the mutating function evolve! on the copy. Please see evolve! for detailed documentation.\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Evolutions.evolve!","page":"Core Interface","title":"CtrlVQE.Evolutions.evolve!","text":"evolve!(evolution, device, grid, ψ; callback=nothing)\nevolve!(evolution, device, basis, grid, ψ; callback=nothing)\n\nEvolve a quantum computational state in-place under a device Hamiltonian.\n\nThis method both mutates and returns ψ.\n\nArguments\n\nevolution::EvolutionType: which evolution algorithm to use.\ndevice::Devices.DeviceType: specifies which Hamiltonian to evolve under.\nbasis::Bases.BasisType: which basis ψ is represented in.   Assumed to be the workbasis of evolution when omitted.\ngrid::Integrations.IntegrationType:   defines the time integration bounds (eg. from 0 to T)\nψ::AbstractVector:   the initial statevector, defined on the full Hilbert space of the device.\n\nKeyword Arguments\n\ncallback: a function which is called at each iteration of the time evolution.       The function is passed three arguments:       - i: indexes the iteration       - t: the current time point       - ψ: the current statevector, in the work basis       The function is called after having evolved ψ into |ψ(t)⟩.\n\nImplementation\n\nOnly the signature omitting basis need be implemented,     so you can assume ψ is represented in whatever basis you return from workbasis.\n\nThe signature including basis will automatically rotate ψ into the workbasis,     call the method you implement, and then rotate back.\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Evolutions.gradientsignals","page":"Core Interface","title":"CtrlVQE.Evolutions.gradientsignals","text":"gradientsignals(evolution, device, grid, ψ, Ō; kwargs...)\ngradientsignals(evolution, device, basis, grid, ψ, Ō; kwargs...)\n\nThe gradient signals associated with a given device Hamiltonian, and an observable O.\n\nGradient signals are used to calculate analytical derivatives of a control pulse.\n\nArguments\n\nevolution::EvolutionType: which evolution algorithm to use.\ndevice::Devices.DeviceType: specifies which Hamiltonian to evolve under.       Also identifies each of the gradient operators used to calculate gradient signals.\nbasis::Bases.BasisType: which basis ψ is represented in.   Assumed to be the workbasis of evolution when omitted.\ngrid::Integrations.IntegrationType:   defines the time integration bounds (eg. from 0 to T)\nψ::AbstractVector:   the initial statevector, defined on the full Hilbert space of the device.\nŌ::Union{LAT.MatrixList,AbstractMatrix}:   a list of Hermitian observables, represented as matrices, or a single such matrix.   Gradients are calculated with respect to the expectation ⟨O⟩ at time T.\n\nThis method signature assumes ψ, Ō are represented in the workbasis of evolution.\n\nKeyword Arguments\n\nresult: an (optional) pre-allocated array to store gradient signals\ncallback: a function called at each iteration of the gradient signal calculation.       The function is passed three arguments:       - i: indexes the iteration       - t: the current time point       - ψ: the current statevector, in the BARE basis       The function is called after having evolved ψ into |ψ(t)⟩,           but before calculating ϕ̄[i,:]. Evolution here runs backwards.\n\nReturns\n\nA 3d array ϕ̄, where each ϕ̄[:,j,k] is the gradient signal ϕ_j(t)     defined with respect to the observable O_k,     or a 2d array when Ō is just a single matrix rather than a matrix list.\n\nExplanation\n\nA gradient signal ϕ_j(t) is defined with respect to a gradient operator A_j,     an observable O, a time-dependent state |ψ(t)⟩, and total pulse duration T.\n\nLet us define the expectation value E(T)  ψ(T)Oψ(T).\n\nDefine the co-state λ(t) as the (un-normalized) statevector     which satisfies E(T)=λ(t)ψ(t) for any time t∊[0,T]. The gradient signal is defined as ϕ_j(t)  λ(t)(iA_j)ψ(t) + ht.\n\nImplementation\n\nOnly the signature omitting basis need be implemented,     so can assume ψ, Ō are represented in whatever basis you return from workbasis.\n\nThe signature including basis will automatically rotate ψ, Ō into the workbasis     before calling the method you implement.\n\nSimiliarly, you should only implement the method where Ō is a MatrixList. When a single matrix, the (already-implemented) method will reshaped it into a MatrixList,     call the method you implement, and then reshape the resulting array.\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.Evolutions.workbasis","page":"Core Interface","title":"CtrlVQE.Evolutions.workbasis","text":"workbasis(evolution::EvolutionType)::Bases.BasisType\n\nWhich basis the evolution algorithm works in.\n\nAlso defines the default basis to interpret ψ as, in evolution methods.\n\n\n\n\n\n","category":"function"},{"location":"core/#Cost-Functions","page":"Core Interface","title":"Cost Functions","text":"","category":"section"},{"location":"core/","page":"Core Interface","title":"Core Interface","text":"Modules = [CostFunctions]","category":"page"},{"location":"core/#CtrlVQE.CostFunctions","page":"Core Interface","title":"CtrlVQE.CostFunctions","text":"CostFunctions\n\nDetailed instructions for how to compute an energy from a set of variational parameters.\n\nNote that the CostFunctionType defined here refers to a type, not a function. But you can call CostFunctions.cost_function(::CostFunctionType) to get a function. This is the thing you would feed into an optimizer.\n\n\n\n\n\n","category":"module"},{"location":"core/#CtrlVQE.CostFunctions.CostFunctionType","page":"Core Interface","title":"CtrlVQE.CostFunctions.CostFunctionType","text":"CostFunctionType{F}\n\nEncapsulates a cost function, the thing you plug into an optimization algorithm.\n\nImplementation\n\nAny concrete sub-type CF must implement the following methods:\n\ncost_function(::CF):       returns a Function which takes a parameter vector           and returns the output of the cost function       ie. a callable expression (x::Vector) -> f(x)\ngrad!function(::CF):       returns a mutating Function which takes a gradient vector (to be mutated)           and a parameter vector, and writes the gradient vector to the first argument.       As a matter of habit, the resulting gradient vector should also be returned.\nBase.length(::CF):       the number of parameters this cost function takes\n\nIf your cost function involves calculating the expectation value of a time-evolved state,     you should implement an EnergyFunction (even if it isn't strictly an energy). This type has a couple extra requirements to allow energy trajectories over the evolution.\n\n\n\n\n\n","category":"type"},{"location":"core/#CtrlVQE.CostFunctions.CostFunctionType-Tuple{AbstractVector}","page":"Core Interface","title":"CtrlVQE.CostFunctions.CostFunctionType","text":"(fn::CostFunctionType)(x̄::AbstractVector)\n\nEvaluate the value of fn at the point x̄.\n\nThis is syntactic sugar for constructing a dedicated cost_function and calling it. It will not normally take advantage of cached work variables,     so avoid using it in high-performance code.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.CostFunctions.EnergyFunction","page":"Core Interface","title":"CtrlVQE.CostFunctions.EnergyFunction","text":"EnergyFunction{F}\n\nSuper-type for cost functions calculating the expectation value of a time-evolved state.\n\nImplementation\n\nAny concrete sub-type CF must implement     everything required in the CostFunctionType interface,     so consult the documentation for CostFunctionType carefully.\n\nIn additon, the following method must be implemented:\n\ntrajectory_callback(::CF, E::AbstractVector; callback=nothing)       returns a Function compatible with Evolutions.evolve callback           ie. a callable expression (i::Int, t::Real, ψ::Vector) -> Nothing       which sets E[i] to the energy of a partially evolved wavefunction ψ.       If callback is provided, the function calls that callback afterwards.\n\nFinally, the following methods must now accept a keyword argument:\n\ncost_function(::CF; callback=nothing):       When callback is provided, the time evolution must call it at each timestep.\ngrad!function(::CF; ϕ=nothing):       When ϕ is provided, write the gradient signals to it.\n\n\n\n\n\n","category":"type"},{"location":"core/#Base.eltype-Union{Tuple{CtrlVQE.CostFunctions.CostFunctionType{F}}, Tuple{F}} where F","page":"Core Interface","title":"Base.eltype","text":"Base.eltype(fn::CostFunctionType)\n\nGives the number type for parameters of this cost function.\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.length-Tuple{CtrlVQE.CostFunctions.CostFunctionType}","page":"Core Interface","title":"Base.length","text":"Base.length(fn::CostFunctionType)::Int\n\nGives the number of parameters for this cost function.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.CostFunctions.cost_function","page":"Core Interface","title":"CtrlVQE.CostFunctions.cost_function","text":"cost_function(fn::CostFunctionType)::Function\n\nConverts the struct fn into a literal function of a parameter vector.\n\nThe function accepts a parameter vector x̄     which should have the type and length given by eltype(fn) and length(fn). The function returns the value of fn at the point x̄.\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.CostFunctions.cost_function-Tuple{CtrlVQE.CostFunctions.EnergyFunction}","page":"Core Interface","title":"CtrlVQE.CostFunctions.cost_function","text":"cost_function(fn::EnergyFunction; callback=nothing)\n\nSame as for CostFunctionType except that whenever the function is called,     the time evolution calls callback (if provided) in each time step.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.CostFunctions.grad!function","page":"Core Interface","title":"CtrlVQE.CostFunctions.grad!function","text":"grad!function(fn::CostFunctionType)::Function\n\nConstructs a (mutating) function to calculate the gradient of fn at a particular point.\n\nThe function accepts a gradient vector ∇f̄ (to be mutated) and a parameter vector x̄. Both should have the type and length given by eltype(fn) and length(fn). After the function is called, ∇f̄ contains the gradient of fn at the point x̄. As per the Julia guidelines on mutating functions, ∇f̄ itself should then be returned.\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.CostFunctions.grad!function-Tuple{CtrlVQE.CostFunctions.EnergyFunction}","page":"Core Interface","title":"CtrlVQE.CostFunctions.grad!function","text":"grad!function(fn::EnergyFunction; ϕ=nothing)\n\nSame as for CostFunctionType except that whenever the function is called,     ϕ (if provided) is updated to contain the gradient signals. The array ϕ should be a 3d array with shape (:,nG,nK),     where nK is the number of observables in the energy function,     nG is the number of gradient operators in the underlying device,     and the remaining dimension is the size of the time grid.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.CostFunctions.grad_function-Union{Tuple{CtrlVQE.CostFunctions.CostFunctionType{F}}, Tuple{F}} where F","page":"Core Interface","title":"CtrlVQE.CostFunctions.grad_function","text":"grad_function(fn::CostFunctionType)\n\nConstructs a Function to calculate the gradient of fn at a particular point.\n\nThe function accepts a parameter vector x̄     which should have the type and length given by eltype(fn) and length(fn). The function returns the gradient (a vector) of fn at the point x̄.\n\n\n\n\n\n","category":"method"},{"location":"core/#CtrlVQE.CostFunctions.nobservables","page":"Core Interface","title":"CtrlVQE.CostFunctions.nobservables","text":"nobservables(fn::EnergyFunction)::Int\n\nIdentify the number of Hermitian observables needed for this energy function.\n\nFor example, to measure the normalized energy,     separate observables are needed for both energy and normalization,     and the results are combined in a non-linear way to produce the final outcome.\n\n\n\n\n\n","category":"function"},{"location":"core/#CtrlVQE.CostFunctions.trajectory_callback","page":"Core Interface","title":"CtrlVQE.CostFunctions.trajectory_callback","text":"trajectory_callback(fn::EnergyFunction, E::AbstractVector; callback=nothing)::Function\n\nMake a callback to write the energy at each step of a time evolution.\n\nThe callback function should be compatible with Evolutions.evolve     (ie. a callable expression (i::Int, t::Real, ψ::Vector) -> Nothing),     which sets E[1+i] to the energy of a partially evolved wavefunction ψ. Note the 1+, due to i indexing a time integration, which starts from 0.\n\nIf callback is provided, the function calls that callback afterwards     (i.e. callback chaining).\n\n\n\n\n\n","category":"function"},{"location":"basics/","page":"Basic Implementations","title":"Basic Implementations","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"basics/#Basic-Implementations","page":"Basic Implementations","title":"Basic Implementations","text":"","category":"section"},{"location":"basics/","page":"Basic Implementations","title":"Basic Implementations","text":"Pages = [\"basics.md\"]\nDepth = 2:5","category":"page"},{"location":"basics/#Integrations","page":"Basic Implementations","title":"Integrations","text":"","category":"section"},{"location":"basics/","page":"Basic Implementations","title":"Basic Implementations","text":"Modules = [\n    TrapezoidalIntegrations,\n]","category":"page"},{"location":"basics/#CtrlVQE.TrapezoidalIntegrations.TrapezoidalIntegration","page":"Basic Implementations","title":"CtrlVQE.TrapezoidalIntegrations.TrapezoidalIntegration","text":"TrapezoidalIntegration(t0::F, tf::F, r::Int)\n\nFirst-order grid using a trapezoidal rule time integration.\n\nArguments\n\nt0, tf: lower and upper bounds of the integral\nr: the number of time steps (remember number of lattice points is r+1)\n\nExplanation\n\nThis grid gives a first-order quadrature,     meaning every step takes you forward in time.\n\nAdditionally, this grid uses uniform spacing. You'd think that would mean stepat(grid, i) would give τ_i = τ for every i,     where τ  T  r and T  t_f - t_0. But careful! The sum of all τ_i must match the length of the integral, ie. T. But there are r+1 points, and (r+1)⋅τ > T. How do we reconcile this? A \"Left Hand Sum\" would omit t=T from the time points;     a \"Right Hand Sum\" would omit t=0. The trapezoidal rule omits half a point from each.\n\nThat sounds awfully strange, but it's mathematically sound! We only integrate through half of each boundary time point t=0 and t=T. Thus, those points, and only those points, have a spacing of τ/2.\n\n\n\n\n\n","category":"type"},{"location":"basics/#CtrlVQE.TrapezoidalIntegrations.TemporalLattice-Tuple{Real, Int64}","page":"Basic Implementations","title":"CtrlVQE.TrapezoidalIntegrations.TemporalLattice","text":"TemporalLattice(T::Real, r::Int)\n\nConvenience constructor to make a trapezoidal time grid from t=0.0 to T.\n\njulia> grid = TemporalLattice(20.0, 400);\n\njulia> validate(grid);\n\njulia> Integrations.duration(grid)\n20.0\njulia> Integrations.nsteps(grid)\n400\n\n\n\n\n\n","category":"method"},{"location":"basics/#Signals","page":"Basic Implementations","title":"Signals","text":"","category":"section"},{"location":"basics/","page":"Basic Implementations","title":"Basic Implementations","text":"Modules = [\n    ConstantSignals,\n    CompositeSignals,\n    WindowedSignals\n]","category":"page"},{"location":"basics/#CtrlVQE.ConstantSignals.ComplexConstantSignal","page":"Basic Implementations","title":"CtrlVQE.ConstantSignals.ComplexConstantSignal","text":"ComplexConstantSignal(A::F, B::F) where {F<:AbstractFloat}\n\nThe constant complex signal Ω(t) = A + iB.\n\n\n\n\n\n","category":"type"},{"location":"basics/#CtrlVQE.ConstantSignals.ConstantSignal","page":"Basic Implementations","title":"CtrlVQE.ConstantSignals.ConstantSignal","text":"ConstantSignal(A::AbstractFloat)\n\nThe constant real signal Ω(t) = A.\n\n\n\n\n\n","category":"type"},{"location":"basics/#CtrlVQE.ConstantSignals.Constant","page":"Basic Implementations","title":"CtrlVQE.ConstantSignals.Constant","text":"Constant(A)\nConstant(A, B)\n\nConvenience constructors for a constant signal.\n\nThe single argument form constructs a ConstantSignal when given a real number,     or a ComplexConstantSignal when given a complex number. The two-argument form constructs a ComplexConstantSignal,     taking A as the real part and B as the imaginary part.\n\njulia> grid = TemporalLattice(20.0, 400);\n\njulia> realonly = Constant(2.0);\n\njulia> validate(realonly; grid=grid, t=10.0, rms=1e-6);\n\njulia> valueat(realonly, 10.0)\n2.0\njulia> Parameters.names(realonly)\n1-element Vector{String}:\n \"A\"\n\njulia> complex = Constant(2.0, 1.0);\n\njulia> validate(complex; grid=grid, t=10.0, rms=1e-6);\n\njulia> valueat(complex, 10.0)\n2.0 + 1.0im\njulia> Parameters.names(complex)\n2-element Vector{String}:\n \"A\"\n \"B\"\n\njulia> alsocomplex = Constant(2.0 + 1.0im);\n\njulia> validate(alsocomplex; grid=grid, t=10.0, rms=1e-6);\n\njulia> typeof(alsocomplex) == typeof(complex)\ntrue\njulia> valueat(alsocomplex, 10.0) == valueat(complex, 10.0)\ntrue\njulia> Parameters.names(alsocomplex) == Parameters.names(complex)\ntrue\n\njulia> imagfrozen = Constrained(complex, :B);\n\njulia> validate(imagfrozen; grid=grid, t=10.0, rms=1e-6);\n\njulia> valueat(imagfrozen, 10.0) == valueat(complex, 10.0)\ntrue\njulia> Parameters.names(imagfrozen) == Parameters.names(realonly)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"basics/#CtrlVQE.CompositeSignals.CompositeSignal","page":"Basic Implementations","title":"CtrlVQE.CompositeSignals.CompositeSignal","text":"CompositeSignal(components::AbstractVector{<:SignalType{P,R}})\n\nA signal which is the sum of each sub-signal in components.\n\nEach component should be the same type of signal, for type stability. If you need to compose different types of signals,     you should probably implement your own custom SignalType.\n\n\n\n\n\n","category":"type"},{"location":"basics/#CtrlVQE.CompositeSignals.Composed-Union{Tuple{Vararg{CtrlVQE.Signals.SignalType{P, R}}}, Tuple{R}, Tuple{P}} where {P, R}","page":"Basic Implementations","title":"CtrlVQE.CompositeSignals.Composed","text":"Composed(components::SignalType...)\n\nConvenience constructor to combine multiple signals into a CompositeSignal.\n\njulia> grid = TemporalLattice(20.0, 400);\n\njulia> realpart = Constrained(Constant(2.0+0.0im), :B);\n\njulia> imagpart = Constrained(Constant(0.0+1.0im), :A);\n\njulia> signal = Composed(realpart, imagpart);\n\njulia> validate(signal; grid=grid, t=10.0, rms=1e-6);\n\njulia> Parameters.names(signal)\n2-element Vector{String}:\n \"A.1\"\n \"B.2\"\n\n\n\n\n\n","category":"method"},{"location":"basics/#CtrlVQE.WindowedSignals.WindowedSignal","page":"Basic Implementations","title":"CtrlVQE.WindowedSignals.WindowedSignal","text":"WindowedSignal(windows, starttimes)\n\nA signal which applies a different function for each window.\n\nArguments\n\nwindows: a vector of signals\nstarttimes: a vector of times transitioning each window\n\nBoth windows and starttimes have the same length;     starttimes[i] indicates when windows[i] begins.\n\nThis signal is undefined for times t < starttimes[1]. Normally, starttimes[1] == 0.\n\nWindows with dynamically changing numbers of parameters are unsupported.\n\n\n\n\n\n","category":"type"},{"location":"basics/#CtrlVQE.WindowedSignals.Windowed","page":"Basic Implementations","title":"CtrlVQE.WindowedSignals.Windowed","text":"Windowed(signal, starttimes)\nWindowed(signal, T, W)\n\nConvenience constructors to segment a single signal into a WindowedSignal.\n\nFeed in starttimes directly,     or make W uniformly spaced windows up to maximum time T.\n\njulia> grid = TemporalLattice(20.0, 400);\n\njulia> signal = Windowed(Constant(2.0), 20.0, 5);\n\njulia> validate(signal; grid=grid, t=10.0, rms=1e-6);\n\njulia> Parameters.names(signal)\n5-element Vector{String}:\n \"A.1\"\n \"A.2\"\n \"A.3\"\n \"A.4\"\n \"A.5\"\n\n\n\n\n\n\n","category":"function"},{"location":"basics/#CtrlVQE.WindowedSignals.get_window_from_parameter-Tuple{WindowedSignal, Int64}","page":"Basic Implementations","title":"CtrlVQE.WindowedSignals.get_window_from_parameter","text":"get_window_from_parameter(signal::WindowedSignal, i::Int)\n\nIdentify the window index given a parameter index (by counting parameters in windows).\n\n\n\n\n\n","category":"method"},{"location":"basics/#CtrlVQE.WindowedSignals.get_window_from_time-Tuple{WindowedSignal, Real}","page":"Basic Implementations","title":"CtrlVQE.WindowedSignals.get_window_from_time","text":"get_window_from_time(signal::WindowedSignal, t::Real)\n\nIdentify the window index given the time (by inspecting starttimes).\n\n\n\n\n\n","category":"method"},{"location":"basics/#Devices","page":"Basic Implementations","title":"Devices","text":"","category":"section"},{"location":"basics/","page":"Basic Implementations","title":"Basic Implementations","text":"Modules = [\n    RealWindowedResonantTransmonDevices,\n    WindowedResonantTransmonDevices,\n    TransmonDevices,\n]","category":"page"},{"location":"basics/#CtrlVQE.RealWindowedResonantTransmonDevices.RealWindowedResonantTransmonDevice","page":"Basic Implementations","title":"CtrlVQE.RealWindowedResonantTransmonDevices.RealWindowedResonantTransmonDevice","text":"RealWindowedResonantTransmonDevice{m}(ω, δ, g, quples, T, Ω)\n\nA minimalist transmon device with real-valued constant windows driven on resonance.\n\nWindows are always equally spaced. Drives are approximated with RWA.\n\nType Parameters\n\nF: (inferred from arguments) the float type of this device\nm: the integer number of levels per transmon\n\nParameters\n\nω: an (abstract) vector of qubit resonance frequencies\nδ: an (abstract) vector of qubit anharmonicities\ng: an (abstract) vector of qubit coupling strengths\nquples: an (abstract) vector of quples identifying each coupling\nT: the total pulse duration applied on this device\nΩ: a matrix of complex amplitudes.   Ω[w,q] is the amplitude applied on qubit q in the time-window indexed by w.\n\n\n\n\n\n","category":"type"},{"location":"basics/#CtrlVQE.RealWindowedResonantTransmonDevices.RealWindowedResonantTransmonDevice-Union{Tuple{m}, Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{Quple}, Real, Int64}} where m","page":"Basic Implementations","title":"CtrlVQE.RealWindowedResonantTransmonDevices.RealWindowedResonantTransmonDevice","text":"RealWindowedResonantTransmonDevice{m}(ω, δ, g, quples, T, W::Int)\n\nConvenience constructor where Ω is initialized to zero, with W time windows.\n\n\n\n\n\n","category":"method"},{"location":"basics/#CtrlVQE.Prototypes.Prototype-Union{Tuple{Type{CtrlVQE.RealWindowedResonantTransmonDevices.RealWindowedResonantTransmonDevice{F, m}}}, Tuple{m}, Tuple{F}} where {F, m}","page":"Basic Implementations","title":"CtrlVQE.Prototypes.Prototype","text":"Prototype(::Type{RealWindowedResonantTransmonDevice{F,m}}, n::Int; kwargs...)\n\nA prototypical RealWindowedResonantTransmonDevice with the following decisions:\n\nAll anharmonicities are constant.\nCouplings are linear.\nEach coupling strength equals the difference in resonance frequencies   of the coupled qubits.\nBy default, all resonance frequencies are equally spaced   (so, coupling strengths are constant)   but this can be controlled through kwargs.\n\nDefault parameters are vaguely reminiscent of IBM devices circa 2021,     although the default behavior of linearly-spaced resonance frequencies     is not realistic and should be avoided outside of testing/benchmarking.\n\nKeyword Arguments\n\nω0=4.82: resonance frequency of first qubit.\nΔω=0.02: the spacing in resonance frequencies between adjacent qubits.   When passed as a float (including the default),       resonance frequencies are linearly spaced.   Instead, you can pass this as an explicit vector with n-1 elements.\nδ0=0.30: the constant anharmonicity.\nT=10.0: total pulse duration.\nW=1: number of window segments.\n\njulia> grid = TemporalLattice(20.0, 400);\n\njulia> device = Prototype(RWRTDevice{Float64,3}; n=2);\n\njulia> validate(device; grid=grid, t=10.0);\n\njulia> nlevels(device)\n3\njulia> nqubits(device)\n2\n\n\n\n\n\n","category":"method"},{"location":"basics/#CtrlVQE.RealWindowedResonantTransmonDevices.__windowindex-Tuple{CtrlVQE.RealWindowedResonantTransmonDevices.RealWindowedResonantTransmonDevice, Real}","page":"Basic Implementations","title":"CtrlVQE.RealWindowedResonantTransmonDevices.__windowindex","text":"__windowindex(device, t)\n\nInfer the column index of device.Ω i which time t falls.\n\n\n\n\n\n","category":"method"},{"location":"basics/#CtrlVQE.WindowedResonantTransmonDevices.WindowedResonantTransmonDevice","page":"Basic Implementations","title":"CtrlVQE.WindowedResonantTransmonDevices.WindowedResonantTransmonDevice","text":"WindowedResonantTransmonDevice{m}(ω, δ, g, quples, T, Ω)\n\nA minimalist transmon device with complex-constant windows driven on resonance.\n\nWindows are always equally spaced. Drives are approximated with RWA.\n\nType Parameters\n\nF: (inferred from arguments) the float type of this device\nm: the integer number of levels per transmon\n\nParameters\n\nω: an (abstract) vector of qubit resonance frequencies\nδ: an (abstract) vector of qubit anharmonicities\ng: an (abstract) vector of qubit coupling strengths\nquples: an (abstract) vector of quples identifying each coupling\nT: the total pulse duration applied on this device\nΩ: a matrix of complex amplitudes.   Ω[w,q] is the amplitude applied on qubit q in the time-window indexed by w.\n\n\n\n\n\n","category":"type"},{"location":"basics/#CtrlVQE.WindowedResonantTransmonDevices.WindowedResonantTransmonDevice-Union{Tuple{m}, Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{Quple}, Real, Int64}} where m","page":"Basic Implementations","title":"CtrlVQE.WindowedResonantTransmonDevices.WindowedResonantTransmonDevice","text":"WindowedResonantTransmonDevice{m}(ω, δ, g, quples, T, W::Int)\n\nConvenience constructor where Ω is initialized to zero, with W time windows.\n\n\n\n\n\n","category":"method"},{"location":"basics/#CtrlVQE.Prototypes.Prototype-Union{Tuple{Type{CtrlVQE.WindowedResonantTransmonDevices.WindowedResonantTransmonDevice{F, m}}}, Tuple{m}, Tuple{F}} where {F, m}","page":"Basic Implementations","title":"CtrlVQE.Prototypes.Prototype","text":"Prototype(::Type{WindowedResonantTransmonDevice{F,m}}, n::Int; kwargs...)\n\nA prototypical WindowedResonantTransmonDevice with the following decisions:\n\nAll anharmonicities are constant.\nCouplings are linear.\nEach coupling strength equals the difference in resonance frequencies   of the coupled qubits.\nBy default, all resonance frequencies are equally spaced   (so, coupling strengths are constant)   but this can be controlled through kwargs.\n\nDefault parameters are vaguely reminiscent of IBM devices circa 2021,     although the default behavior of linearly-spaced resonance frequencies     is not realistic and should be avoided outside of testing/benchmarking.\n\nKeyword Arguments\n\nω0=4.82: resonance frequency of first qubit.\nΔω=0.02: the spacing in resonance frequencies between adjacent qubits.   When passed as a float (including the default),       resonance frequencies are linearly spaced.   Instead, you can pass this as an explicit vector with n-1 elements.\nδ0=0.30: the constant anharmonicity.\nT=10.0: total pulse duration.\nW=1: number of window segments.\n\njulia> grid = TemporalLattice(20.0, 400);\n\njulia> device = Prototype(CWRTDevice{Float64,3}; n=2);\n\njulia> validate(device; grid=grid, t=10.0);\n\njulia> nlevels(device)\n3\njulia> nqubits(device)\n2\n\n\n\n\n\n","category":"method"},{"location":"basics/#CtrlVQE.WindowedResonantTransmonDevices.__windowindex-Tuple{CtrlVQE.WindowedResonantTransmonDevices.WindowedResonantTransmonDevice, Real}","page":"Basic Implementations","title":"CtrlVQE.WindowedResonantTransmonDevices.__windowindex","text":"__windowindex(device, t)\n\nInfer the column index of device.Ω i which time t falls.\n\n\n\n\n\n","category":"method"},{"location":"basics/#CtrlVQE.TransmonDevices.TransmonDevice","page":"Basic Implementations","title":"CtrlVQE.TransmonDevices.TransmonDevice","text":"TransmonDevice{m}(ω, δ, g, quples, q, Ω, Δ)\n\nA transmon device where control signals and drive frequencies are signals.\n\nDrives are approximated with RWA.\n\nType Parameters\n\nF: (inferred from arguments) the float type of this device\nm: the integer number of levels per transmon\n\nParameters\n\nω: an (abstract) vector of qubit resonance frequencies\nδ: an (abstract) vector of qubit anharmonicities\ng: an (abstract) vector of qubit coupling strengths\nquples: an (abstract) vector of quples identifying each coupling\nq: the qubits corresponding to each drive.\nΩ: an (abstract) vector of control signals for each drive. May be real or complex.\nΔ: an (abstract) vector of detunings for each drive frequency. Must be real.\n\n\n\n\n\n","category":"type"},{"location":"basics/#CtrlVQE.TransmonDevices.TransmonDevice-Union{Tuple{m}, Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{Quple}}} where m","page":"Basic Implementations","title":"CtrlVQE.TransmonDevices.TransmonDevice","text":"TransmonDevice{m}(ω, δ, g, quples; kwargs...)\n\nConvenience constructor allowing a more semantic approach to inputting signals.\n\nKeyword Arguments\n\nq: may be a an (abstract) vector of Int.       Defaults to one drive for each qubit (i.e. 1:length(ω))\nΩ: may be a SignalType or an (abstract) vector of SignalTypes.       If a single SignalType is provided, it is duplicated for each drive.\nΔ: may be a Bool or a SignalType or an (abstract) vector of SignalTypes.       If a single SignalType is provided, it is duplicated for each drive.       If Δ=true, drive frequencies are constant signals initialized on resonance.       If Δ=false (the default), drive frequencies are frozen on resonance.\n\n\n\n\n\n","category":"method"},{"location":"basics/#CtrlVQE.Prototypes.Prototype-Union{Tuple{Type{TransmonDevice{F, m}}}, Tuple{m}, Tuple{F}} where {F, m}","page":"Basic Implementations","title":"CtrlVQE.Prototypes.Prototype","text":"Prototype(::Type{TransmonDevice{F,m}}, n::Int; kwargs...)\n\nA prototypical TransmonDevice with the following decisions:\n\nAll anharmonicities are constant.\nCouplings are linear.\nEach coupling strength equals the difference in resonance frequencies   of the coupled qubits.\nBy default, all resonance frequencies are equally spaced   (so, coupling strengths are constant)   but this can be controlled through kwargs.\nDrives match those of the defaults when using the kwarg constructor.\n\nDefault parameters are vaguely reminiscent of IBM devices circa 2021,     although the default behavior of linearly-spaced resonance frequencies     is not realistic and should be avoided outside of testing/benchmarking.\n\nKeyword Arguments\n\nω0=4.82: resonance frequency of first qubit.\nΔω=0.02: the spacing in resonance frequencies between adjacent qubits.   When passed as a float (including the default),       resonance frequencies are linearly spaced.   Instead, you can pass this as an explicit vector with n-1 elements.\nδ0=0.30: the constant anharmonicity.\nT=10.0: the pulse duration,   but this has no effect since the default signals are constant.\n\njulia> grid = TemporalLattice(20.0, 400);\n\njulia> device = Prototype(TransmonDevice{Float64,3}; n=2);\n\njulia> validate(device; grid=grid, t=10.0);\n\njulia> nlevels(device)\n3\njulia> nqubits(device)\n2\n\n\n\n\n\n","category":"method"},{"location":"basics/#Evolutions","page":"Basic Implementations","title":"Evolutions","text":"","category":"section"},{"location":"basics/","page":"Basic Implementations","title":"Basic Implementations","text":"Modules = [\n    RotatingFrameEvolutions,\n    QubitFrameEvolutions,\n]","category":"page"},{"location":"basics/#CtrlVQE.RotatingFrameEvolutions.RotatingFrameEvolution","page":"Basic Implementations","title":"CtrlVQE.RotatingFrameEvolutions.RotatingFrameEvolution","text":"ROTATING_FRAME\n\nA Trotterization method calculating drive terms in the rotating frame of the device.\n\nThe work basis for this algorithm is Bases.DRESSED. This ensures the rotating-frame evolution U_t  exp(-itH_0) is quite cheap. Even so, this algorithm exponentiates the matrix U_t V(t) U_t at each time step,     so it is not terribly efficient.\n\nA gradientsignals method is not currently supported for this evolution algorithm.\n\njulia> grid = TemporalLattice(20.0, 400);\n\njulia> device = Prototype(TransmonDevice{Float64,2}; n=2);\n\njulia> evolution = ROTATING_FRAME;\n\njulia> validate(evolution; grid=grid, device=device, skipgradient=true);\n\njulia> workbasis(evolution)\nCtrlVQE.Bases.Dressed()\n\n\n\n\n\n\n","category":"type"},{"location":"basics/#CtrlVQE.QubitFrameEvolutions.QubitFrameEvolution","page":"Basic Implementations","title":"CtrlVQE.QubitFrameEvolutions.QubitFrameEvolution","text":"QUBIT_FRAME\n\nA Trotterization method alternately propagating static and drive terms.\n\nThe work basis for this algorithm is Bases.BARE. The static term propagator is expensive but only computed once. If the drive terms are local (as for a LocallyDrivenDevice),     the drive propagator is relatively cheap.\n\nBeware that this algorithm implicitly employs a trapezoidal rule,     irrespective of the grid passed to evolution functions.\n\njulia> grid = TemporalLattice(20.0, 400);\n\njulia> device = Prototype(TransmonDevice{Float64,2}; n=2);\n\njulia> evolution = QUBIT_FRAME;\n\njulia> validate(evolution; grid=grid, device=device, skipgradient=true);\n\njulia> workbasis(evolution)\nCtrlVQE.Bases.Bare()\n\n\n\n\n\n\n","category":"type"},{"location":"basics/#Cost-Functions","page":"Basic Implementations","title":"Cost Functions","text":"","category":"section"},{"location":"basics/","page":"Basic Implementations","title":"Basic Implementations","text":"Modules = [\n    DenseLeakageFunctions,\n    DenseObservableFunctions,\n    CompositeCostFunctions,\n    WindowedResonantPenalties,\n    SignalStrengthPenalties,\n    AmplitudePenalties,\n    DetuningPenalties,\n]","category":"page"},{"location":"basics/#CtrlVQE.DenseLeakageFunctions.DenseLeakage","page":"Basic Implementations","title":"CtrlVQE.DenseLeakageFunctions.DenseLeakage","text":"DenseLeakage(reference, device, basis, frame, grid, evolution)\n\nCalculate leakage of a reference state after evolution.\n\nLeakage is the probability of finding any qubit outside the |0⟩,|1⟩ subspace.\n\nParameters\n\nreference: the initial statevector before evolution.\ndevice: the device under which the state evolves.\nbasis: the basis that reference is input as,   and the basis which for which leakage is defined.\nframe: the rotating frame for which leakage is defined.\ngrid: the time grid on which the state evolves.\nevolution: the algorithm to calculate the time evolution.\n\njulia> grid = TemporalLattice(20.0, 400);\n\njulia> device = Prototype(TransmonDevice{Float64,2}; n=2);\n\njulia> ψ0 = LAT.basisvector(Complex{eltype(device)}, nstates(device), 1);\n\njulia> costfn = DenseLeakage(ψ0, device, Bases.DRESSED, Operators.STATIC, grid, QUBIT_FRAME);\n\njulia> validate(costfn; rms=1e-6, grid=grid, device=device);\n\n\n\n\n\n\n","category":"type"},{"location":"basics/#CtrlVQE.DenseObservableFunctions.DenseObservable","page":"Basic Implementations","title":"CtrlVQE.DenseObservableFunctions.DenseObservable","text":"DenseObservable(observable, reference, device, basis, frame, grid, evolution)\n\nCalculate the expectation value of an observable after evolution of a reference state.\n\nParameters\n\nobservable: the matrix (defined on the whole Hilbert space) to measure.\nreference: the initial statevector before evolution.\ndevice: the device under which the state evolves.\nbasis: the basis that observable and reference are input as.\nframe: the rotating frame in which observable is to be measured.\ngrid: the time grid on which the state evolves.\nevolution: the algorithm to calculate the time evolution.\n\njulia> grid = TemporalLattice(20.0, 400);\n\njulia> device = Prototype(TransmonDevice{Float64,2}; n=2);\n\njulia> ψ0 = LAT.basisvector(Complex{eltype(device)}, nstates(device), 1);\n\njulia> O = LAT.basisvectors(Complex{eltype(device)}, nstates(device));\n\njulia> costfn = DenseObservable(O, ψ0, device, Bases.DRESSED, Operators.STATIC, grid, QUBIT_FRAME);\n\njulia> validate(costfn; rms=1e-6, grid=grid, device=device);\n\n\n\n\n\n\n","category":"type"},{"location":"basics/#CtrlVQE.CompositeCostFunctions.CompositeCostFunction","page":"Basic Implementations","title":"CtrlVQE.CompositeCostFunctions.CompositeCostFunction","text":"CompositeCostFunction(components::AbstractVector{CostFunctionType})\n\nThe sum of several cost-functions, with matching length and float type.\n\nUse this eg. to combine an energy function with one or more penalty functions.\n\nThis struct records the last values computed (value or gradient)     for each cost function in its values and gradients fields.\n\nBeware that the components field is a vector with abstract eltype. This is a relatively mild form of type instability;     certain compiled code could hypothetically be sub-optimal. But it does not appear to cause any noticeable disadvantage;     see Examples/CompositeCostFunctions.\n\n\n\n\n\n","category":"type"},{"location":"basics/#CtrlVQE.CompositeCostFunctions.CompositeCostFunction-Union{Tuple{Vararg{CtrlVQE.CostFunctions.CostFunctionType{F}}}, Tuple{F}} where F","page":"Basic Implementations","title":"CtrlVQE.CompositeCostFunctions.CompositeCostFunction","text":"CompositeCostFunction(components::CostFunctionType{F}...)\n\nAlternate constructor, letting each function be passed as its own argument.\n\njulia> grid = TemporalLattice(20.0, 400);\n\njulia> device = Prototype(CWRTDevice{Float64,2}; n=2);\n\njulia> ψ0 = LAT.basisvector(Complex{eltype(device)}, nstates(device), 1);\n\njulia> O = LAT.basisvectors(Complex{eltype(device)}, nstates(device));\n\njulia> energyfn = DenseObservable(O, ψ0, device, Bases.DRESSED, Operators.STATIC, grid, QUBIT_FRAME);\n\njulia> penaltyfn = WindowedResonantPenalty(device; A=0.8);\n\njulia> costfn = CompositeCostFunction(energyfn, penaltyfn);\n\njulia> validate(costfn; rms=1e-6);\n\n\n\n\n\n\n","category":"method"},{"location":"basics/#CtrlVQE.WindowedResonantPenalties.WindowedResonantPenalty","page":"Basic Implementations","title":"CtrlVQE.WindowedResonantPenalties.WindowedResonantPenalty","text":"WindowedResonantPenalty(device, A::Vector, σ::Vector, λ::Vector)\n\nCompute penalties for exceeding the maximum amplitude of a device.\n\nLet u=\fracΩ-Aσ. When u0 the penalty is computed as Λ = λ xp(u - 1u).\n\nParameters\n\ndevice: a compatible device (see below).\nA: the maximum modulus of any amplitude, on each drive.\nσ: the steepness parameter of the penalty function, on each drive.\nλ: the strength parameter of the penalty function, on each drive\n\nDevice Compatibility\n\nIntended for use with the RWRTDevice and CWRTDevice provided in the basics,     this type should work if:\n\ndevice has a field Ω\nΩ is a matrix of (potentially complex) amplitudes, with n columns,   where n = Devices.nqubits(device).\nParameters.values(x) is a vectorization of Ω (and nothing else),   reinterpreted as a vector of floats when Ω is complex.\n\n\n\n\n\n","category":"type"},{"location":"basics/#CtrlVQE.WindowedResonantPenalties.WindowedResonantPenalty-Union{Tuple{CtrlVQE.Devices.DeviceType{F}}, Tuple{F}} where F","page":"Basic Implementations","title":"CtrlVQE.WindowedResonantPenalties.WindowedResonantPenalty","text":"WindowedResonantPenalty(device; A=1.0, σ=A, λ=1.0)\n\nAlternate constructor, with kwargs and sensible defaults.\n\nEach parameter may be provided as a vector or as a scalar,     in which case it is automatically expanded to a vector     where the given value is assigned to each qubit.\n\nWe have selected σ defaulting to A because heuristically it seems to work well. Don't feel too attached to that choice.\n\njulia> device = Prototype(CWRTDevice{Float64,2}; n=2);\n\njulia> costfn = WindowedResonantPenalty(device; A=0.8);\n\njulia> x = collect(range(0.0, 1.0, length(costfn)))\n4-element Vector{Float64}:\n 0.0\n 0.3333333333333333\n 0.6666666666666666\n 1.0\n\njulia> validate(costfn; x=x, rms=1e-6);\n\njulia> costfn(x)\n0.22571605879846993\njulia> grad_function(costfn)(x)\n4-element Vector{Float64}:\n 0.0\n 0.0\n 0.7767775331625435\n 1.1651662997438155\n\n\n\n\n\n\n","category":"method"},{"location":"basics/#CtrlVQE.SignalStrengthPenalties.SignalStrengthPenalty","page":"Basic Implementations","title":"CtrlVQE.SignalStrengthPenalties.SignalStrengthPenalty","text":"SignalStrengthPenalty(grid, signal, A, σ, λ)\n\nCompute penalties for a signal exceeding a maximum absolute value over a time interval.\n\nLet u(t)=fracΩ(t)-Aσ, where Ω(t) is defined by signal. When u0 the instantaneous penalty is computed as Λ(t) = λexpu(t) - 1u(t). The total penalty is frac1Tint_0^T Λ(t)dt,     where the integration is defined by grid.\n\nParameters\n\ngrid: defines the integration (including time bounds) over which to penalize.\nsignal: the signal to penalize.\nA: the maximum modulus of the signal.\nσ: the steepness parameter of the penalty function.\nλ: the strength parameter of the penalty function.\n\nNote that, if you do not wish the penalty to be normalized per unit time,     λ should be selected to be proportional to the duration of grid.\n\n\n\n\n\n","category":"type"},{"location":"basics/#CtrlVQE.SignalStrengthPenalties.SignalStrengthPenalty-Union{Tuple{R}, Tuple{F}, Tuple{CtrlVQE.Integrations.IntegrationType{F}, CtrlVQE.Signals.SignalType{F, R}}} where {F, R}","page":"Basic Implementations","title":"CtrlVQE.SignalStrengthPenalties.SignalStrengthPenalty","text":"SignalStrengthPenalty(device; A=1.0, σ=A, λ=1.0)\n\nAlternate constructor, with kwargs and sensible defaults.\n\nWe have selected σ defaulting to A because heuristically it seems to work well. Don't feel too attached to that choice.\n\njulia> grid = TemporalLattice(20.0, 400);\n\njulia> signal = Windowed(Constant(2.0), 20.0, 5);\n\njulia> costfn = SignalStrengthPenalty(grid, signal; A=0.8);\n\njulia> x = collect(range(0.0, 1.0, length(costfn)))\n5-element Vector{Float64}:\n 0.0\n 0.25\n 0.5\n 0.75\n 1.0\n\njulia> validate(costfn; x=x, rms=1e-6);\n\njulia> costfn(x)\n0.00473294635352182\njulia> grad_function(costfn)(x)\n5-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.10057511001233899\n\n\n\n\n\n\n","category":"method"},{"location":"basics/#CtrlVQE.AmplitudePenalties.AmplitudePenalty","page":"Basic Implementations","title":"CtrlVQE.AmplitudePenalties.AmplitudePenalty","text":"AmplitudePenalty(device::DeviceType, penalties::AbstractVector{<:CostFunctionType})\n\nThe sum of several penalty functions acting on a device's amplitude signals.\n\nIn order for this type to be usable,     each penalty in penalties must act on parameters corresponding to     the signals contained in device.Ω,     and parameters in device must be disjoint,     listing parameters for each device.Ω then each device.ν. This interface is suitable for the basic TransmonDevice.\n\nThis struct records the last values computed (value or gradient)     for each cost function in its values and gradients fields.\n\nBeware that the components field is a vector with abstract eltype. This is a relatively mild form of type instability;     certain compiled code could hypothetically be sub-optimal. But it does not appear to cause any noticeable disadvantage;     see Examples/CompositeCostFunctions.\n\njulia> grid = TemporalLattice(20.0, 400);\n\njulia> device = Prototype(TransmonDevice{Float64,2}; n=2);\n\njulia> penalties = [SignalStrengthPenalty(grid, signal; A=0.8) for signal in device.Ω];\n\njulia> costfn = AmplitudePenalty(device, penalties);\n\njulia> x = collect(range(0.0, 1.0, length(costfn)))\n4-element Vector{Float64}:\n 0.0\n 0.3333333333333333\n 0.6666666666666666\n 1.0\n\njulia> validate(costfn; x=x, rms=1e-6);\n\njulia> costfn(x)\n0.22571605879846895\njulia> grad_function(costfn)(x)\n4-element Vector{Float64}:\n 0.0\n 0.0\n 0.7767775331625492\n 1.165166299743822\n\n\n\n\n\n\n","category":"type"},{"location":"basics/#CtrlVQE.DetuningPenalties.DetuningPenalty","page":"Basic Implementations","title":"CtrlVQE.DetuningPenalties.DetuningPenalty","text":"DetuningPenalty(device::DeviceType, penalties::AbstractVector{<:CostFunctionType})\n\nThe sum of several penalty functions acting on a device's detuning signals.\n\nIn order for this type to be usable,     each penalty in penalties must act on parameters corresponding to     the signals contained in device.Δ,     and parameters in device must be disjoint,     listing parameters for each device.Ω then each device.Δ. This interface is suitable for the basic TransmonDevice.\n\nThis struct records the last values computed (value or gradient)     for each cost function in its values and gradients fields.\n\nBeware that the components field is a vector with abstract eltype. This is a relatively mild form of type instability;     certain compiled code could hypothetically be sub-optimal. But it does not appear to cause any noticeable disadvantage;     see Examples/CompositeCostFunctions.\n\njulia> grid = TemporalLattice(20.0, 400);\n\njulia> device = TransmonDevice{2}([4.82, 4.84], [0.00, 0.00], [0.02], [Quple(1,2)]; Ω=Constrained(Constant(zero(ComplexF64)), :B), Δ=Constant(zero(Float64)));\n\njulia> penalties = [SignalStrengthPenalty(grid, signal; A=0.8) for signal in device.Δ];\n\njulia> costfn = DetuningPenalty(device, penalties);\n\njulia> x = collect(range(0.0, 1.0, length(costfn)))\n4-element Vector{Float64}:\n 0.0\n 0.3333333333333333\n 0.6666666666666666\n 1.0\n\njulia> validate(costfn; x=x, rms=1e-6);\n\njulia> costfn(x)\n0.02351774585600897\njulia> grad_function(costfn)(x)\n4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.4997520994401937\n\n\n\n\n\n\n","category":"type"},{"location":"modulars/","page":"Modular Framework","title":"Modular Framework","text":"CurrentModule = CtrlVQE.ModularFramework","category":"page"},{"location":"modulars/#Modular-Framework","page":"Modular Framework","title":"Modular Framework","text":"","category":"section"},{"location":"modulars/","page":"Modular Framework","title":"Modular Framework","text":"Pages = [\"modulars.md\"]\nDepth = 2:5","category":"page"},{"location":"modulars/","page":"Modular Framework","title":"Modular Framework","text":"The types in CtrlVQE are designed to be as flexible as possible, while remaining performant. We did this by designing the DeviceType to represent the complete Hamiltonian,","category":"page"},{"location":"modulars/","page":"Modular Framework","title":"Modular Framework","text":"hat H(vec xt) = hat H_0(vec x) + sum_i hat V_i (vec xt)","category":"page"},{"location":"modulars/","page":"Modular Framework","title":"Modular Framework","text":"There is an interface to follow drift and drive terms are handled correctly and efficiently in time evolution,     but it is completely and entirely your choice how to implement them. But prioritizing flexibility and performance has a tendency to sacrifice readability and reusability.","category":"page"},{"location":"modulars/","page":"Modular Framework","title":"Modular Framework","text":"This package attempts to find a middle ground,     by splitting each bit of the Hamiltonian equation into chunks. That is, there is one type (AlgebraType) which defines the space on which each operator hat H, hat H_0, hat V_i acts. There is another (DriftType) defining hat H_0. There is another (DriveType) defining hat V_i.","category":"page"},{"location":"modulars/","page":"Modular Framework","title":"Modular Framework","text":"And to help keep the drives as modular as possible,     there is a MapperType to map \"device\" parameters to individual drift and drive. A more complete equation - which is itself less readable,     but it makes the code so much easier to work with - would be","category":"page"},{"location":"modulars/","page":"Modular Framework","title":"Modular Framework","text":"hat H(vec xt) = hat H_0(h(vec x)) + sum_i hat V_i(f_i(vec x) t)","category":"page"},{"location":"modulars/","page":"Modular Framework","title":"Modular Framework","text":"For example, let's say you're curious how a single three-qubit interaction term     in the static Hamiltonian of a transmon device would alter the minimal evolution time. This is a tiny change, but going from Basics,     it would seem to require implementing a whole new device type, and to do that correctly,     you'd have to be sure to implement the dozen or so methods required for new device types. You'll presumably just copy and paste from an existing implementation,     which is generally considered bad practice and has a tendency to produce unexpected bugs     (hence the desire for code reusability). And you'll generate a file with hundreds of lines of code,     a real pain to organize, document, and debug     (hence the desire for code readability).","category":"page"},{"location":"modulars/","page":"Modular Framework","title":"Modular Framework","text":"Going from here, you'd simply implement a new drift type, with two methods, and be done.","category":"page"},{"location":"modulars/#Core-Interface","page":"Modular Framework","title":"Core Interface","text":"","category":"section"},{"location":"modulars/","page":"Modular Framework","title":"Modular Framework","text":"Modules = [\n    ModularFramework,\n    LocalDevices,\n    Energies,\n    DrivePenalties,\n]","category":"page"},{"location":"modulars/#CtrlVQE.ModularFramework","page":"Modular Framework","title":"CtrlVQE.ModularFramework","text":"ModularFramework\n\nProvides a framework for designing devices and energy functions in a less monolithic way. Different behaviors are delegated to different types.\n\nBehavior for devices are divided into:\n\nAlgebraType\nDriftType\nDriveType\nParameterMap\n\nThese can be implemented by the user and then combined into a pre-existing concrete type,     usually LocalDevice.\n\nBehavior for energy functions are divided into:\n\nReferenceType\nMeasurementType\n\nThese can be implemented by the user and then combined     with an integration, device, and evolution     using the pre-existing concrete type Energy.\n\nEach type has a validate method defined, with the following signatures. (See the function's docstring for details.)\n\nvalidate(::AlgebraType)\nvalidate(::DriftType; algebra::AlgebraType)\nvalidate(::DriveType; algebra::AlgebraType, grid::IntegrationType, t)\nvalidate(::ParameterMap; device::DeviceType)\n\nvalidate(::ReferenceType; device::DeviceType)\nvalidate(::MeasurementType; grid::IntegrationType, device::DeviceType, t)\n\nTypes may optionally implement the Prototypes interface. Since these are often inter-dependent     (e.g. a prototypical DipoleDrive may depend on the DriftType),     prototypes defined here are implemented in a special file, Prototypes.jl,     and users defining their own types are advised to do something similar     for the sake of writing concise doctests.\n\n\n\n\n\n","category":"module"},{"location":"modulars/#CtrlVQE.ModularFramework.AlgebraType","page":"Modular Framework","title":"CtrlVQE.ModularFramework.AlgebraType","text":"AlgebraType{m,n}\n\nDefines a Hilbert space and an operator basis.\n\nDelegated the following methods:\n\nDevices.nlevels\nDevices.nqubits\nDevices.noperators\nDevices.localalgebra\n\nType Parameters\n\nm: the number of levels in each qubit\nn: the number of qubits\n\nImplementation\n\nSubtypes A must implement the following methods:\n\nDevices.noperators(::Type{A}):       how many unique operators define an algebra on one qubit.\nDevices.localalgebra(::A; result): a 4d array ā       where ā[:,:,σ,q] is the σ'th algebraic operator on qubit q, in the bare basis.\n\n\n\n\n\n","category":"type"},{"location":"modulars/#CtrlVQE.ModularFramework.DriftType","page":"Modular Framework","title":"CtrlVQE.ModularFramework.DriftType","text":"DriftType{A}\n\nDefines the static Hamiltonian hat H_0.\n\nDelegated the following methods:\n\nDevices.qubithamiltonian\nDevices.staticcoupling\n\nImplementation\n\nSubtypes H must implement the following methods:\n\nDevices.qubithamiltonian(::H, ā, q::Int; result):       the static components of the device Hamiltonian local to qubit q.\nDevices.staticcoupling(::H, ā; result):       the static components of the device Hamiltonian nonlocal to any one qubit.\n\nThe ā arg is a 4d array with all algebra operators,     like the one returned by Devices.localalgebra     (but not necessarily in a local basis).\n\n\n\n\n\n","category":"type"},{"location":"modulars/#CtrlVQE.ModularFramework.DriveType","page":"Modular Framework","title":"CtrlVQE.ModularFramework.DriveType","text":"DriveType{A}\n\nDefines a drive term hat V_i.\n\nDelegated the following methods:\n\nDevices.ngrades\nDevices.driveoperator\nDevices.gradeoperator\nDevices.gradient\n\nImplementation\n\nSubtypes V must implement the Parameters interface, and the following methods:\n\nngrades(::Type{<:V}): the number of distinct gradient operators for this drive type.\ndriveoperator(::V, ā, t::Real; result):       the distinct drive operator for this channel at time t.\ngradeoperator(::V, ā, j::Int, t::Real; result):       the distinct gradient operator indexed by j at time t.\ngradient(::V, grid::Integrations.IntegrationType, ϕ; result):       the gradient vector for each variational parameter in the device.\n\nNote that the drive index i is omitted from the interface for driveoperator,     and the grade index j is with respect to just this channel. That means j will only ever take values between 1 and ngrades(V). This is true of both the j in the signature of gradeoperator     and the column indices of ϕ in the signature of gradient.\n\n\n\n\n\n","category":"type"},{"location":"modulars/#CtrlVQE.ModularFramework.LocalDrive","page":"Modular Framework","title":"CtrlVQE.ModularFramework.LocalDrive","text":"LocalDrive{F,A}\n\nExtension of DriveType for hat V_i which act on a single qubit.\n\nDelegated drivequbit.\n\nImplementation\n\nSubtypes D must implement the DriveType interface, and the following method:\n\nDevices.drivequbit(::D): index of the qubit on which this drive is applied.\n\nNote that the drive index i is omitted from the interface for drivequbit.\n\n\n\n\n\n","category":"type"},{"location":"modulars/#CtrlVQE.ModularFramework.MeasurementType","page":"Modular Framework","title":"CtrlVQE.ModularFramework.MeasurementType","text":"MeasurementType{B,O}\n\nA protocol to measure scalars from a statevector.\n\nType Parameters\n\nB<:Bases.BasisType: the basis that a measurement takes place in.\nO<:Operators.OperatorType: the frame rotation that a measurement takes place in.   Specifically, identifies the static operator in the interacture picture,   so STATIC identifies the dressed frame and IDENTITY identifies the lab frame.\n\nImplementation\n\nTODO: Rather different now. Be sure to mention overriding initbasis/initframe if needed.\n\nSubtypes M must implement the following methods:\n\nmeasure(::M, device, ψ): measures a state given in the initbasis.\nobservables(::M, device; result): constructs the observables in the initbasis.\nCostFunctions.nobservables(::Type{M}):   the number of distinct observables involved in a measurement.\nDevices.gradient(::M, device, grid, ϕ, ψ; result):   calculates the gradient of device parameters, given gradient signals.\n\nIn Devices.gradient, ϕ[:,j,k] contains the jth gradient signal     ϕ_j(t) evaluated at each point in grid for observable k,     while ψ contains the wavefunction itself,     evolved to the end of the grid     and rotated into the measurement basis. For the most part, implementing types will simply delegate to device,     whose gradient method expects the 2d array ϕ[:,k]. When M consists of more than one observable,     it will need to decide how to combine the resulting gradients into one.\n\nWhile initbasis and initframe have default implementations     for singleton basis and operator types,     these methods will need to be overridden     if your measurement is ever needed with more complex types.\n\n\n\n\n\n","category":"type"},{"location":"modulars/#CtrlVQE.ModularFramework.ParameterMap","page":"Modular Framework","title":"CtrlVQE.ModularFramework.ParameterMap","text":"ParameterMap\n\nEnumerates the protocol for mapping device parameters to each drive.\n\nDelegated Parameters.names.\n\nImplementation\n\nSubtypes P must implement the following methods:\n\nParameters.names(::P, device): constructs a list of human-readable names       for each parameter in the device,       which is a device implementing the Parameters interface.   Certain implementations of ParameterMap may have additional requirements.\nsync!(::P, device): mutate the internal parameters of a device       to match those of its drives.\nmap_values(::P, device, i::Int; result):       computes drive parameters from device parameters.\nmap_gradients(::P, device, i::Int; result):       computes drive gradients with respect to device parameters.\n\n\n\n\n\n","category":"type"},{"location":"modulars/#CtrlVQE.ModularFramework.ReferenceType","page":"Modular Framework","title":"CtrlVQE.ModularFramework.ReferenceType","text":"ReferenceType{B}\n\nA protocol to prepare an initial statevector.\n\nType Parameters\n\nB<:Bases.BasisType: the basis that a reference was defined in\n\nImplementation\n\nSubtypes R must implement the following methods:\n\nprepare(::R, device; result): constructs the initial statevector in the initbasis.\n\nWhile initbasis has a default implementation for singleton basis types,     this method will need to be overridden     if your reference is ever needed with more complex types.\n\n\n\n\n\n","category":"type"},{"location":"modulars/#CtrlVQE.ModularFramework.algebratype","page":"Modular Framework","title":"CtrlVQE.ModularFramework.algebratype","text":"algebratype(object)\n\nFetch the algebra type backing this object.\n\n\n\n\n\n","category":"function"},{"location":"modulars/#CtrlVQE.ModularFramework.initbasis-Union{Tuple{CtrlVQE.ModularFramework.MeasurementType{B, O}}, Tuple{O}, Tuple{B}} where {B, O}","page":"Modular Framework","title":"CtrlVQE.ModularFramework.initbasis","text":"initbasis(measurement)\n\nFetch the basis that this measurement takes place in.\n\n\n\n\n\n","category":"method"},{"location":"modulars/#CtrlVQE.ModularFramework.initbasis-Union{Tuple{CtrlVQE.ModularFramework.ReferenceType{B}}, Tuple{B}} where B","page":"Modular Framework","title":"CtrlVQE.ModularFramework.initbasis","text":"initbasis(reference)\n\nFetch the basis that this reference was defined in.\n\n\n\n\n\n","category":"method"},{"location":"modulars/#CtrlVQE.ModularFramework.initframe-Union{Tuple{CtrlVQE.ModularFramework.MeasurementType{B, O}}, Tuple{O}, Tuple{B}} where {B, O}","page":"Modular Framework","title":"CtrlVQE.ModularFramework.initframe","text":"initframe(measurement)\n\nFetch the frame that this measurement takes place in.\n\nSpecifically, this function fetches the static operator in the interacture picture,     so STATIC identifies the dressed frame and IDENTITY identifies the lab frame.\n\n\n\n\n\n","category":"method"},{"location":"modulars/#CtrlVQE.ModularFramework.map_gradients","page":"Modular Framework","title":"CtrlVQE.ModularFramework.map_gradients","text":"map_gradients(pmap::ParameterMap, device::ModularDevice, i::Int; result)\n\nCompute gradients for parameters in a drive term, with respect to each device parameter.\n\nParameters\n\npmap: the ParameterMap defining the family of functions to map parameters.\ndevice: the device, giving the device parameters (via Parameters.values).       Certain implementations of ParameterMap may have additional requirements.\ni: identifies which function in the family (i.e. indexes the drive).\n\nReturns\n\nA matrix g, such that g[k,j] is _x_k y_j.\n\n\n\n\n\n","category":"function"},{"location":"modulars/#CtrlVQE.ModularFramework.map_values","page":"Modular Framework","title":"CtrlVQE.ModularFramework.map_values","text":"map_values(pmap::ParameterMap, device, i::Int; result)\n\nCompute the parameters for a drive term, as a function of all device parameters.\n\nParameters\n\npmap: the ParameterMap defining the family of functions to map parameters.\ndevice: the device, giving the device parameters (via Parameters.values).       Certain implementations of ParameterMap may have additional requirements.\ni: identifies which function in the family (i.e. indexes the drive).\n\n\n\n\n\n","category":"function"},{"location":"modulars/#CtrlVQE.ModularFramework.measure","page":"Modular Framework","title":"CtrlVQE.ModularFramework.measure","text":"measure(measurement, device, ψ)\nmeasure(measurement, device, ψ, t)\nmeasure(measurement, device, basis, ψ)\nmeasure(measurement, device, basis, ψ, t)\n\nMeasure the state ψ, provided in the given basis, at time t.\n\nParameters\n\nmeasurement::MeasurementType: the measurement protocol.\ndevice::DeviceType: the device being measured.\nbasis::BasisType: the basis that ψ is represented in.   Defaults to initbasis when omitted.\nψ::AbstractVector: the state to measure.\nt::Real: the time at which ψ is being measured,   i.e. the time over which to evolve the frame operator.   When t is omitted, the frame rotation is skipped.\n\n\n\n\n\n","category":"function"},{"location":"modulars/#CtrlVQE.ModularFramework.observables","page":"Modular Framework","title":"CtrlVQE.ModularFramework.observables","text":"observables(measurement, device; result=nothing)\nobservables(measurement, device, t; result=nothing)\nobservables(measurement, device, basis; result=nothing)\nobservables(measurement, device, basis, t; result=nothing)\n\nConstructs the Hermitian observables involved in this measurement.\n\nParameters\n\nmeasurement::MeasurementType: the measurement protocol.\ndevice::DeviceType: the device being measured.\nbasis::BasisType: the basis the observables are represented in.   Defaults to initbasis when omitted.\nt::Real: the time at which the measurement takes place,   i.e. the time over which to evolve the frame operator.   When t is omitted, the frame rotation is skipped.\n\nThe returned result is also written to the result kwarg when provided.\n\nReturns\n\nA 3darray indexed such that result[:,:,k] is the kth matrix,     the same format required by the parameter Ō in Evolutions.gradientsignal. The size of the third dimension must be equal to nobservables(measurement).\n\n\n\n\n\n","category":"function"},{"location":"modulars/#CtrlVQE.ModularFramework.prepare","page":"Modular Framework","title":"CtrlVQE.ModularFramework.prepare","text":"prepare(reference, device; result=nothing)\nprepare(reference, device, basis; result=nothing)\n\nPrepare the state and represent it as a statevector in the given basis.\n\nParameters\n\nreference::ReferenceType: the state preparation protocol.\ndevice::DeviceType: the device for which the state is being prepared.\nbasis::BasisType: the basis to represent the reference state in   (defaults to initbasis when omitted).\n\nThe returned result is also written to the result kwarg when provided.\n\n\n\n\n\n","category":"function"},{"location":"modulars/#CtrlVQE.ModularFramework.sync!","page":"Modular Framework","title":"CtrlVQE.ModularFramework.sync!","text":"sync!(device)\nsync!(pmap::ParameterMap, device)\n\nMutate the internal parameters of a device to match those of its drives.\n\nThe one-parameter signature requires device to have a property pmap,     which is the parameter map that will be used for dispatch. Both signatures require device to have the property x     which is a vector of all the parameters of device. Certain implementations of ParameterMap may have additional requirements.\n\nThis function may resize x.\n\n\n\n\n\n","category":"function"},{"location":"modulars/#CtrlVQE.ModularFramework.LocalDevices.LocalDevice","page":"Modular Framework","title":"CtrlVQE.ModularFramework.LocalDevices.LocalDevice","text":"LocalDevice(algebra, drift, drives, pmap, x)\n\nA totally modular device, with some restrictions (see below).\n\nParameters\n\nalgebra::AlgebraType: the algebra, defining the Hilbert space.\ndrift::DriftType: the drift term, describing the static Hamiltonian.\ndrives::Vector{<:DriveType} a vector of drive terms,       describing the time-dependent Hamiltonian.\npmap::ParameterMap: the parameter map,   defining the relationship between device and drive parameters.\nx::Vector{<:AbstractFloat}: the initial device parameters\nLocalDevice(F, algebra, drift, drives, pmap)\n\nThe typical constructor for a LocalDevice.\n\nParameters\n\nF: the float type for this device (typically Float64).\nalgebra::AlgebraType: the algebra, defining the Hilbert space.\ndrift::DriftType: the drift term, describing the static Hamiltonian.\ndrives::Vector{<:DriveType} a vector of drive terms,       describing the time-dependent Hamiltonian.\npmap::ParameterMap: the parameter map,   defining the relationship between device and drive parameters.\n\nThe device parameters are initialized to be consistent with drives     (though the degree of consistency is defined by pmap).\n\nRestrictions\n\nDrift can't be parametric\nI could program around this, but it would add an unnecessary amount of code for a feature I may never use.\nIn principle, another type could relax this restriction if:\ncompatible drift types implement the Parameters interface.\ncompatible parameter map types implement suitable versions   of map_values and map_gradients\nthe bind! method clears relevant methods from the Memoization.jl cache.\nall loops in this file with parameter manipulation include a step for the drift.\nOnly works with LocalDrives\nThis restriction is necessary only due to lack of multiple inheritance in Julia. In other words, I have to subtype LocallyDrivenDevice     in order to get the fast evolution,     and that means I have to restrict the drives to those compatible with it. But none of the code here depends on it,     other than the parts implementing the interface for LocallyDrivenDevice.\nIn principle, another type could relax this restriction if:\nyou copy and paste the whole file.\nswitch out LocallDrivenDevice for LocalDevice\nswitch out LocalDrive with DriveType.\ndelete the parts with drivequbit and gradequbit.\n\n\n\n\n\n","category":"type"},{"location":"modulars/#CtrlVQE.ModularFramework.Energies.Energy","page":"Modular Framework","title":"CtrlVQE.ModularFramework.Energies.Energy","text":"Energy(evolution, device, grid, reference, measurement)\n\nA totally modular energy function.\n\nParameters\n\nevolution::EvolutionType: the time integration algorithm\ndevice::DeviceType: the device that gets evolved in time\ngrid::IntegrationType: the time grid to integrate over\nreference::ReferenceType: the reference state to initialize the device to\nmeasurement::MeasurementType: the protocol to extract energies from evolved states\n\n\n\n\n\n","category":"type"},{"location":"modulars/#CtrlVQE.ModularFramework.DrivePenalties.DrivePenalty","page":"Modular Framework","title":"CtrlVQE.ModularFramework.DrivePenalties.DrivePenalty","text":"DrivePenalty(device, penalties::AbstractVector{<:CostFunctionType})\n\nThe sum of several penalty functions acting on a device's drives.\n\nIn order for this type to be usable,     each penalty in penalties must act on parameters corresponding to     the drives contained in device.drives,     and device parameters must be mapped onto drives according to device.pmap. This interface is suitable for the Device types in ModularFramework.\n\nThis struct records the last values computed (value or gradient)     for each cost function in its values and gradients fields.\n\nBeware that the components field is a vector with abstract eltype. This is a relatively mild form of type instability;     certain compiled code could hypothetically be sub-optimal. But it does not appear to cause any noticeable disadvantage;     see Examples/CompositeCostFunctions.\n\n\n\n\n\n","category":"type"},{"location":"modulars/#Device-Modules","page":"Modular Framework","title":"Device Modules","text":"","category":"section"},{"location":"modulars/#Algebras","page":"Modular Framework","title":"Algebras","text":"","category":"section"},{"location":"modulars/","page":"Modular Framework","title":"Modular Framework","text":"Modules = [\n    TruncatedBosonicAlgebras,\n    PauliAlgebras,\n]","category":"page"},{"location":"modulars/#CtrlVQE.ModularFramework.TruncatedBosonicAlgebras.TruncatedBosonicAlgebra","page":"Modular Framework","title":"CtrlVQE.ModularFramework.TruncatedBosonicAlgebras.TruncatedBosonicAlgebra","text":"TruncatedBosonicAlgebra{m,n}()\n\nAn algebra of n distinguishable bosonic modes, each represented with m levels.\n\nThis algebra is useful for transmon architectures.\n\njulia> using CtrlVQE.ModularFramework;\n\njulia> A = TruncatedBosonicAlgebra{3,2};\n\njulia> validate(A());\n\njulia> nlevels(A)\n3\njulia> nqubits(A)\n2\njulia> noperators(A)\n1\n\n\n\n\n\n\n","category":"type"},{"location":"modulars/#CtrlVQE.ModularFramework.PauliAlgebras.PauliAlgebra","page":"Modular Framework","title":"CtrlVQE.ModularFramework.PauliAlgebras.PauliAlgebra","text":"PauliAlgebra{n}()\n\nAn algebra of n spinors, represented with the Pauli spin matrices.\n\njulia> using CtrlVQE.ModularFramework;\n\njulia> A = PauliAlgebra{4};\n\njulia> validate(A());\n\njulia> nlevels(A)\n2\njulia> nqubits(A)\n4\njulia> noperators(A)\n3\n\n\n\n\n\n\n","category":"type"},{"location":"modulars/#Drifts","page":"Modular Framework","title":"Drifts","text":"","category":"section"},{"location":"modulars/","page":"Modular Framework","title":"Modular Framework","text":"Modules = [\n    TransmonDrifts,\n]","category":"page"},{"location":"modulars/#CtrlVQE.ModularFramework.TransmonDrifts.TransmonDrift","page":"Modular Framework","title":"CtrlVQE.ModularFramework.TransmonDrifts.TransmonDrift","text":"TransmonDrift(ω, δ, g, quples)\n\nA static Hamiltonian for architectures of n transmons with fixed-couplings.\n\n``\\hat H0 = \\sumq ωq \\hat a^\\daggerq \\hat a_q\n\n\\sumq δq \\hat a^\\daggerq \\hat a^\\daggerq \\hat aq \\hat aq\n\\sum{⟨pq⟩} g{pq} (\\hat a^\\daggerp \\hat aq + \\hat a^\\daggerq \\hat ap)``\n\nParameters\n\nω: a vector of n resonance frequencies\nδ: a vector of n anharmonicities\ng: a vector of coupling strengths\nquples: a vector of Quple   identifying the qubit pairs associated with each g[i]\n\njulia> using CtrlVQE.ModularFramework;\n\njulia> A = TruncatedBosonicAlgebra{3,2};\n\njulia> drift = TransmonDrift{A}([4.82, 4.84], [0.30, 0.30], [0.02], [Quple(1,2)]);\n\njulia> validate(drift; algebra=A());\n\njulia> ā0 = Devices.localalgebra(A());\n\njulia> Devices.qubithamiltonian(drift, ā0, 1)\n3×3 Matrix{ComplexF64}:\n 0.0+0.0im   0.0+0.0im   0.0+0.0im\n 0.0+0.0im  4.82+0.0im   0.0+0.0im\n 0.0+0.0im   0.0+0.0im  9.34+0.0im\n\njulia> Devices.qubithamiltonian(drift, ā0, 2)\n3×3 Matrix{ComplexF64}:\n 0.0+0.0im   0.0+0.0im   0.0+0.0im\n 0.0+0.0im  4.84+0.0im   0.0+0.0im\n 0.0+0.0im   0.0+0.0im  9.38+0.0im\n\n\n\n\n\n\n","category":"type"},{"location":"modulars/#Drives","page":"Modular Framework","title":"Drives","text":"","category":"section"},{"location":"modulars/","page":"Modular Framework","title":"Modular Framework","text":"Modules = [\n    DipoleDrives,\n]","category":"page"},{"location":"modulars/#CtrlVQE.ModularFramework.DipoleDrives.DipoleDrive","page":"Modular Framework","title":"CtrlVQE.ModularFramework.DipoleDrives.DipoleDrive","text":"DipoleDrive(q, ω, Ω, Δ)\n\nA drive term representing interaction of a bosonic mode with an electric dipole,     in the rotating wave approximation.\n\nhat V = Ω(t) e^i Δ(t)+ω t hat a_q + rm ht\n\nParameters\n\nq: the integer index identifying which qubit this drive applies to\nω: the resonance frequency of the qubit\nΩ: a SignalType representing the complex drive strength over time\nΔ: a SignalType representing the detuning over time\n\njulia> grid = TemporalLattice(20.0, 400);\n\njulia> Ω = Constant(2.0+1.0im);\n\njulia> Δ = Constant(0.0);\n\njulia> using CtrlVQE.ModularFramework;\n\njulia> A = TruncatedBosonicAlgebra{3,2};\n\njulia> drive = DipoleDrive{A}(1, 4.82, Ω, Δ);\n\njulia> validate(drive; algebra=A(), grid=grid, t=10.0);\n\njulia> ā0 = Devices.localalgebra(A());\n\njulia> Devices.driveoperator(drive, ā0, 10.0)\n3×3 Matrix{ComplexF64}:\n        0.0+0.0im      -0.0693931-2.23499im         0.0+0.0im\n -0.0693931+2.23499im         0.0+0.0im      -0.0981367-3.16075im\n        0.0+0.0im      -0.0981367+3.16075im         0.0+0.0im\n\n\n\n\n\n\n","category":"type"},{"location":"modulars/#Parameter-Mappers","page":"Modular Framework","title":"Parameter Mappers","text":"","category":"section"},{"location":"modulars/","page":"Modular Framework","title":"Modular Framework","text":"Modules = [\n    DisjointMappers,\n    LinearMappers,\n]","category":"page"},{"location":"modulars/#CtrlVQE.ModularFramework.DisjointMappers.DisjointMapper","page":"Modular Framework","title":"CtrlVQE.ModularFramework.DisjointMappers.DisjointMapper","text":"DISJOINT\n\nUseful for when parameters for each drive are completely independent of one another.\n\nIn this case, all the parameters for drive 1     are followed by all the parameters for drive 2, and so on.\n\njulia> using CtrlVQE.ModularFramework;\n\njulia> pmap = DISJOINT;\n\njulia> device = Prototype(LocalDevice{Float64}; n=3, pmap=pmap);\n\njulia> validate(pmap; device=device);\n\njulia> map_values(pmap, device, 1)\n2-element Vector{Float64}:\n 0.0\n 0.0\n\njulia> Parameters.count(device)\n6\n\n\n\n\n\n\n","category":"type"},{"location":"modulars/#CtrlVQE.ModularFramework.LinearMappers.LinearMapper","page":"Modular Framework","title":"CtrlVQE.ModularFramework.LinearMappers.LinearMapper","text":"LinearMapper(encoding::Vector{F}, size::Vector{Int})\nLinearMapper(A::Array{F,3})\n\nAssociate each device parameter with the weight of a basis vector for each drive.\n\nThe implemetation of this type is designed     around the assumption that each drive has the same number of parameters.\n\nThe linear map A is a 3d array such that y[i] = A[:,:,i] * x,     where y[i] is the parameter vector for drive i     and x is the parameter vector for the whole device.\n\nA is represented internally as a data vector encoding and shape vector size,     so that it can be resized in-place.\n\njulia> using CtrlVQE.ModularFramework;\n\njulia> pmap = LinearMapper(ones(2,4,3));\n\njulia> device = Prototype(LocalDevice{Float64}; n=3, pmap=pmap);\n\njulia> validate(pmap; device=device);\n\njulia> map_values(pmap, device, 1)\n2-element Vector{Float64}:\n 0.0\n 0.0\n\njulia> Parameters.count(device)\n4\n\n\n\n\n\n\n","category":"type"},{"location":"modulars/#CtrlVQE.ModularFramework.LinearMappers.addbasisvector!-Union{Tuple{F}, Tuple{CtrlVQE.ModularFramework.LinearMappers.LinearMapper{F}, AbstractMatrix{F}}} where F","page":"Modular Framework","title":"CtrlVQE.ModularFramework.LinearMappers.addbasisvector!","text":"addbasisvector!(pmap, a)\n\nUpdate a LinearMapper to add in a new device parameter.\n\nYou'll pretty much always need to sync! a device after calling this.\n\nParameters\n\npmap: the LinearMapper object to mutate.\na::AbstractMatrix: a[:,i] contains the mapping   from the new device parameter to the parameters of drive i.\n\n\n\n\n\n","category":"method"},{"location":"modulars/#Energy-Modules","page":"Modular Framework","title":"Energy Modules","text":"","category":"section"},{"location":"modulars/#References","page":"Modular Framework","title":"References","text":"","category":"section"},{"location":"modulars/","page":"Modular Framework","title":"Modular Framework","text":"Modules = [\n    KetReferences,\n    DenseReferences,\n]","category":"page"},{"location":"modulars/#CtrlVQE.ModularFramework.KetReferences.KetReference","page":"Modular Framework","title":"CtrlVQE.ModularFramework.KetReferences.KetReference","text":"KetReference(basis::B, ket)\n\nRepresents a basis state of the given basis B.\n\nParameters\n\nbasis::Bases.BasisType: the basis this ket is defined in.\nket: a vector of integers representing the ket.   For example, [0,1,1] represents state |011⟩, the fourth basis state.   Note that index 1 of the ket is the most significant bit.\n\njulia> using CtrlVQE.ModularFramework;\n\njulia> reference = KetReference(BARE, [0,1]);\n\njulia> device = Prototype(LocalDevice{Float64}; n=2);\n\njulia> validate(reference; device=device);\n\njulia> prepare(reference, device)\n4-element Vector{ComplexF64}:\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n\n\n\n\n\n\n","category":"type"},{"location":"modulars/#CtrlVQE.ModularFramework.DenseReferences.DenseReference","page":"Modular Framework","title":"CtrlVQE.ModularFramework.DenseReferences.DenseReference","text":"DenseReference(basis::B, statevector; m, n)\n\nRepresents an arbitrary statevector of the given basis B.\n\nParameters\n\nbasis::Bases.BasisType: the basis where statevector represents the reference.\nstatevector::AbstractVector: a dense statevector.\n\nThe kwargs m and n specify the number of levels and number of qubits     for which the statevector is defined. The reference state may be prepared on a device with the same number of qubits,     and at least as many levels. Typically, only one of m and n are provided,     and the other is inferred from the length of statevector. If neither is provided, m defaults to 2. If both are provided, an error will be thrown     if they are not consistent with the length of statevector.\n\njulia> using CtrlVQE.ModularFramework;\n\njulia> reference = DenseReference(BARE, [0,1,0,0]);\n\njulia> device = Prototype(LocalDevice{Float64}; n=2);\n\njulia> validate(reference; device=device);\n\njulia> prepare(reference, device)\n4-element Vector{ComplexF64}:\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n\n\n\n\n\n\n","category":"type"},{"location":"modulars/#Measurements","page":"Modular Framework","title":"Measurements","text":"","category":"section"},{"location":"modulars/","page":"Modular Framework","title":"Modular Framework","text":"Modules = [\n    PauliMeasurements,\n    DenseMeasurements,\n]","category":"page"},{"location":"modulars/#CtrlVQE.ModularFramework.PauliMeasurements.PauliMeasurement","page":"Modular Framework","title":"CtrlVQE.ModularFramework.PauliMeasurements.PauliMeasurement","text":"PauliMeasurement(basis, frame, X, Z, c)\n\nRepresents a bare measurement of a linear combination of Paulis,     without any logical projection prior to frame rotation.\n\nPaulis are encoded symplectically, as two length-n bitstrings labeled x and z. 1s in x indicate a Pauli X appears on that bit; 1s in z indicate the same for Z. When a bit has both an X and a Z, it is interpreted as having a Y. (You could think of it as Z*X = iY, except the implementation here ignores phase.)\n\nParameters\n\nbasis: the BasisType identifying the basis observable is written in.\nframe: the OperatorType identifying the frame where measurements are conducted.\nX: a vector of integers whose bitstrings give each x.\nZ: a vector of integers whose bitstrings give each z.\nc: a vector of floats giving the coefficients for each pauli word.\n\n\n\n\n\n","category":"type"},{"location":"modulars/#CtrlVQE.ModularFramework.PauliMeasurements.PauliMeasurement-Union{Tuple{F}, Tuple{O}, Tuple{B}, Tuple{B, O, AbstractMatrix{F}}} where {B, O, F}","page":"Modular Framework","title":"CtrlVQE.ModularFramework.PauliMeasurements.PauliMeasurement","text":"PauliMeasurement(basis, frame, observable; eps=1e-10)\n\nA constructor accepting a dense matrix observable.\n\nThe Pauli coefficients are computed once from (a not very efficient implementation of)     the Hilbert-Schmidt inner product.\n\nParameters\n\nbasis: the BasisType identifying the basis observable is written in.\nframe: the OperatorType identifying the frame where measurements are conducted.\nobservable: the dense matrix observable.\neps: smallest coefficient to keep before discarding as negligible.\n\n\n\n\n\n","category":"method"},{"location":"modulars/#CtrlVQE.ModularFramework.PauliMeasurements.PauliMeasurement-Union{Tuple{O}, Tuple{B}, Tuple{B, O}} where {B, O}","page":"Modular Framework","title":"CtrlVQE.ModularFramework.PauliMeasurements.PauliMeasurement","text":"PauliMeasurement(basis, frame; paulis...)\n\nA constructor accepting coefficients for each Pauli word.\n\nParameters\n\nbasis: the BasisType identifying the basis observable is written in.\nframe: the OperatorType identifying the frame where measurements are conducted.\n\nKeyword Arguments\n\nEach key is a consistent-length string consisting only of \"I\", \"X\", \"Y\", \"Z\".\nEach value is the float coefficient for that Pauli word.\n\njulia> using CtrlVQE.ModularFramework;\n\njulia> I = [1 0; 0 1]; X = [0 1; 1 0]; Z = [1 0; 0 -1];\n\njulia> observable = (0.5 .* kron(X,Z)) .+ (1.0 .* kron(I, Z))\n4×4 Matrix{Float64}:\n 1.0   0.0  0.5   0.0\n 0.0  -1.0  0.0  -0.5\n 0.5   0.0  1.0   0.0\n 0.0  -0.5  0.0  -1.0\n\njulia> measurement = PauliMeasurement(BARE, STATIC; XZ=0.5, IZ=1.0);\n\njulia> device = Prototype(LocalDevice{Float64}; n=2);\n\njulia> validate(measurement; device=device);\n\njulia> Ō = observables(measurement, device);\n\njulia> size(Ō)\n(4, 4, 1)\n\njulia> observable ≈ reshape(Ō, (4,4))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"modulars/#CtrlVQE.ModularFramework.DenseMeasurements.DenseMeasurement","page":"Modular Framework","title":"CtrlVQE.ModularFramework.DenseMeasurements.DenseMeasurement","text":"DenseMeasurement(basis, frame, observable)\n\nRepresents a bare measurement of a matrix observable in a given basis and frame,     without any logical projection prior to frame rotation.\n\nParameters\n\nobservable: the dense matrix observable.\nbasis: the BasisType identifying the basis observable is written in.\nframe: the OperatorType identifying the frame where measurements are conducted.\n\nSpecifically, the operator identified by frame     is the one we rotate by for duration t     to move from the \"lab\" frame to the interaction picture. Use IDENTITY for the lab frame itslef, and STATIC for the dressed frame.\n\njulia> using CtrlVQE.ModularFramework;\n\njulia> I = [1 0; 0 1]; X = [0 1; 1 0]; Z = [1 0; 0 -1];\n\njulia> observable = (0.5 .* kron(X,Z)) .+ (1.0 .* kron(I, Z))\n4×4 Matrix{Float64}:\n 1.0   0.0  0.5   0.0\n 0.0  -1.0  0.0  -0.5\n 0.5   0.0  1.0   0.0\n 0.0  -0.5  0.0  -1.0\n\njulia> measurement = DenseMeasurement(BARE, STATIC, observable);\n\njulia> device = Prototype(LocalDevice{Float64}; n=2);\n\njulia> validate(measurement; device=device);\n\njulia> Ō = observables(measurement, device);\n\njulia> size(Ō)\n(4, 4, 1)\n\njulia> observable ≈ reshape(Ō, (4,4))\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"enums/","page":"Enumerations","title":"Enumerations","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"enums/#Enumerations","page":"Enumerations","title":"Enumerations","text":"","category":"section"},{"location":"enums/","page":"Enumerations","title":"Enumerations","text":"Pages = [\"enums.md\"]\nDepth = 2:5","category":"page"},{"location":"enums/#Parameters","page":"Enumerations","title":"Parameters","text":"","category":"section"},{"location":"enums/","page":"Enumerations","title":"Enumerations","text":"Modules = [Parameters]","category":"page"},{"location":"enums/#CtrlVQE.Parameters","page":"Enumerations","title":"CtrlVQE.Parameters","text":"Parameters\n\nStandardized interface for interacting with variational parameters.\n\nMost commonly encountered when implementing Signals and Devices.\n\n\n\n\n\n","category":"module"},{"location":"enums/#CtrlVQE.Parameters.bind!","page":"Enumerations","title":"CtrlVQE.Parameters.bind!","text":"bind!(entity, x̄::AbstractVector)\n\nAssigns new values for each variational parameter in entity.\n\nImplementation\n\nThis method should mutate entity such that, for example,     the expression bind!(entity, x̄); ȳ = values(entity); x̄ == ȳ evaluates true. The method should return entity,     in accordance with Julia's style guidelines for mutating functions.\n\n\n\n\n\n","category":"function"},{"location":"enums/#CtrlVQE.Parameters.count","page":"Enumerations","title":"CtrlVQE.Parameters.count","text":"count(entity)\n\nThe number of variational parameters in entity.\n\nImplementation\n\nMust return a non-negative integer.\n\n\n\n\n\n","category":"function"},{"location":"enums/#CtrlVQE.Parameters.names","page":"Enumerations","title":"CtrlVQE.Parameters.names","text":"names(entity)\n\nAn ordered list of human-readable names for each variational parameter in entity.\n\nImplementation\n\nMust return a vector of strings.\n\n\n\n\n\n","category":"function"},{"location":"enums/#CtrlVQE.Parameters.validate-Tuple{Any}","page":"Enumerations","title":"CtrlVQE.Parameters.validate","text":"validateparameters(entity)\n\nValidate an entity satisfies the Parameters interface.\n\n\n\n\n\n","category":"method"},{"location":"enums/#CtrlVQE.Parameters.values","page":"Enumerations","title":"CtrlVQE.Parameters.values","text":"values(entity)\n\nAn ordered list of the numerical values for each variational parameter in entity.\n\nThe resulting array should be treated as read-only,     since whether it is or isn't \"backed\" by entity is not enforced. That means changes to the resulting array MAY or MAY NOT modfiy entity. So don't do it!\n\nImplementation\n\nMust return a vector of some float type.\n\nIf at all possible, avoid allocating a new array when calling this function.\n\n\n\n\n\n","category":"function"},{"location":"enums/#Validation","page":"Enumerations","title":"Validation","text":"","category":"section"},{"location":"enums/","page":"Enumerations","title":"Enumerations","text":"Modules = [Validation]","category":"page"},{"location":"enums/#CtrlVQE.Validation","page":"Enumerations","title":"CtrlVQE.Validation","text":"Validation\n\nStandardized interface for ensuring user-defined types are consistent with the interface.\n\n\n\n\n\n","category":"module"},{"location":"enums/#CtrlVQE.Validation.validate","page":"Enumerations","title":"CtrlVQE.Validation.validate","text":"validate(type)\n\nCheck that type is consistent with the interface defined by its supertype.\n\nEach abstract type defined in the core interface implements its own validate,     running a suite of interface-compliance and self-consistency checks.\n\nEach type accepts a different collection of keyword arguments:\n\nvalidate(::IntegrationType)\nvalidate(::SignalType; grid::IntegrationType, t, rms)\nvalidate(::DeviceType; grid::IntegrationType, t)\nvalidate(::EvolutionType; grid::IntegrationType, device::DeviceType, skipgradient)\nvalidate(::CostFunctionType; x, rms)\nvalidate(::EnergyFunction; grid::IntegrationType, device::DeviceType, x, rms)\n\nIf grid and device are omitted, relevant tests will be skipped.\nNote in particular that validate(::EvolutionType) requires both in order to validate any evolution at all!\nAlso note that validate(::EnergyFunction) requires both for any validations special to energy functions, and they must be consistent with those used to construct the energy function, but if omitted the usual cost function tests will still occur.\nt (a single time) and x (a vector of parameters)       determine the point at which accuracy checks are conducted.   t defaults to one when omitted, and all x default to zero.\nrms is the maximum root mean square error permitted       between analytical gradients and finite differences.   It defaults to nothing, which skips the finite difference altogether.\nskipgradient is a flag indicating whether to skip anlaytical gradient validation,   useful for evolution types that don't bother to implement gradientsignals.\n\n\n\n\n\n","category":"function"},{"location":"enums/#CtrlVQE.Validation.@withresult-Tuple{Any}","page":"Enumerations","title":"CtrlVQE.Validation.@withresult","text":"result = @withresult fn(args...; kwargs...)\n\nValidate that a function accepting an optional result kwarg     calculates the same value with and without result,     and that, with result, the object returned is identical to the one passed.\n\n\n\n\n\n","category":"macro"},{"location":"enums/#Prototypes","page":"Enumerations","title":"Prototypes","text":"","category":"section"},{"location":"enums/","page":"Enumerations","title":"Enumerations","text":"Modules = [Prototypes]","category":"page"},{"location":"enums/#CtrlVQE.Prototypes","page":"Enumerations","title":"CtrlVQE.Prototypes","text":"Prototypes\n\nStandardized interface for quickly constructing certain objects.\n\n\n\n\n\n","category":"module"},{"location":"enums/#CtrlVQE.Prototypes.Prototype","page":"Enumerations","title":"CtrlVQE.Prototypes.Prototype","text":"Prototype(::Type{T}; kwargs...)\n\nConstruct a prototypical object of type T.\n\nEach type accepts a different collection of keyword arguments,     which is largely up to the user defining the type,     depending on how flexible they'd like their prototype function to be. However, certain keyword arguments must be accepted for certain abstract types,     in order for standard tests and benchmarking to work. But even these should be provided sensible default values.\n\nPrototype(::Type{<:DeviceType}; n::Int, T::Real, kwargs...)\nPrototype(::Type{<:IntegrationType}; T::Real, r::Int, kwargs...)\n\nn is the number of qubits.\nr is the total number of time steps.\nT is a default pulse duration (often but not always irrelevant in DeviceTypes).\n\n\n\n\n\n","category":"function"},{"location":"enums/#Operators","page":"Enumerations","title":"Operators","text":"","category":"section"},{"location":"enums/","page":"Enumerations","title":"Enumerations","text":"Modules = [Operators]","category":"page"},{"location":"enums/#CtrlVQE.Operators","page":"Enumerations","title":"CtrlVQE.Operators","text":"Operators\n\nEnumerates various categories of Hermitian observable related to a device.\n\n\n\n\n\n","category":"module"},{"location":"enums/#CtrlVQE.Operators.Channel","page":"Enumerations","title":"CtrlVQE.Operators.Channel","text":"Channel(i,t)\n\nAn individual drive term (indexed by i) at a specific time t.\n\nFor example, in a transmon device,     Channel(q,t) might represent Ω_q(t) exp(iν_qt) a_q + exp(-iν_qt) a_q,     the drive for a single qubit.\n\nNote that you are free to have multiple channels for each qubit,     or channels which operate on multiple qubits.\n\n\n\n\n\n","category":"type"},{"location":"enums/#CtrlVQE.Operators.Coupling","page":"Enumerations","title":"CtrlVQE.Operators.Coupling","text":"Coupling(), aka COUPLING\n\nThe components of the static Hamiltonian which are non-local to any one qubit.\n\nFor example, in a transmon device,     Coupling() represents the sum _pq g_pq (a_pa_q + a_qa_p).\n\n\n\n\n\n","category":"type"},{"location":"enums/#CtrlVQE.Operators.Drive","page":"Enumerations","title":"CtrlVQE.Operators.Drive","text":"Drive(t)\n\nThe sum of all drive terms at a specific time t.\n\nThis represents the sum of each Channel(i,t),     where i iterates over each drive term in the device.\n\nFor example, in a transmon device,     Drive(t) might represent _q Ω_q(t) exp(iν_qt) a_q + exp(-iν_qt) a_q.\n\n\n\n\n\n","category":"type"},{"location":"enums/#CtrlVQE.Operators.Gradient","page":"Enumerations","title":"CtrlVQE.Operators.Gradient","text":"Gradient(j,t)\n\nAn individual gradient operator (indexed by j) at a specific time t.\n\nThe gradient operators appear in the derivation of each gradient signal,     which are used to calculate analytical gradients of each variational parameter. The gradient operators are very closely related to individual channel operators,     but sufficiently distinct that they need to be treated separately.\n\nFor example, for a transmon device,     each channel operator Ω_q(t) exp(iν_qt) a_q + exp(-iν_qt) a_q     is associated with two gradient operators:\n\nexp(iν_qt) a_q + exp(-iν_qt) a_q\niexp(iν_qt) a_q - exp(-iν_qt) a_q\n\n\n\n\n\n","category":"type"},{"location":"enums/#CtrlVQE.Operators.Hamiltonian","page":"Enumerations","title":"CtrlVQE.Operators.Hamiltonian","text":"Hamiltonian(t)\n\nThe full Hamiltonian at a specific time t.\n\nThis represents the sum of Static() and Drive(t).\n\n\n\n\n\n","category":"type"},{"location":"enums/#CtrlVQE.Operators.Identity","page":"Enumerations","title":"CtrlVQE.Operators.Identity","text":"Identity(), aka IDENTITY\n\nThe identity operator.\n\n\n\n\n\n","category":"type"},{"location":"enums/#CtrlVQE.Operators.Qubit","page":"Enumerations","title":"CtrlVQE.Operators.Qubit","text":"Qubit(q)\n\nThe component of the static Hamiltonian which is local to qubit q.\n\nFor example, in a transmon device,     Qubit(2) represents a term ω_q a_qa_q - δ_q2 a_qa_qa_q a_q.\n\n\n\n\n\n","category":"type"},{"location":"enums/#CtrlVQE.Operators.Static","page":"Enumerations","title":"CtrlVQE.Operators.Static","text":"Static(), aka STATIC\n\nAll components of the static Hamiltonian.\n\nThis represents the sum of Uncoupled() and Coupled()\n\n\n\n\n\n","category":"type"},{"location":"enums/#CtrlVQE.Operators.Uncoupled","page":"Enumerations","title":"CtrlVQE.Operators.Uncoupled","text":"Uncoupled(), aka UNCOUPLED\n\nThe components of the static Hamiltonian which are local to each qubit.\n\nThis represents the sum of each Qubit(q),     where q iterates over each qubit in the device.\n\nFor example, in a transmon device,     Uncoupled() represents the sum _q (ω_q a_qa_q - δ_q2 a_qa_qa_q a_q).\n\n\n\n\n\n","category":"type"},{"location":"enums/#Bases","page":"Enumerations","title":"Bases","text":"","category":"section"},{"location":"enums/","page":"Enumerations","title":"Enumerations","text":"Modules = [Bases]","category":"page"},{"location":"enums/#CtrlVQE.Bases","page":"Enumerations","title":"CtrlVQE.Bases","text":"Bases\n\nEnumerates various linear-algebraic bases for representing statevectors and matrices.\n\n\n\n\n\n","category":"module"},{"location":"enums/#CtrlVQE.Bases.Bare","page":"Enumerations","title":"CtrlVQE.Bases.Bare","text":"Bare(), aka BARE\n\nThe \"default\" representation, defined by the localalgebra a Device implements.\n\nFor transmons, it is the eigenbasis of local number operators n  aa,     and generally, it is what would be called the \"computational basis\".\n\n\n\n\n\n","category":"type"},{"location":"enums/#CtrlVQE.Bases.Dressed","page":"Enumerations","title":"CtrlVQE.Bases.Dressed","text":"Dressed(), aka DRESSED\n\nThe eigenbasis of the static Hamiltonian associated with a Device. Eigenvectors are ordered to maximize similarity with an identity matrix. Phases are fixed so that the diagonal is real.\n\n\n\n\n\n","category":"type"},{"location":"","page":"CtrlVQE","title":"CtrlVQE","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"#CtrlVQE","page":"CtrlVQE","title":"CtrlVQE","text":"","category":"section"},{"location":"","page":"CtrlVQE","title":"CtrlVQE","text":"Documentation for CtrlVQE.","category":"page"},{"location":"","page":"CtrlVQE","title":"CtrlVQE","text":"Pages = [\n    \"utils.md\",\n    \"enums.md\",\n    \"core.md\",\n    \"basics.md\",\n    \"modulars.md\",\n]\nDepth = 1","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Pages = [\"utils.md\"]\nDepth = 2:5","category":"page"},{"location":"utils/#Quples","page":"Utilities","title":"Quples","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Modules = [Quples]","category":"page"},{"location":"utils/#CtrlVQE.Quples","page":"Utilities","title":"CtrlVQE.Quples","text":"Quples\n\nQubit tuples: simple types to represent couplings within a device.\n\n\n\n\n\n","category":"module"},{"location":"utils/#CtrlVQE.Quples.Quple","page":"Utilities","title":"CtrlVQE.Quples.Quple","text":"Quple(q1,q2)\n\nA (symmetric) coupling between qubits indexed by q1 and q2.\n\nThe order is irrelevant: Quple(q1,q2) === Quple(q2,q1).\n\n\n\n\n\n","category":"type"},{"location":"utils/#LinearAlgebraTools","page":"Utilities","title":"LinearAlgebraTools","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Modules = [LinearAlgebraTools]","category":"page"},{"location":"utils/#CtrlVQE.LinearAlgebraTools","page":"Utilities","title":"CtrlVQE.LinearAlgebraTools","text":"LinearAlgebraTools\n\nImplement some frequently-used linear-algebraic operations.\n\nConsider this to be a shallow extension of Julia's standard LinearAlgebra module,     taking advantage of Allocations whenever possible.\n\nNote that this module does not export anything. This is intentional - the risk of name collisions is very high with this module,     so I insist that no one ever writes using LinearAlgebraTools.\n\n\n\n\n\n","category":"module"},{"location":"utils/#CtrlVQE.LinearAlgebraTools.MatrixList","page":"Utilities","title":"CtrlVQE.LinearAlgebraTools.MatrixList","text":"MatrixList{T}\n\nSemantic alias for a 3d array representing a distinct matrix for each final index.\n\nIn other words, think of a MatrixList Ā semantically as a list A     where each A[i] = Ā[:,:,i] is a matrix.\n\n\n\n\n\n","category":"type"},{"location":"utils/#CtrlVQE.LinearAlgebraTools.VectorList","page":"Utilities","title":"CtrlVQE.LinearAlgebraTools.VectorList","text":"VectorList{T}\n\nSemantic alias for a 2d array representing a distinct vector in each column.\n\nThis is philosophically (but not operationally) distinct from a Matrix,     which may imply some additional structure relating columns.\n\n\n\n\n\n","category":"type"},{"location":"utils/#CtrlVQE.LinearAlgebraTools.basisvector-Tuple{Int64, Int64}","page":"Utilities","title":"CtrlVQE.LinearAlgebraTools.basisvector","text":"basisvector(N::Int, i::Int; result=nothing)\n\nConstruct a length-N basis vector for index i.\n\nThe result is written to result if provided. Otherwise returns a vector of type Bool.\n\nbasisvector(::Type{T}, N::Int, i::Int)\n\nConstruct a length-N basis vector of type T for index i.\n\njulia> LAT.basisvector(4, 2)\n4-element Vector{Bool}:\n 0\n 1\n 0\n 0\n\njulia> LAT.basisvector(ComplexF64, 4, 2)\n4-element Vector{ComplexF64}:\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"utils/#CtrlVQE.LinearAlgebraTools.basisvectors-Tuple{Int64}","page":"Utilities","title":"CtrlVQE.LinearAlgebraTools.basisvectors","text":"basisvectors(N::Int)\n\nConstruct a matrix of length-N basis vectors, aka an identity matrix.\n\nThe result is written to result if provided. Otherwise returns a matrix of type Bool.\n\nbasisvectors(::Type{T}, N::Int)\n\nConstruct a size-N identity matrix of type T.\n\njulia> LAT.basisvectors(4)\n4×4 Matrix{Bool}:\n 1  0  0  0\n 0  1  0  0\n 0  0  1  0\n 0  0  0  1\n\njulia> LAT.basisvectors(ComplexF64, 4)\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"utils/#CtrlVQE.LinearAlgebraTools.braket-Tuple{AbstractVector, Union{AbstractArray{T, 3} where T, AbstractMatrix}, AbstractVector}","page":"Utilities","title":"CtrlVQE.LinearAlgebraTools.braket","text":"braket(x1, A, x2)\n\nCompute the braket x1Ax2.\n\nParameters\n\nA: the operator to measure. Usually an (abstract) matrix.   When A is a MatrixList, the operator is a Kronecker product of each matrix.\nx1, x2: the states, both (abstract) vectors, to measure with respect to.   Note that x1 should be passed as a vector, NOT as a dual vector.\n\njulia> LAT.braket([1; 0], [0 1; 1 0], [0; 1]) # ⟨0|X|1⟩\n1\n\n\n\n\n\n","category":"method"},{"location":"utils/#CtrlVQE.LinearAlgebraTools.cis!","page":"Utilities","title":"CtrlVQE.LinearAlgebraTools.cis!","text":"cis!(A::AbstractMatrix, x=1)\n\nCalculates exp(ixA) for a Hermitian matrix A.\n\nThe name comes from the identity exp(ix) = Cos(x) + I Sin(x).\n\nNote that this method mutates A itself to the calculated exponential. Therefore, A must have a complex float type, and it must not be an immutable view. For example, even though A must be Hermitian for this method to work correctly,     it can't actually be a LinearAlgebra.Hermitian view.\n\njulia> A = ComplexF64[0 1; 1 0];\n\njulia> LAT.cis!(A, π/4) * √2\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+1.0im\n 0.0+1.0im  1.0+0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#CtrlVQE.LinearAlgebraTools.cis_type-Tuple{Any}","page":"Utilities","title":"CtrlVQE.LinearAlgebraTools.cis_type","text":"cis_type(x)\n\nPromote the number type of x to a complex float (compatible with cis operations).\n\nThe argument x may be a number, an array of numbers, or a number type itself.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CtrlVQE.LinearAlgebraTools.eigen!-Tuple{Vector, Matrix, AbstractMatrix}","page":"Utilities","title":"CtrlVQE.LinearAlgebraTools.eigen!","text":"eigen!(Λ::Vector, U::Matrix, A::Matrix)\n\nDiagonalize a matrix with minimal allocations.\n\nParameters\n\nΛ: Vector where eigenvalues are written.\nU: Matrix where eigenvectors are written. U[:,i] corresponds to Λ[i].\nA: An (abstract) matrix to diagonalize - assumed to be Hermitian.\n\nReturns\n\nThis function explicitly returns nothing.\n\njulia> Λ = zeros(2);\n\njulia> U = zeros(2,2);\n\njulia> LAT.eigen!(Λ, U, Float64[0 1; 1 0]);\n\njulia> Λ\n2-element Vector{Float64}:\n -1.0\n  1.0\n\njulia> U * √2\n2×2 Matrix{Float64}:\n  1.0  1.0\n -1.0  1.0\n\n\n\n\n\n\n","category":"method"},{"location":"utils/#CtrlVQE.LinearAlgebraTools.expectation-Tuple{Union{AbstractArray{T, 3} where T, AbstractMatrix}, AbstractVector}","page":"Utilities","title":"CtrlVQE.LinearAlgebraTools.expectation","text":"expectation(A, x)\n\nCompute the braket xAx.\n\nParameters\n\nA: the operator to measure. Usually a matrix.   When A is a MatrixList, the operator is a Kronecker product of each matrix.\nx: the state (a vector) to measure with respect to.\n\njulia> LAT.expectation([1 0; 0 -1], [0; 1]) # ⟨1|Z|1⟩\n-1\n\n\n\n\n\n","category":"method"},{"location":"utils/#CtrlVQE.LinearAlgebraTools.globalize-Union{Tuple{F}, Tuple{AbstractMatrix{F}, Int64, Int64}} where F","page":"Utilities","title":"CtrlVQE.LinearAlgebraTools.globalize","text":"globalize(op::AbstractMatrix, n::Int, q::Int; result=nothing)\n\nExtend a local operator op acting on qubit q,     into the global Hilbert space of n qubits.\n\nThe array is stored in result if provided.\n\njulia> LAT.globalize([0 1; 1 0], 2, 1) # X⊗I\n4×4 Matrix{Int64}:\n 0  0  1  0\n 0  0  0  1\n 1  0  0  0\n 0  1  0  0\n\njulia> LAT.globalize([0 1; 1 0], 2, 2) # I⊗X\n4×4 Matrix{Int64}:\n 0  1  0  0\n 1  0  0  0\n 0  0  0  1\n 0  0  1  0\n\n\n\n\n\n\n","category":"method"},{"location":"utils/#CtrlVQE.LinearAlgebraTools.kron","page":"Utilities","title":"CtrlVQE.LinearAlgebraTools.kron","text":"function kron(Ā; result=nothing)\n\nConstruct the Kronecker product of each element of Ā.\n\nParameters\n\nĀ: either a MatrixList (to construct a large matrix)   or a VectorList (to construct a large vector)\n\nOrdering: [x1; x2] ⊗ [y1; y2] = [x1⋅y1l  x1⋅y2;  x2⋅y1;  x2⋅y2]\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\njulia> LAT.kron([1 0; 0 1]) # |0⟩⊗|1⟩\n4-element Vector{Int64}:\n 0\n 1\n 0\n 0\n\njulia> LAT.kron([0 1; 1 0;;; 0 1; 1 0]) # X⊗X\n4×4 Matrix{Int64}:\n 0  0  0  1\n 0  0  1  0\n 0  1  0  0\n 1  0  0  0\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#CtrlVQE.LinearAlgebraTools.rotate!","page":"Utilities","title":"CtrlVQE.LinearAlgebraTools.rotate!","text":"rotate!(R, x)\n\nApply the rotation R to the object x, mutating x.\n\nGenerally, R is a unitary (or orthogonal) matrix. If x is a vector, rotate! computes x  Rx. If x is a matrix, rotate! computes x  RxR.\n\nYou may also pass R as a MatrixList,     which is interpreted as a rotation with a factorized tensor structure. In other words, if r̄ is a MatrixList,     rotate!(r̄, x) is equivalent to rotate!(kron(r̄), x),     except that the former has a more efficient implementation.\n\nSince this method mutates x,     the number type of x must be sufficiently expressive. For example, if R is a unitary matrix, x had better be a vector of complex floats.\n\njulia> LAT.rotate!([0 1; 1 0], [1; 0]) # X|0⟩\n2-element Vector{Int64}:\n 0\n 1\n\njulia> LAT.rotate!([0 1; 1 0], [1 0; 0 -1]) # XZX'\n2×2 Matrix{Int64}:\n -1  0\n  0  1\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#QubitOperations","page":"Utilities","title":"QubitOperations","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Modules = [QubitProjections]","category":"page"},{"location":"utils/#CtrlVQE.QubitProjections","page":"Utilities","title":"CtrlVQE.QubitProjections","text":"QubitProjections\n\nImplement some handy tools for working with specifically two-level systems.\n\n\n\n\n\n","category":"module"},{"location":"utils/#CtrlVQE.QubitProjections.isometrize-Union{Tuple{F}, Tuple{AbstractVector{F}, Int64, Int64}} where F","page":"Utilities","title":"CtrlVQE.QubitProjections.isometrize","text":"isometrize(A, n, m; result)\n\nLift or reduce a statevector or matrix for n qubits     onto a physical Hilbert space with just m levels per qubit.\n\nIf result is provided, results are written to result without further allocation.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CtrlVQE.QubitProjections.isometry-Tuple{Int64, Int64}","page":"Utilities","title":"CtrlVQE.QubitProjections.isometry","text":"isometry(n, m; m0=2, result)\n\nAn isometry lifting or reducing a system over m0 levels to m levels.\n\nThe result is an (m^n⨯m0^n) matrix,     acting on a vector with n qubits of m0 levels each,     and producing a vector with n qubits of m levels each.\n\nIf result is provided, results are written to result without further allocation.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CtrlVQE.QubitProjections.localisometries-Tuple{Int64, Int64}","page":"Utilities","title":"CtrlVQE.QubitProjections.localisometries","text":"localisometries(n, m; m0=2, result)\n\nA matrix list (aka a 3d array) of n local qubit isometries.\n\nEach isometry is an (m⨯m0) matrix,     acting on a vector with m0 levels and producing a vector with m levels.\n\nIf result is provided, results are written to result without further allocation.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CtrlVQE.QubitProjections.localprojectors-Tuple{Int64, Int64}","page":"Utilities","title":"CtrlVQE.QubitProjections.localprojectors","text":"localprojectors(n, m; m0=2, result)\n\nA matrix list (aka a 3d array) of n local qubit projectors.\n\nEach projector is an (m⨯m) matrix,     acting on a vector with m levels and producing a vector with the same size,     but support on only m0 levels.\n\nIf result is provided, results are written to result without further allocation.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CtrlVQE.QubitProjections.mapindex","page":"Utilities","title":"CtrlVQE.QubitProjections.mapindex","text":"mapindex(i0, n, m, m0=2)\n\nGiven an index i0 defined for vectors of n qubits with m0 levels each,     compute the corresponding index in a space with m levels each.\n\nThis function assumes m > m0. Otherwise, there may not be a corresponding index!\n\n\n\n\n\n","category":"function"},{"location":"utils/#CtrlVQE.QubitProjections.nlevels-Tuple{Int64, Int64}","page":"Utilities","title":"CtrlVQE.QubitProjections.nlevels","text":"nlevels(N, n)\n\nInfer the number of levels per qubit from the number of states and qubits.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CtrlVQE.QubitProjections.nqubits","page":"Utilities","title":"CtrlVQE.QubitProjections.nqubits","text":"nqubits(N, m=2)\n\nInfer the number of qubits from the number of states and levels per qubit.\n\n\n\n\n\n","category":"function"},{"location":"utils/#CtrlVQE.QubitProjections.nstates","page":"Utilities","title":"CtrlVQE.QubitProjections.nstates","text":"nstates(n, m=2)\n\nInfer the number of states from the number of qubits and levels per qubit.\n\n\n\n\n\n","category":"function"},{"location":"utils/#CtrlVQE.QubitProjections.projector-Tuple{Int64, Int64}","page":"Utilities","title":"CtrlVQE.QubitProjections.projector","text":"projector(n, m; m0=2, result)\n\nA projector from a system with m levels per qubit onto one with m0 levels.\n\nThe result is an (m^n⨯m^n) matrix,     acting on a vector with n qubits of m levels each,     producing a vector of the same size     but where each qubit has support on only the first m0 levels.\n\nIf result is provided, results are written to result without further allocation.\n\n\n\n\n\n","category":"method"}]
}
