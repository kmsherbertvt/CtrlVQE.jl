<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Evolutions · CtrlVQE.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://kmsherbertvt.github.io/CtrlVQE.jl/Evolutions/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CtrlVQE.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">CtrlVQE</a></li><li><a class="tocitem" href="../Bases/">Bases</a></li><li><a class="tocitem" href="../CostFunctions/">Cost Functions</a></li><li><a class="tocitem" href="../Devices/">Devices</a></li><li class="is-active"><a class="tocitem" href>Evolutions</a><ul class="internal"><li><a class="tocitem" href="#Trotter-Evolutions"><span>Trotter Evolutions</span></a></li></ul></li><li><a class="tocitem" href="../Integrations/">Integrations</a></li><li><a class="tocitem" href="../LinearAlgebraTools/">LinearAlgebraTools</a></li><li><a class="tocitem" href="../Operators/">Operators</a></li><li><a class="tocitem" href="../Parameters/">Parameters</a></li><li><a class="tocitem" href="../QubitOperators/">QubitOperators</a></li><li><a class="tocitem" href="../Signals/">Signals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Evolutions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Evolutions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/main/docs/src/Evolutions.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Evolutions"><a class="docs-heading-anchor" href="#Evolutions">Evolutions</a><a id="Evolutions-1"></a><a class="docs-heading-anchor-permalink" href="#Evolutions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Evolutions" href="#CtrlVQE.Evolutions"><code>CtrlVQE.Evolutions</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Evolutions</code></pre><p>Algorithms to run time evolution, and related constructs like gradient signals.</p><p>NOTE: the <code>trapezoidaltimegrid</code> function is a utility.     But it is implicitly tied to evolutions. I&#39;m not sure what to do about it.     It is an awkward space, similar to QubitOperators below.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/97e41c4808d0686eb3201497cf40287e81550dca/src/CtrlVQE.jl#L209-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Evolutions.EvolutionType" href="#CtrlVQE.Evolutions.EvolutionType"><code>CtrlVQE.Evolutions.EvolutionType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EvolutionType</code></pre><p>Super-type for all evolution algorithms.</p><p><strong>Implementation</strong></p><p>Any concrete sub-type <code>A</code> must implement the following methods:</p><ul><li><code>workbasis(::A)</code>: which Bases.BasisType the evolution algorithm uses</li><li><code>evolve!(::A, device, grid, ψ; callback=nothing)</code>: evolve ψ (in-place) on a time grid                                   (you may assume the basis of ψ is the work basis)</li></ul><p>You are allowed to implement <code>evolve!</code> for restricted types of <code>grid</code>     (eg. require it to be a <code>TrapezoidalIntegration</code>),     so long as you are clear in your documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/97e41c4808d0686eb3201497cf40287e81550dca/src/evols/Evolutions.jl#L19-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Evolutions.evolve" href="#CtrlVQE.Evolutions.evolve"><code>CtrlVQE.Evolutions.evolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evolve(evolution, device, [basis, ]grid, ψ0; result=nothing, kwargs...)</code></pre><p>Evolve a state <code>ψ0</code> over time <code>grid</code> under a <code>device</code> Hamiltonian, without mutating <code>ψ0</code>.</p><p>This method simply copies <code>ψ0</code> (to <code>result</code> if provided, or else to a new array),     then calls the mutating function <code>evolve!</code> on the copy. Please see <code>evolve!</code> for detailed documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/97e41c4808d0686eb3201497cf40287e81550dca/src/evols/Evolutions.jl#L105-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Evolutions.evolve!" href="#CtrlVQE.Evolutions.evolve!"><code>CtrlVQE.Evolutions.evolve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evolve!(evolution, device, [basis, ]T, ψ; basis=nothing, callback=nothing)</code></pre><p>Evolve a state <code>ψ</code> by time <code>T</code> under a <code>device</code> Hamiltonian.</p><p>This method both mutates and returns <code>ψ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>evolution::EvolutionType</code>: which evolution algorithm to use.</li><li><code>device::Devices.DeviceType</code>: specifies which Hamiltonian to evolve under.</li><li><code>basis::Bases.BasisType</code>: which basis <code>ψ</code> is represented in.       Implicitly defaults to <code>workbasis(evolution)</code>.</li><li><code>grid::TrapezoidalIntegration</code>: defines the time integration bounds (eg. from 0 to <code>T</code>)</li><li><code>ψ</code>: the initial statevector, defined on the full Hilbert space of the device.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>callback</code>: a function which is called at each iteration of the time evolution.       The function is passed three arguments:       - <code>i</code>: indexes the iteration       - <code>t</code>: the current time point       - <code>ψ</code>: the current statevector, in the work basis       The function is called after having evolved ψ into |ψ(t)⟩.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/97e41c4808d0686eb3201497cf40287e81550dca/src/evols/Evolutions.jl#L51-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Evolutions.gradientsignals-Tuple{CtrlVQE.Evolutions.EvolutionType, CtrlVQE.Devices.DeviceType, Vararg{Any}}" href="#CtrlVQE.Evolutions.gradientsignals-Tuple{CtrlVQE.Evolutions.EvolutionType, CtrlVQE.Devices.DeviceType, Vararg{Any}}"><code>CtrlVQE.Evolutions.gradientsignals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradientsignals(device[, basis], grid, ψ0, r, O; kwargs...)</code></pre><p>The gradient signals associated with a given <code>device</code> Hamiltonian, and an observable <code>O</code>.</p><p>Gradient signals are used to calculate analytical derivatives of a control pulse.</p><p>NOTE: Currently, this method assumes a trapezoidal rule,     so only <code>TrapezoidalIntegration</code> grids are allowed.</p><p><strong>Arguments</strong></p><ul><li><p><code>evolution::EvolutionType</code> how to initialize the co-state <code>|λ⟩</code>       A standard choice would be <code>ToggleEvolutions.Toggle(r)</code>.</p></li><li><p><code>device::Devices.DeviceType</code>: specifies which Hamiltonian to evolve under.       Also identifies each of the gradient operators used to calculate gradient signals.</p></li><li><p><code>basis::Bases.BasisType</code>: which basis <code>ψ</code> is represented in.       ALSO determines the basis in which calculations are carried out.       Defaults to <code>Bases.OCCUPATION</code>.</p></li><li><p><code>grid::TrapezoidalIntegration</code>: defines the time integration bounds (eg. from 0 to <code>T</code>)</p></li><li><p><code>ψ0</code>: the initial statevector, defined on the full Hilbert space of the device.</p></li><li><p><code>O</code>: a Hermitian observable, represented as a matrix.   Gradients are calculated with respect to the expectation <code>⟨O⟩</code> at time <code>T</code>.</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>result</code>: an (optional) pre-allocated array to store gradient signals</p></li><li><p><code>callback</code>: a function called at each iteration of the gradient signal calculation.       The function is passed three arguments:       - <code>i</code>: indexes the iteration       - <code>t</code>: the current time point       - <code>ψ</code>: the current statevector, in the OCCUPATION basis       The function is called after having evolved ψ into |ψ(t)⟩,           but before calculating ϕ̄[i,:]. Evolution here runs backwards.</p></li></ul><p><strong>Returns</strong></p><p>A vector list <code>ϕ̄</code>, where each <code>ϕ̄[:,j]</code> is the gradient signal <span>$ϕ_j(t)$</span>     evaluated on the given time grid.</p><p><strong>Explanation</strong></p><p>A gradient signal <span>$ϕ_j(t)$</span> is defined with respect to a gradient operator <span>$Â_j$</span>,     an observable <span>$Ô$</span>, a time-dependent state <code>|ψ(t)⟩</code>, and total pulse duration <code>T</code>.</p><p>Let us define the expectation value <span>$E(T) ≡ ⟨ψ(T)|Ô|ψ(T)⟩$</span>.</p><p>Define the co-state <span>$|λ(t)⟩$</span> as the (un-normalized) statevector     which satisfies <span>$E(T)=⟨λ(t)|ψ(t)⟩$</span> for any time <code>t∊[0,T]</code>. The gradient signal is defined as <span>$ϕ_j(t) ≡ ⟨λ(t)|(iÂ_j)|ψ(t)⟩ + h.t.$</span>.</p><pre><code class="nohighlight hljs">gradientsignals(device[, basis], T, ψ0, r, Ō; kwargs...)</code></pre><p>When the matrix argument <code>O</code> is replaced by a matrix list <code>Ō</code>,     each <code>Ō[:,:,k]</code> represents a different Hermitian observable <span>$Ô_k$</span>. In this case, a different set of gradient signals is computed for <em>each</em> <span>$Ô_k$</span>.</p><p><strong>Returns</strong></p><p>A 3d array <code>ϕ̄</code>, where each <code>ϕ̄[:,j,k]</code> is the gradient signal <span>$ϕ_j(t)$</span>     defined with respect to the observable <span>$Ô_k$</span>.</p><p><strong>Explanation</strong></p><p>Multiple sets of gradient signals may be useful     if you want to compute gradients with respect to multiple observables. For example, gradients with respect to a normalized molecular energy     include contributions from both a molecular Hamiltonian and a leakage operator. This method enables such calculations using only a single &quot;pass&quot; through time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/97e41c4808d0686eb3201497cf40287e81550dca/src/evols/Evolutions.jl#L148-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Evolutions.workbasis-Tuple{CtrlVQE.Evolutions.EvolutionType}" href="#CtrlVQE.Evolutions.workbasis-Tuple{CtrlVQE.Evolutions.EvolutionType}"><code>CtrlVQE.Evolutions.workbasis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">workbasis(evolution::EvolutionType)</code></pre><p>Which basis the evolution algorithm works in.</p><p>Also defines the default basis to interpret ψ as, in evolution methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/97e41c4808d0686eb3201497cf40287e81550dca/src/evols/Evolutions.jl#L38-L45">source</a></section></article><h2 id="Trotter-Evolutions"><a class="docs-heading-anchor" href="#Trotter-Evolutions">Trotter Evolutions</a><a id="Trotter-Evolutions-1"></a><a class="docs-heading-anchor-permalink" href="#Trotter-Evolutions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.ToggleEvolutions.Toggle" href="#CtrlVQE.ToggleEvolutions.Toggle"><code>CtrlVQE.ToggleEvolutions.Toggle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Toggle</code></pre><p>A Trotterization method (using <code>r</code> steps) alternately propagating static and drive terms.</p><p>The work basis for this algorithm is <code>Bases.OCCUPATION</code>,     since the time-dependent &quot;Drive&quot; operator at each step is usually qubit-local.</p><p>NOTE: This method assumes a trapezoidal rule,     so only <code>TrapezoidalIntegration</code> grids are allowed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/97e41c4808d0686eb3201497cf40287e81550dca/src/evols/ToggleEvolutions.jl#L15-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.DirectEvolutions.Direct" href="#CtrlVQE.DirectEvolutions.Direct"><code>CtrlVQE.DirectEvolutions.Direct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Direct</code></pre><p>A Trotterization method (using <code>r</code> steps) calculating drive terms in the rotation-frame.</p><p>The work basis for this algorithm is <code>Bases.DRESSED</code>,     since the rotating-frame evolution <span>$U_t ≡ exp(-itH_0)$</span> happens at each step.</p><p>This algorithm exponentiates the matrix <span>$U_t&#39; V(t) U_t$</span> at each time step,     so it is not terribly efficient.</p><p>NOTE: Currently, this method assumes a trapezoidal rule,     so only <code>TrapezoidalIntegration</code> grids are allowed. TODO (mid): Actually I&#39;m pretty sure this one doesn&#39;t have any reason to...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/97e41c4808d0686eb3201497cf40287e81550dca/src/evols/DirectEvolutions.jl#L18-L33">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Devices/">« Devices</a><a class="docs-footer-nextpage" href="../Integrations/">Integrations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 1 November 2023 15:43">Wednesday 1 November 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
