<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Devices · CtrlVQE.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://kmsherbertvt.github.io/CtrlVQE.jl/Devices/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CtrlVQE.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">CtrlVQE</a></li><li><a class="tocitem" href="../Bases/">Bases</a></li><li class="is-active"><a class="tocitem" href>Devices</a><ul class="internal"><li><a class="tocitem" href="#Transmon-Devices"><span>Transmon Devices</span></a></li></ul></li><li><a class="tocitem" href="../Evolutions/">Evolutions</a></li><li><a class="tocitem" href="../LinearAlgebraTools/">LinearAlgebraTools</a></li><li><a class="tocitem" href="../Operators/">Operators</a></li><li><a class="tocitem" href="../Parameters/">Parameters</a></li><li><a class="tocitem" href="../Signals/">Signals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Devices</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Devices</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/main/docs/src/Devices.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Devices"><a class="docs-heading-anchor" href="#Devices">Devices</a><a id="Devices-1"></a><a class="docs-heading-anchor-permalink" href="#Devices" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices" href="#CtrlVQE.Devices"><code>CtrlVQE.Devices</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Devices</code></pre><p><em>In silico</em> representation of quantum devices, in which quantum states evolve in time.</p><p>In this package,     the &quot;static&quot; components (ie. qubit frequencies, couplings, etc.)     and the &quot;drive&quot; components (ie. control signal, variational parameters, etc.)     are <em>all</em> integrated into a single <code>Device</code> object. All you need to know how a quantum state <code>ψ</code> evolves up time <code>T</code> is in the device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/CtrlVQE.jl#L370-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.Device" href="#CtrlVQE.Devices.Device"><code>CtrlVQE.Devices.Device</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Device</code></pre><p>Super-type for all device objects.</p><p><strong>Implementation</strong></p><p>Any concrete sub-type <code>D</code> must implement all functions in the <code>Parameters</code> module.</p><ul><li>In particular, if any static operators in your device depend on variational parameters,   you should consult the &quot;Note on Caching&quot; below.</li></ul><p>In addition, all methods in the following sections must be implemented.</p><ul><li>Counting methods</li><li>Algebra methods</li><li>Operator methods</li><li>Type methods</li><li>Gradient methods</li></ul><p>If your device&#39;s drive channels are all local,     you should implement a <code>LocallyDrivenDevice</code>,     which has a few extra requirements.</p><p><strong>Counting methods:</strong></p><ul><li><code>nqubits(::D)</code>: the number of qubits in the device - call this <code>n</code>.</li><li><code>nlevels(::D)</code>: the number of physical levels in each &quot;qubit&quot; - call this <code>m</code>.</li><li><code>ndrives(::D)</code>: the number of distinct drive channels.</li><li><code>ngrades(::D)</code>: the number of distinct gradient operators.</li></ul><p>Each of these methods returns an integer.</p><p><strong>Algebra methods:</strong></p><ul><li><code>localloweringoperator(::D)</code>:       an <code>m × m</code> matrix applying the lowering operator <code>a</code> to a single qubit.</li></ul><p>This method should define <code>result=nothing</code> as a keyword argument;     when passed, use it as the array to store your result in.</p><p><strong>Operator methods:</strong></p><ul><li><p><code>qubithamiltonian(::D, ā, q::Int)</code>:       the static components of the device Hamiltonian local to qubit q.</p></li><li><p><code>staticcoupling(::D, ā)</code>:       the static components of the device Hamiltonian nonlocal to any one qubit.</p></li><li><p><code>driveoperator(::D, ā, i::Int, t::Real)</code>:       the distinct drive operator for channel <code>i</code> at time <code>t</code></p></li><li><p><code>gradeoperator(::D, ā, j::Int, t::Real)</code>:       the distinct gradient operator indexed by <code>j</code> at time <code>t</code></p></li></ul><p>Each of these methods should define <code>result=nothing</code> as a keyword argument;     when passed, use it as the array to store your result in.</p><p>Each of these methods takes a 3darray <code>ā</code>;     the annihilation operator <span>$a_q$</span> is given by the matrix <code>ā[:,:,q]</code>. These methods should construct a new matrix as a function of each <span>$a_q$</span>. Usually, each <code>ā[:,:,q]</code> is defined on the full Hilbert space (ie. <code>m^n × m^n</code>),     but sometimes the code exploits a simple tensor structure     by passing in local <code>m × m</code> operators instead,     so do not assume a specific size a priori.</p><p>The annihilation operators <span>$a_q$</span> and their adjoints <span>$a_q&#39;$</span> form a complete algebra,     so it is always possible to express any operator given just <code>ā</code>. For example, the Pauli spin matrices in a two-level system can be expressed     as <span>$X=a+a&#39;$</span>, <span>$Y=i(a-a&#39;)$</span>, and <span>$Z=a&#39;a$</span>. If you <em>really</em> want to write your operators as functions of something other than <span>$a_q$</span>,     you may &quot;hack&quot; in a new algebra by implementing new methods     for this module&#39;s <code>eltype_algebra</code>, <code>algebra</code>, and <code>localalgebra</code> functions.</p><p><strong>Type methods:</strong></p><ul><li><code>eltype_localloweringoperator(::D)</code></li><li><code>eltype_qubithamiltonian(::D)</code></li><li><code>eltype_staticcoupling(::D)</code></li><li><code>eltype_driveoperator(::D)</code></li><li><code>eltype_gradeoperator(::D)</code></li></ul><p>Each of these methods gives the number type of the corresponding operator. Implement these methods based only on your implementation of the methods,     ie. they should be independent of the type of <code>ā</code>.</p><p><strong>Gradient methods:</strong></p><ul><li><code>gradient(::D, τ̄, t̄, ϕ̄)</code>:       the gradient vector for each variational parameter in the device.</li></ul><p>Each partial is generally an integral over at least one gradient signal. The arguments <code>τ̄</code> and <code>t̄</code> are time spacings and time grids,     as given by <code>Evolutions.trapezoidaltimegrid</code>. The argument <code>ϕ̄</code> is a 2d array; <code>ϕ̄[:,:,j]</code> contains the jth gradient signal     <span>$ϕ_j(t)$</span> evaluated at each point in <code>t̄</code>. An integral <span>$∫f(ϕ_j(t), t)⋅dt$</span> is computed as <code>sum( f.(ϕ̄[:,:,j], t̄) .* τ̄ )</code>.</p><p>This method should define <code>result=nothing</code> as a keyword argument;     when passed, use it as the array to store your result in.</p><p><strong>Notes on Caching</strong></p><p>This module uses the <code>Memoization</code> package to cache some arrays as they are calculated.</p><p>This does not apply to any method which depends on an absolute time t,     though it does apply to methods depending only on a relative time τ. For example, the propagator for a static Hamiltonian is cached,     but not one for a drive Hamiltonian. No caching happens for any method if its <code>result</code> keyword argument is used.</p><p>Usually, variational parameters only affect time-dependent methods,     but if any of your device&#39;s static operators do depend on a variational parameter,     you should be careful to empty the cache when <code>Parameters.bind</code> is called.</p><p>You can completely clear everything in the cache with:</p><pre><code class="nohighlight hljs">Memoization.empty_all_caches!()</code></pre><p>Alternatively, selectively clear caches for affected functions via:</p><pre><code class="nohighlight hljs">Memoization.empty_cache!(fn)</code></pre><p>I don&#39;t know if it&#39;s possible to selectively clear cached values for specific methods. If it can be done, it would require obtaining the actual <code>Dict</code>     being used as a cache for a particular function,     figuring out exactly how that cache is indexed,     and manually removing elements matching your targeted method signature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L13-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eltype-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device}" href="#Base.eltype-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.eltype(op::Operators.OperatorType, device::Device[, basis::Bases.BasisType])</code></pre><p>The number type of the matrix returned by <code>operator(op, device, basis)</code>.</p><p>When omitted, the basis defaults to Bases.OCCUPATION.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L650-L657">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.algebra" href="#CtrlVQE.Devices.algebra"><code>CtrlVQE.Devices.algebra</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">algebra(device::Device[, basis::Bases.BasisType])</code></pre><p>A matrix list <code>ā</code>, where <code>ā[:,:,q]</code> represents the annihilation operator <span>$a_q$</span>.</p><p>When omitted, the basis defaults to Bases.OCCUPATION.</p><p>Each <code>ā[:,:,q]</code> acts globally on the full Hilbert space of the device,     even in bases where it acts trivially on states outside the local space of qubit <code>q</code>. To construct local operators, use <code>localalgebra</code> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L590-L601">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.basisrotation-Tuple{CtrlVQE.Bases.BasisType, CtrlVQE.Bases.BasisType, CtrlVQE.Devices.Device}" href="#CtrlVQE.Devices.basisrotation-Tuple{CtrlVQE.Bases.BasisType, CtrlVQE.Bases.BasisType, CtrlVQE.Devices.Device}"><code>CtrlVQE.Devices.basisrotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basisrotation(tgt::Bases.BasisType, src::Bases.BasisType, device::Device)</code></pre><p>Calculate the basis rotation <code>U</code> which transforms <span>$|ψ_{src}⟩ → |ψ_{tgt}⟩ = U|ψ_{src}⟩$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L498-L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.basisrotation-Tuple{CtrlVQE.Bases.LocalBasis, CtrlVQE.Bases.LocalBasis, CtrlVQE.Devices.Device, Int64}" href="#CtrlVQE.Devices.basisrotation-Tuple{CtrlVQE.Bases.LocalBasis, CtrlVQE.Bases.LocalBasis, CtrlVQE.Devices.Device, Int64}"><code>CtrlVQE.Devices.basisrotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basisrotation(tgt::Bases.LocalBasis, src::Bases.LocalBasis, device::Device, q::Int)</code></pre><p>Same as above, except that <code>U</code> acts on the local Hilbert space of qubit <code>q</code>.</p><p>This is used elsewhere for more efficient rotations exploiting tensor structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L525-L532">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.braket-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device, AbstractVector, AbstractVector}" href="#CtrlVQE.Devices.braket-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device, AbstractVector, AbstractVector}"><code>CtrlVQE.Devices.braket</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">braket(op, device[, basis], ψ1, ψ2)</code></pre><p>The braket of an operator describing a <code>device</code> with respect to states <code>ψ1</code> and <code>ψ2</code>.</p><p>If <span>$A$</span> is the operator specified by <code>op</code>, this method calculates <span>$⟨ψ1|A|ψ2⟩$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>op::Operators.OperatorType</code>: which operator to estimate (eg. static, drive, etc.).</li><li><code>device::Device</code>: which device is being described.</li><li><code>basis::Bases.BasisType</code>: which basis the state <code>ψ</code> is represented in.       Defaults to <code>Bases.OCCUPATION</code> when omitted.</li><li><code>ψ1</code>, <code>ψ2</code>: Statevectors defined over the full Hilbert space of the device.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L1503-L1517">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.diagonalize" href="#CtrlVQE.Devices.diagonalize"><code>CtrlVQE.Devices.diagonalize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">diagonalize(basis::Bases.BasisType, device::Device)</code></pre><p>Compute the vector of eigenvalues <code>Λ</code> and the rotation matrix <code>U</code> for a given basis.</p><p><code>U</code> is an operator acting on the global Hilbert space of the device.</p><p>The result is packed into a <code>LinearAlgebra.Eigen</code> object,     but it may be unpacked by <code>Λ, U = diagonalize(basis, device)</code>.</p><pre><code class="nohighlight hljs">diagonalize(basis::Bases.LocalBasis, device::Device, q::Int)</code></pre><p>Same as above, except that <code>U</code> acts on the local Hilbert space of qubit <code>q</code>.</p><p>Note that you can still construct     the global rotation matrix of a local basis by using the first method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L405-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.driveoperator-Tuple{CtrlVQE.Devices.Device, Array{T, 3} where T, Int64, Real}" href="#CtrlVQE.Devices.driveoperator-Tuple{CtrlVQE.Devices.Device, Array{T, 3} where T, Int64, Real}"><code>CtrlVQE.Devices.driveoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">driveoperator(device::Device, ā::MatrixList, i::Int, t::Real; result=nothing)</code></pre><p>The distinct drive operator for channel <code>i</code> at time <code>t</code>.</p><p>This method is a function of annihilation operators <span>$a_q$</span> given by <code>ā[:,:,q]</code>,     which are matrices acting globally on the physical Hilbert space. If <code>device</code> is a <code>LocallyDrivenDevice</code>,     the matrices may also act on a local physical Hilbert space for each individual qubit.</p><p>Optionally, pass a pre-allocated array of compatible type and shape as <code>result</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L232-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.eltype_algebra" href="#CtrlVQE.Devices.eltype_algebra"><code>CtrlVQE.Devices.eltype_algebra</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eltype_algebra(device::Device[, basis::Bases.BasisType])</code></pre><p>The number type of each annihilation operator <span>$a_j$</span> represented in the given basis.</p><p>When omitted, the basis defaults to Bases.OCCUPATION.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L569-L576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.eltype_driveoperator-Tuple{CtrlVQE.Devices.Device}" href="#CtrlVQE.Devices.eltype_driveoperator-Tuple{CtrlVQE.Devices.Device}"><code>CtrlVQE.Devices.eltype_driveoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eltype_driveoperator(device::Device)</code></pre><p>The number type of the time-dependent drive channels for this device.</p><p>The number type of the algebra <code>ā</code> is ignored for the purposes of this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L309-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.eltype_gradeoperator-Tuple{CtrlVQE.Devices.Device}" href="#CtrlVQE.Devices.eltype_gradeoperator-Tuple{CtrlVQE.Devices.Device}"><code>CtrlVQE.Devices.eltype_gradeoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eltype_gradeoperator(device::Device)</code></pre><p>The number type of the gradient operators for this device.</p><p>The number type of the algebra <code>ā</code> is ignored for the purposes of this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L322-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.eltype_localloweringoperator-Tuple{CtrlVQE.Devices.Device}" href="#CtrlVQE.Devices.eltype_localloweringoperator-Tuple{CtrlVQE.Devices.Device}"><code>CtrlVQE.Devices.eltype_localloweringoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eltype_localloweringoperator(device::Device)</code></pre><p>The number type of a local lowering operator for this device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L272-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.eltype_qubithamiltonian-Tuple{CtrlVQE.Devices.Device}" href="#CtrlVQE.Devices.eltype_qubithamiltonian-Tuple{CtrlVQE.Devices.Device}"><code>CtrlVQE.Devices.eltype_qubithamiltonian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eltype_qubithamiltonian(device::Device)</code></pre><p>The number type of the local static components of the Hamiltonian for this device.</p><p>The number type of the algebra <code>ā</code> is ignored for the purposes of this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L283-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.eltype_staticcoupling-Tuple{CtrlVQE.Devices.Device}" href="#CtrlVQE.Devices.eltype_staticcoupling-Tuple{CtrlVQE.Devices.Device}"><code>CtrlVQE.Devices.eltype_staticcoupling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eltype_staticcoupling(device::Device)</code></pre><p>The number type of the non-local static components of the Hamiltonian for this device.</p><p>The number type of the algebra <code>ā</code> is ignored for the purposes of this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L296-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.evolve!-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device, Real, AbstractVecOrMat{&lt;:Complex{&lt;:AbstractFloat}}}" href="#CtrlVQE.Devices.evolve!-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device, Real, AbstractVecOrMat{&lt;:Complex{&lt;:AbstractFloat}}}"><code>CtrlVQE.Devices.evolve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evolve!(op, device[, basis], t, ψ)</code></pre><p>Propagate a state <code>ψ</code> by a time <code>t</code> under the Hermitian <code>op</code> describing a <code>device</code>.</p><p>This function is identical to <code>propagate!</code>,     except that the cache is not used for intermediate propagator matrices,     and that it is undefined for time-dependent operators. Look to the <code>Evolutions</code> module for algorithms compatible with time-dependence!</p><p><strong>Arguments</strong></p><ul><li><code>op::Operators.OperatorType</code>: which operator to evolve under (eg. static, drive, etc.).</li><li><code>device::Device</code>: which device is being described.</li><li><code>basis::Bases.BasisType</code>: which basis the state <code>ψ</code> is represented in.       Defaults to <code>Bases.OCCUPATION</code> when omitted.</li><li><code>t::Real</code>: the amount to move forward in time by.</li><li><code>ψ</code>: Either a vector or a matrix, defined over the full Hilbert space of the device.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L1380-L1398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.evolver-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device, Real}" href="#CtrlVQE.Devices.evolver-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device, Real}"><code>CtrlVQE.Devices.evolver</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evolver(op, device[, basis], t; kwargs...)</code></pre><p>A unitary propagator describing evolution under a Hermitian operator for an time t.</p><p>This function is identical to <code>propagator</code>,     except that the argument <code>t</code> is considered an absolute time so it is never cached,     and that it is undefined for time-dependent operators. It exists solely to perform rotating-frame rotations at every time-step     without worrying about over-caching.</p><p><strong>Arguments</strong></p><ul><li><code>op::Operators.OperatorType</code>: which operator to evolve under (eg. static, drive, etc.).</li><li><code>device::Device</code>: which device is being described.</li><li><code>basis::Bases.BasisType</code>: which basis the operator will be represented in.       Defaults to <code>Bases.OCCUPATION</code> when omitted.</li><li><code>t::Real</code>: the amount to move forward in time by.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>result</code>: a pre-allocated array of compatible type and shape, used to store the result.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L1242-L1263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.expectation-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device, AbstractVector}" href="#CtrlVQE.Devices.expectation-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device, AbstractVector}"><code>CtrlVQE.Devices.expectation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expectation(op, device[, basis], ψ)</code></pre><p>The expectation value of an operator describing a <code>device</code> with respect to the state <code>ψ</code>.</p><p>If <span>$A$</span> is the operator specified by <code>op</code>, this method calculates <span>$⟨ψ|A|ψ⟩$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>op::Operators.OperatorType</code>: which operator to estimate (eg. static, drive, etc.).</li><li><code>device::Device</code>: which device is being described.</li><li><code>basis::Bases.BasisType</code>: which basis the state <code>ψ</code> is represented in.       Defaults to <code>Bases.OCCUPATION</code> when omitted.</li><li><code>ψ</code>: A statevector defined over the full Hilbert space of the device.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L1475-L1489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.globalize-Union{Tuple{F}, Tuple{CtrlVQE.Devices.Device, AbstractMatrix{F}, Int64}} where F" href="#CtrlVQE.Devices.globalize-Union{Tuple{F}, Tuple{CtrlVQE.Devices.Device, AbstractMatrix{F}, Int64}} where F"><code>CtrlVQE.Devices.globalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">globalize(device::Device, op::AbstractMatrix, q::Int; result=nothing)</code></pre><p>Extend a local operator <code>op</code> acting on qubit <code>q</code> into the global Hilbert space.</p><p>Optionally, pass a pre-allocated array of compatible type and shape as <code>result</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L379-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.gradeoperator-Tuple{CtrlVQE.Devices.Device, Array{T, 3} where T, Int64, Real}" href="#CtrlVQE.Devices.gradeoperator-Tuple{CtrlVQE.Devices.Device, Array{T, 3} where T, Int64, Real}"><code>CtrlVQE.Devices.gradeoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradeoperator(device::Device, ā::MatrixList, j::Int, t::Real; result=nothing)</code></pre><p>The distinct gradient operator indexed by <code>j</code> at time <code>t</code>.</p><p>I have defined the &quot;gradient operator&quot; <span>$Â_j$</span> as the Hermitian operator     for which the jth gradient signal is <span>$ϕ_j = ⟨λ|(iÂ_j)|ψ⟩ + h.t.$</span>.</p><p>This method is a function of annihilation operators <span>$a_q$</span> given by <code>ā[:,:,q]</code>,     which are matrices acting globally on the physical Hilbert space. If <code>device</code> is a <code>LocallyDrivenDevice</code>,     the matrices may also act on a local physical Hilbert space for each individual qubit.</p><p>Optionally, pass a pre-allocated array of compatible type and shape as <code>result</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L250-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.gradient-Tuple{CtrlVQE.Devices.Device, AbstractVector, AbstractVector, AbstractMatrix}" href="#CtrlVQE.Devices.gradient-Tuple{CtrlVQE.Devices.Device, AbstractVector, AbstractVector, AbstractMatrix}"><code>CtrlVQE.Devices.gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradient(::Device, τ̄, t̄, ϕ̄; result=nothing)</code></pre><p>The gradient vector of partials for each variational parameter in the device.</p><p>Each partial is generally an integral over at least one gradient signal. The arguments <code>τ̄</code> and <code>t̄</code> are time spacings and time grids,     as given by <code>Evolutions.trapezoidaltimegrid</code>. The argument <code>ϕ̄</code> is a 2d array; <code>ϕ̄[:,:,j]</code> contains the jth gradient signal     <span>$ϕ_j(t)$</span> evaluated at each point in <code>t̄</code>.</p><p>Optionally, pass a pre-allocated array of compatible type and shape as <code>result</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L335-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.localalgebra" href="#CtrlVQE.Devices.localalgebra"><code>CtrlVQE.Devices.localalgebra</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">localalgebra(device::Device[, basis::Bases.LocalBasis])</code></pre><p>A matrix list <code>ā</code>, where <code>ā[:,:,q]</code> represents the annihilation operator <span>$a_q$</span>.</p><p>When omitted, the basis defaults to Bases.OCCUPATION.</p><p>Each <code>ā[:,:,q]</code> acts locally on the physical Hilbert space of qubit <code>q</code>. Note that you can construct global operators in a local basis by using <code>algebra</code> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L620-L630">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.localbasisrotations-Tuple{CtrlVQE.Bases.LocalBasis, CtrlVQE.Bases.LocalBasis, CtrlVQE.Devices.Device}" href="#CtrlVQE.Devices.localbasisrotations-Tuple{CtrlVQE.Bases.LocalBasis, CtrlVQE.Bases.LocalBasis, CtrlVQE.Devices.Device}"><code>CtrlVQE.Devices.localbasisrotations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">localbasisrotations(tgt::Bases.LocalBasis, src::Bases.LocalBasis, device::Device)</code></pre><p>A matrix list <code>ū</code>, where <code>ū[:,:,q]</code> is a local basis rotation on qubit <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L546-L551">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.localloweringoperator-Tuple{CtrlVQE.Devices.Device}" href="#CtrlVQE.Devices.localloweringoperator-Tuple{CtrlVQE.Devices.Device}"><code>CtrlVQE.Devices.localloweringoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">localloweringoperator(device::Device; result=nothing)</code></pre><p>The lowering operator <span>$a$</span> acting on the Hilbert space of a single physical qubit.</p><p>Optionally, pass a pre-allocated array of compatible type and shape as <code>result</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L187-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.localqubitevolvers-Tuple{CtrlVQE.Devices.Device, Real}" href="#CtrlVQE.Devices.localqubitevolvers-Tuple{CtrlVQE.Devices.Device, Real}"><code>CtrlVQE.Devices.localqubitevolvers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">localqubitevolvers(device[, basis], τ; kwargs...)</code></pre><p>A matrix list <code>ū</code>, where each <code>ū[:,:,q]</code> is a propagator for a local qubit hamiltonian.</p><p>This function is identical to <code>localqubitevolvers</code>,     except that the argument <code>t</code> is considered an absolute time so it is never cached.</p><p><strong>Arguments</strong></p><ul><li><code>device::Device</code>: which device is being described.</li><li><code>basis::Bases.BasisType</code>: which basis the operator will be represented in.       Defaults to <code>Bases.OCCUPATION</code> when omitted.</li><li><code>τ::Real</code>: the amount to move forward in time by.       Note that the propagation is only approximate for time-dependent operators.       The smaller <code>τ</code> is, the more accurate the approximation.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>result</code>: a pre-allocated array of compatible type and shape, used to store the result.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L1338-L1357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.localqubitoperators-Tuple{CtrlVQE.Devices.Device}" href="#CtrlVQE.Devices.localqubitoperators-Tuple{CtrlVQE.Devices.Device}"><code>CtrlVQE.Devices.localqubitoperators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">localqubitoperators(device[, basis]; kwargs...)</code></pre><p>A matrix list <code>h̄</code>, where each <code>h̄[:,:,q]</code> represents a local qubit hamiltonian.</p><p><strong>Arguments</strong></p><ul><li><code>device::Device</code>: which device is being described.</li><li><code>basis::Bases.BasisType</code>: which basis the operators will be represented in.       Defaults to <code>Bases.OCCUPATION</code> when omitted.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>result</code>: a pre-allocated array of compatible type and shape, used to store the result.</p><p>localqubitoperators(device, basis, :cache)</p></li></ul><p>For internal use only. The extra positional argument enables dispatch to a cached function when appropriate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L913-L931">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.localqubitpropagators-Tuple{CtrlVQE.Devices.Device, Real}" href="#CtrlVQE.Devices.localqubitpropagators-Tuple{CtrlVQE.Devices.Device, Real}"><code>CtrlVQE.Devices.localqubitpropagators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">localqubitpropagators(device[, basis], τ; kwargs...)</code></pre><p>A matrix list <code>ū</code>, where each <code>ū[:,:,q]</code> is a propagator for a local qubit hamiltonian.</p><p><strong>Arguments</strong></p><ul><li><code>device::Device</code>: which device is being described.</li><li><code>basis::Bases.BasisType</code>: which basis the operator will be represented in.       Defaults to <code>Bases.OCCUPATION</code> when omitted.</li><li><code>τ::Real</code>: the amount to move forward in time by.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>result</code>: a pre-allocated array of compatible type and shape, used to store the result.</p><p>localqubitpropagators(device, basis, τ, :cache)</p></li></ul><p>For internal use only. The extra positional argument enables dispatch to a cached function when appropriate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L1092-L1111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.ndrives-Tuple{CtrlVQE.Devices.Device}" href="#CtrlVQE.Devices.ndrives-Tuple{CtrlVQE.Devices.Device}"><code>CtrlVQE.Devices.ndrives</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ndrives(device::Device)</code></pre><p>The number of distinct drive channels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L165-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.ngrades-Tuple{CtrlVQE.Devices.Device}" href="#CtrlVQE.Devices.ngrades-Tuple{CtrlVQE.Devices.Device}"><code>CtrlVQE.Devices.ngrades</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ngrades(device::Device)</code></pre><p>The number of distinct gradient operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L176-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.nlevels-Tuple{CtrlVQE.Devices.Device}" href="#CtrlVQE.Devices.nlevels-Tuple{CtrlVQE.Devices.Device}"><code>CtrlVQE.Devices.nlevels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nlevels(device::Device)</code></pre><p>The number of physical levels in each &quot;qubit&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L154-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.nqubits-Tuple{CtrlVQE.Devices.Device}" href="#CtrlVQE.Devices.nqubits-Tuple{CtrlVQE.Devices.Device}"><code>CtrlVQE.Devices.nqubits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nqubits(device::Device)</code></pre><p>The number of qubits in the device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L143-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.nstates-Tuple{CtrlVQE.Devices.Device}" href="#CtrlVQE.Devices.nstates-Tuple{CtrlVQE.Devices.Device}"><code>CtrlVQE.Devices.nstates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nstates(device::Device)</code></pre><p>The total number of states in the physical Hilbert space of the device.</p><p>(This is as opposed to <code>nlevels(device)</code>,     the number of states in the physical Hilbert space of a single independent qubit.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L367-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.operator-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device}" href="#CtrlVQE.Devices.operator-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device}"><code>CtrlVQE.Devices.operator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">operator(op, device[, basis]; kwargs...)</code></pre><p>A Hermitian operator describing a <code>device</code>, represented in the given <code>basis</code>.</p><p>For example, to construct the static Hamiltonian of a device in the dressed basis,     call <code>operator(Operators.STATIC, device, Bases.DRESSED)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>op::Operators.OperatorType</code>: which operator to construct (eg. static, drive, etc.).</li><li><code>device::Device</code>: which device is being described.</li><li><code>basis::Bases.BasisType</code>: which basis the operator will be represented in.       Defaults to <code>Bases.OCCUPATION</code> when omitted.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>result</code>: a pre-allocated array of compatible type and shape, used to store the result.</p><p>operator(op, device, basis, :cache)</p></li></ul><p>For internal use only. The extra positional argument enables dispatch to a cached function when appropriate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L725-L747">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.propagate!-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device, Real, AbstractVecOrMat{&lt;:Complex{&lt;:AbstractFloat}}}" href="#CtrlVQE.Devices.propagate!-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device, Real, AbstractVecOrMat{&lt;:Complex{&lt;:AbstractFloat}}}"><code>CtrlVQE.Devices.propagate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate!(op, device[, basis], τ, ψ)</code></pre><p>Propagate a state <code>ψ</code> by a small time <code>τ</code> under the Hermitian <code>op</code> describing a <code>device</code>.</p><p><strong>Arguments</strong></p><ul><li><code>op::Operators.OperatorType</code>: which operator to evolve under (eg. static, drive, etc.).</li><li><code>device::Device</code>: which device is being described.</li><li><code>basis::Bases.BasisType</code>: which basis the state <code>ψ</code> is represented in.       Defaults to <code>Bases.OCCUPATION</code> when omitted.</li><li><code>τ::Real</code>: the amount to move forward in time by.       Note that the propagation is only approximate for time-dependent operators.       The smaller <code>τ</code> is, the more accurate the approximation.</li><li><code>ψ</code>: Either a vector or a matrix, defined over the full Hilbert space of the device.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L1144-L1159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.propagator-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device, Real}" href="#CtrlVQE.Devices.propagator-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device, Real}"><code>CtrlVQE.Devices.propagator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagator(op, device[, basis], τ; kwargs...)</code></pre><p>A unitary propagator describing evolution under a Hermitian operator for a small time τ.</p><p><strong>Arguments</strong></p><ul><li><code>op::Operators.OperatorType</code>: which operator to evolve under (eg. static, drive, etc.).</li><li><code>device::Device</code>: which device is being described.</li><li><code>basis::Bases.BasisType</code>: which basis the operator will be represented in.       Defaults to <code>Bases.OCCUPATION</code> when omitted.</li><li><code>τ::Real</code>: the amount to move forward in time by.       Note that the propagation is only approximate for time-dependent operators.       The smaller <code>τ</code> is, the more accurate the approximation.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>result</code>: a pre-allocated array of compatible type and shape, used to store the result.</p><p>propagator(op, device, basis, τ, :cache)</p></li></ul><p>For internal use only. The extra positional argument enables dispatch to a cached function when appropriate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L962-L984">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.qubithamiltonian-Tuple{CtrlVQE.Devices.Device, Array{T, 3} where T, Int64}" href="#CtrlVQE.Devices.qubithamiltonian-Tuple{CtrlVQE.Devices.Device, Array{T, 3} where T, Int64}"><code>CtrlVQE.Devices.qubithamiltonian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">qubithamiltonian(device::Device, ā::MatrixList, q::Int; result=nothing)</code></pre><p>The static components of the device Hamiltonian local to qubit <code>q</code>.</p><p>This method is a function of annihilation operators <span>$a_q$</span> given by <code>ā[:,:,q]</code>,     which may be matrices acting on a physical Hilbert space either globally or locally.</p><p>Optionally, pass a pre-allocated array of compatible type and shape as <code>result</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L200-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.staticcoupling-Tuple{CtrlVQE.Devices.Device, Array{T, 3} where T}" href="#CtrlVQE.Devices.staticcoupling-Tuple{CtrlVQE.Devices.Device, Array{T, 3} where T}"><code>CtrlVQE.Devices.staticcoupling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">staticcoupling(device::Device, ā::MatrixList, q::Int; result=nothing)</code></pre><p>The static components of the device Hamiltonian nonlocal to any one qubit.</p><p>This method is a function of annihilation operators <span>$a_q$</span> given by <code>ā[:,:,q]</code>,     which are matrices acting globally on the physical Hilbert space.</p><p>Optionally, pass a pre-allocated array of compatible type and shape as <code>result</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Devices.jl#L216-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.LocallyDrivenDevices.LocallyDrivenDevice" href="#CtrlVQE.Devices.LocallyDrivenDevices.LocallyDrivenDevice"><code>CtrlVQE.Devices.LocallyDrivenDevices.LocallyDrivenDevice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LocallyDrivenDevice</code></pre><p>Super-type for device objects whose drive channels act locally on individual qubits.</p><p>Inherit from this type if your <code>driveoperator</code> and <code>gradeoperator</code> methods     depend only on a single annihilation operator <code>ā[:,:,q]</code>. This enables more efficient propagation methods which exploit a tensor product structure.</p><p><strong>Implementation</strong></p><p>Any concrete sub-type <code>D</code> must implement <em>everything</em> required in the <code>Device</code> interface,     so consult the documentation for <code>Device</code> carefully.</p><p>In addition, the following methods must be implemented:</p><ul><li><code>drivequbit(::D, i::Int)</code>: index of the qubit on which channel <code>i</code> is applied.</li><li><code>gradequbit(::D, j::Int)</code>: index of the qubit associated with the jth gradient operator.</li></ul><p>It&#39;s usually trivial to infer the channel index i associated with each gradient operator,     in which case <code>gradequbit(device, j) = drivequbit(device, i)</code>,     but this is left as an implementation detail.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/devices/LocallyDrivenDevices.jl#L7-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.LocallyDrivenDevices.drivequbit-Tuple{CtrlVQE.Devices.LocallyDrivenDevices.LocallyDrivenDevice, Int64}" href="#CtrlVQE.Devices.LocallyDrivenDevices.drivequbit-Tuple{CtrlVQE.Devices.LocallyDrivenDevices.LocallyDrivenDevice, Int64}"><code>CtrlVQE.Devices.LocallyDrivenDevices.drivequbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">drivequbit(device, i::Int)</code></pre><p>Index of the qubit on which channel <code>i</code> is applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/devices/LocallyDrivenDevices.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.LocallyDrivenDevices.gradequbit-Tuple{CtrlVQE.Devices.LocallyDrivenDevices.LocallyDrivenDevice, Int64}" href="#CtrlVQE.Devices.LocallyDrivenDevices.gradequbit-Tuple{CtrlVQE.Devices.LocallyDrivenDevices.LocallyDrivenDevice, Int64}"><code>CtrlVQE.Devices.LocallyDrivenDevices.gradequbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradequbit(device, j::Int)</code></pre><p>Index of the qubit associated with the jth gradient operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/devices/LocallyDrivenDevices.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.LocallyDrivenDevices.localdriveoperators-Tuple{CtrlVQE.Devices.LocallyDrivenDevices.LocallyDrivenDevice, Real}" href="#CtrlVQE.Devices.LocallyDrivenDevices.localdriveoperators-Tuple{CtrlVQE.Devices.LocallyDrivenDevices.LocallyDrivenDevice, Real}"><code>CtrlVQE.Devices.LocallyDrivenDevices.localdriveoperators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">localdriveoperators(device[, basis], t; kwargs...)</code></pre><p>A matrix list <code>v̄</code>, where <code>v̄[:,:,q]</code> represents a sum of all drives acting on qubit <code>q</code>.</p><p><strong>Arguments</strong></p><ul><li><code>device::Device</code>: which device is being described.</li><li><code>basis::Bases.BasisType</code>: which basis the operators will be represented in.       Defaults to <code>Bases.OCCUPATION</code> when omitted.</li><li><code>t::Real</code>: the time each drive operator is evaluated at.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/devices/LocallyDrivenDevices.jl#L54-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.LocallyDrivenDevices.localdrivepropagators-Tuple{CtrlVQE.Devices.LocallyDrivenDevices.LocallyDrivenDevice, Real, Real}" href="#CtrlVQE.Devices.LocallyDrivenDevices.localdrivepropagators-Tuple{CtrlVQE.Devices.LocallyDrivenDevices.LocallyDrivenDevice, Real, Real}"><code>CtrlVQE.Devices.LocallyDrivenDevices.localdrivepropagators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">localdrivepropagators(device[, basis], τ, t; kwargs...)</code></pre><p>A matrix list <code>ū</code>, where <code>ū[:,:,q]</code> is the propagator for a local drive term.</p><p><strong>Arguments</strong></p><ul><li><code>device::Device</code>: which device is being described.</li><li><code>basis::Bases.BasisType</code>: which basis the operators will be represented in.       Defaults to <code>Bases.OCCUPATION</code> when omitted.</li><li><code>τ::Real</code>: the amount to move forward in time by.       Note that the propagation is only approximate for time-dependent operators.       The smaller <code>τ</code> is, the more accurate the approximation.</li><li><code>t::Real</code>: the time each drive operator is evaluated at.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/devices/LocallyDrivenDevices.jl#L90-L104">source</a></section></article><h2 id="Transmon-Devices"><a class="docs-heading-anchor" href="#Transmon-Devices">Transmon Devices</a><a id="Transmon-Devices-1"></a><a class="docs-heading-anchor-permalink" href="#Transmon-Devices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.TransmonDevices.FixedFrequencyTransmonDevice" href="#CtrlVQE.Devices.TransmonDevices.FixedFrequencyTransmonDevice"><code>CtrlVQE.Devices.TransmonDevices.FixedFrequencyTransmonDevice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FixedFrequencyTransmonDevice(ω̄, δ̄, ḡ, quples, q̄, ν̄, Ω̄, m)</code></pre><p>A transmon device, modeling for example IBM&#39;s superconducting quantum computers.</p><p>Variational parameters include ONLY the shape parameters in each pulse. Pulse frequencies are &quot;frozen&quot;.</p><p><strong>Arguments</strong></p><ul><li><p><code>ω̄</code>: a vector of angular frequencies specifying the resonance frequency of each qubit.</p></li><li><p><code>δ̄</code>: a vector of angular frequencies specifying the anharmonicity of each qubit.</p></li><li><p><code>ḡ</code>: a vector of angular frequencies specifying the strength of each coupling.</p></li><li><p><code>quples</code>: a vector of <code>Quple</code> identifying whcih qubits participate in each coupling.</p></li><li><p><code>q̄</code>: a vector of indices specifying the target qubit for each drive channel.</p></li><li><p><code>ν̄</code>: a vector of angular frequencies specifying the pulse frequencies for each channel.</p></li><li><p><code>Ω̄</code>: a vector of signals specifying the shape of the pulse for each channel.</p></li><li><p><code>m</code>: an integer specifying the number of physical levels to retain for each qubit.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/devices/TransmonDevices.jl#L415-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Devices.TransmonDevices.TransmonDevice" href="#CtrlVQE.Devices.TransmonDevices.TransmonDevice"><code>CtrlVQE.Devices.TransmonDevices.TransmonDevice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TransmonDevice(ω̄, δ̄, ḡ, quples, q̄, ν̄, Ω̄, m)</code></pre><p>A transmon device, modeling for example IBM&#39;s superconducting quantum computers.</p><p>Variational parameters include the shape parameters in each pulse,     and the pulse frequencies.</p><p><strong>Arguments</strong></p><ul><li><p><code>ω̄</code>: a vector of angular frequencies specifying the resonance frequency of each qubit.</p></li><li><p><code>δ̄</code>: a vector of angular frequencies specifying the anharmonicity of each qubit.</p></li><li><p><code>ḡ</code>: a vector of angular frequencies specifying the strength of each coupling.</p></li><li><p><code>quples</code>: a vector of <code>Quple</code> identifying whcih qubits participate in each coupling.</p></li><li><p><code>q̄</code>: a vector of indices specifying the target qubit for each drive channel.</p></li><li><p><code>ν̄</code>: a vector of angular frequencies specifying the pulse frequencies for each channel.</p></li><li><p><code>Ω̄</code>: a vector of signals specifying the shape of the pulse for each channel.</p></li><li><p><code>m</code>: an integer specifying the number of physical levels to retain for each qubit.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/devices/TransmonDevices.jl#L312-L333">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Bases/">« Bases</a><a class="docs-footer-nextpage" href="../Evolutions/">Evolutions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 9 June 2023 21:50">Friday 9 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
