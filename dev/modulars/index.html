<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modular Framework · CtrlVQE.jl</title><meta name="title" content="Modular Framework · CtrlVQE.jl"/><meta property="og:title" content="Modular Framework · CtrlVQE.jl"/><meta property="twitter:title" content="Modular Framework · CtrlVQE.jl"/><meta name="description" content="Documentation for CtrlVQE.jl."/><meta property="og:description" content="Documentation for CtrlVQE.jl."/><meta property="twitter:description" content="Documentation for CtrlVQE.jl."/><meta property="og:url" content="https://kmsherbertvt.github.io/CtrlVQE.jl/modulars/"/><meta property="twitter:url" content="https://kmsherbertvt.github.io/CtrlVQE.jl/modulars/"/><link rel="canonical" href="https://kmsherbertvt.github.io/CtrlVQE.jl/modulars/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CtrlVQE.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">CtrlVQE</a></li><li><a class="tocitem" href="../basics/">Basic Implementations</a></li><li><a class="tocitem" href="../core/">Core Interface</a></li><li><a class="tocitem" href="../enums/">Enumerations</a></li><li class="is-active"><a class="tocitem" href>Modular Framework</a><ul class="internal"><li><a class="tocitem" href="#Core-Interface"><span>Core Interface</span></a></li><li><a class="tocitem" href="#Device-Modules"><span>Device Modules</span></a></li><li><a class="tocitem" href="#Energy-Modules"><span>Energy Modules</span></a></li></ul></li><li><a class="tocitem" href="../utils/">Utilities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Modular Framework</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Modular Framework</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/kmsherbertvt/CtrlVQE.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/main/docs/src/modulars.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Modular-Framework"><a class="docs-heading-anchor" href="#Modular-Framework">Modular Framework</a><a id="Modular-Framework-1"></a><a class="docs-heading-anchor-permalink" href="#Modular-Framework" title="Permalink"></a></h1><ul><li><a href="#Core-Interface">Core Interface</a></li><li><a href="#Device-Modules">Device Modules</a></li><li class="no-marker"><ul><li><a href="#Algebras">Algebras</a></li><li><a href="#Drifts">Drifts</a></li><li><a href="#Drives">Drives</a></li><li><a href="#Parameter-Mappers">Parameter Mappers</a></li></ul></li><li><a href="#Energy-Modules">Energy Modules</a></li><li class="no-marker"><ul><li><a href="#References">References</a></li><li><a href="#Measurements">Measurements</a></li></ul></li></ul><p>The types in <code>CtrlVQE</code> are designed to be as flexible as possible, while remaining <em>performant</em>. We did this by designing the <code>DeviceType</code> to represent the complete Hamiltonian,</p><p class="math-container">\[\hat H(\vec x,t) = \hat H_0(\vec x) + \sum_i \hat V_i (\vec x,t)\]</p><p>There is an interface to follow drift and drive terms are handled correctly and efficiently in time evolution,     but it is completely and entirely your choice how to implement them. But prioritizing <em>flexibility</em> and <em>performance</em> has a tendency to sacrifice <em>readability</em> and <em>reusability</em>.</p><p>This package attempts to find a middle ground,     by splitting each bit of the Hamiltonian equation into chunks. That is, there is one type (<code>AlgebraType</code>) which defines the <em>space</em> on which each operator <span>$\hat H$</span>, <span>$\hat H_0$</span>, <span>$\hat V_i$</span> acts. There is another (<code>DriftType</code>) defining <span>$\hat H_0$</span>. There is another (<code>DriveType</code>) defining <span>$\hat V_i$</span>.</p><p>And to help keep the drives as modular as possible,     there is a <code>MapperType</code> to map &quot;device&quot; parameters to individual drift and drive. A more complete equation - which is itself less readable,     but it makes the code <em>so</em> much easier to work with - would be</p><p class="math-container">\[\hat H(\vec x,t) = \hat H_0(h(\vec x)) + \sum_i \hat V_i(f_i(\vec x), t)\]</p><p>For example, let&#39;s say you&#39;re curious how a single three-qubit interaction term     in the static Hamiltonian of a transmon device would alter the minimal evolution time. This is a tiny change, but going from Basics,     it would seem to require implementing a whole new device type, and to do that correctly,     you&#39;d have to be sure to implement the dozen or so methods required for new device types. You&#39;ll presumably just copy and paste from an existing implementation,     which is generally considered bad practice and has a tendency to produce unexpected bugs     (hence the desire for code reusability). And you&#39;ll generate a file with hundreds of lines of code,     a real pain to organize, document, and debug     (hence the desire for code readability).</p><p>Going from here, you&#39;d simply implement a new drift type, with two methods, and be done.</p><h2 id="Core-Interface"><a class="docs-heading-anchor" href="#Core-Interface">Core Interface</a><a id="Core-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework" href="#CtrlVQE.ModularFramework"><code>CtrlVQE.ModularFramework</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ModularFramework</code></pre><p>Provides a framework for designing devices and energy functions in a less monolithic way. Different behaviors are delegated to different types.</p><p>Behavior for devices are divided into:</p><ul><li><code>AlgebraType</code></li><li><code>DriftType</code></li><li><code>DriveType</code></li><li><code>ParameterMap</code></li></ul><p>These can be implemented by the user and then combined into a pre-existing concrete type,     usually <code>LocalDevice</code>.</p><p>Behavior for energy functions are divided into:</p><ul><li><code>ReferenceType</code></li><li><code>MeasurementType</code></li></ul><p>These can be implemented by the user and then combined     with an integration, device, and evolution     using the pre-existing concrete type <code>Energy</code>.</p><p>Each type has a <code>validate</code> method defined, with the following signatures. (See the function&#39;s docstring for details.)</p><pre><code class="nohighlight hljs">validate(::AlgebraType)
validate(::DriftType; algebra::AlgebraType)
validate(::DriveType; algebra::AlgebraType, grid::IntegrationType, t)
validate(::ParameterMap; device::DeviceType)

validate(::ReferenceType; device::DeviceType)
validate(::MeasurementType; grid::IntegrationType, device::DeviceType, t)</code></pre><p>Types may optionally implement the <code>Prototypes</code> interface. Since these are often inter-dependent     (e.g. a prototypical <code>DipoleDrive</code> may depend on the <code>DriftType</code>),     prototypes defined here are implemented in a special file, <code>Prototypes.jl</code>,     and users defining their own types are advised to do something similar     for the sake of writing concise doctests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/ModularFramework.jl#L1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.AlgebraType" href="#CtrlVQE.ModularFramework.AlgebraType"><code>CtrlVQE.ModularFramework.AlgebraType</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AlgebraType{m,n}</code></pre><p>Defines a Hilbert space and an operator basis.</p><p>Delegated the following methods:</p><ul><li><code>Devices.nlevels</code></li><li><code>Devices.nqubits</code></li><li><code>Devices.noperators</code></li><li><code>Devices.localalgebra</code></li></ul><p><strong>Type Parameters</strong></p><ul><li><code>m</code>: the number of levels in each qubit</li><li><code>n</code>: the number of qubits</li></ul><p><strong>Implementation</strong></p><p>Subtypes <code>A</code> must implement the following methods:</p><ul><li><code>Devices.noperators(::Type{A})</code>:       how many unique operators define an algebra on one qubit.</li><li><code>Devices.localalgebra(::A; result)</code>: a 4d array ā       where ā[:,:,σ,q] is the σ&#39;th algebraic operator on qubit q, in the bare basis.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/core/__deviceinterface.jl#L13-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.DriftType" href="#CtrlVQE.ModularFramework.DriftType"><code>CtrlVQE.ModularFramework.DriftType</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DriftType{A}</code></pre><p>Defines the static Hamiltonian <span>$\hat H_0$</span>.</p><p>Delegated the following methods:</p><ul><li><code>Devices.qubithamiltonian</code></li><li><code>Devices.staticcoupling</code></li></ul><p><strong>Implementation</strong></p><p>Subtypes <code>H</code> must implement the following methods:</p><ul><li><code>Devices.qubithamiltonian(::H, ā, q::Int; result)</code>:       the static components of the device Hamiltonian local to qubit q.</li><li><code>Devices.staticcoupling(::H, ā; result)</code>:       the static components of the device Hamiltonian nonlocal to any one qubit.</li></ul><p>The <code>ā</code> arg is a 4d array with all algebra operators,     like the one returned by <code>Devices.localalgebra</code>     (but not necessarily in a local basis).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/core/__deviceinterface.jl#L50-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.DriveType" href="#CtrlVQE.ModularFramework.DriveType"><code>CtrlVQE.ModularFramework.DriveType</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DriveType{A}</code></pre><p>Defines a drive term <span>$\hat V_i$</span>.</p><p>Delegated the following methods:</p><ul><li><code>Devices.ngrades</code></li><li><code>Devices.driveoperator</code></li><li><code>Devices.gradeoperator</code></li><li><code>Devices.gradient</code></li></ul><p><strong>Implementation</strong></p><p>Subtypes <code>V</code> must implement the <code>Parameters</code> interface, and the following methods:</p><ul><li><code>ngrades(::Type{&lt;:V})</code>: the number of distinct gradient operators for this drive type.</li><li><code>driveoperator(::V, ā, t::Real; result)</code>:       the distinct drive operator for this channel at time <code>t</code>.</li><li><code>gradeoperator(::V, ā, j::Int, t::Real; result)</code>:       the distinct gradient operator indexed by <code>j</code> at time <code>t</code>.</li><li><code>gradient(::V, grid::Integrations.IntegrationType, ϕ; result)</code>:       the gradient vector for each variational parameter in the device.</li></ul><p>Note that the drive index <code>i</code> is omitted from the interface for <code>driveoperator</code>,     and the grade index <code>j</code> is with respect to just this channel. That means <code>j</code> will only ever take values between 1 and <code>ngrades(V)</code>. This is true of both the <code>j</code> in the signature of <code>gradeoperator</code>     and the column indices of <code>ϕ</code> in the signature of <code>gradient</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/core/__deviceinterface.jl#L78-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.LocalDrive" href="#CtrlVQE.ModularFramework.LocalDrive"><code>CtrlVQE.ModularFramework.LocalDrive</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LocalDrive{F,A}</code></pre><p>Extension of <code>DriveType</code> for <span>$\hat V_i$</span> which act on a single qubit.</p><p>Delegated <code>drivequbit</code>.</p><p><strong>Implementation</strong></p><p>Subtypes <code>D</code> must implement the <code>DriveType</code> interface, and the following method:</p><ul><li><code>Devices.drivequbit(::D)</code>: index of the qubit on which this drive is applied.</li></ul><p>Note that the drive index <code>i</code> is omitted from the interface for <code>drivequbit</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/core/__deviceinterface.jl#L115-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.MeasurementType" href="#CtrlVQE.ModularFramework.MeasurementType"><code>CtrlVQE.ModularFramework.MeasurementType</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MeasurementType{B,O}</code></pre><p>A protocol to measure scalars from a statevector.</p><p><strong>Type Parameters</strong></p><ul><li><code>B&lt;:Bases.BasisType</code>: the basis that a measurement takes place in.</li><li><code>O&lt;:Operators.OperatorType</code>: the frame rotation that a measurement takes place in.   Specifically, identifies the static operator in the interacture picture,   so <code>STATIC</code> identifies the dressed frame and <code>IDENTITY</code> identifies the lab frame.</li></ul><p><strong>Implementation</strong></p><p>TODO: Rather different now. Be sure to mention overriding initbasis/initframe if needed.</p><p>Subtypes <code>M</code> must implement the following methods:</p><ul><li><code>measure(::M, device, ψ)</code>: measures a state given in the initbasis.</li><li><code>observables(::M, device; result)</code>: constructs the observables in the initbasis.</li><li><code>CostFunctions.nobservables(::Type{M})</code>:   the number of distinct observables involved in a measurement.</li><li><code>Devices.gradient(::M, device, grid, ϕ, ψ; result)</code>:   calculates the gradient of device parameters, given gradient signals.</li></ul><p>In <code>Devices.gradient</code>, <code>ϕ[:,j,k]</code> contains the jth gradient signal     <span>$ϕ_j(t)$</span> evaluated at each point in <code>grid</code> for observable <code>k</code>,     while <code>ψ</code> contains the wavefunction itself,     evolved to the end of the grid     and rotated into the measurement basis. For the most part, implementing types will simply delegate to <code>device</code>,     whose gradient method expects the 2d array <code>ϕ[:,k]</code>. When <code>M</code> consists of more than one observable,     it will need to decide how to combine the resulting gradients into one.</p><p>While <code>initbasis</code> and <code>initframe</code> have default implementations     for singleton basis and operator types,     these methods will need to be overridden     if your measurement is ever needed with more complex types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/core/__energyinterface.jl#L69-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.ParameterMap" href="#CtrlVQE.ModularFramework.ParameterMap"><code>CtrlVQE.ModularFramework.ParameterMap</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParameterMap</code></pre><p>Enumerates the protocol for mapping device parameters to each drive.</p><p>Delegated <code>Parameters.names</code>.</p><p><strong>Implementation</strong></p><p>Subtypes <code>P</code> must implement the following methods:</p><ul><li><code>Parameters.names(::P, device)</code>: constructs a list of human-readable names       for each parameter in the <code>device</code>,       which is a device implementing the <code>Parameters</code> interface.   Certain implementations of <code>ParameterMap</code> may have additional requirements.</li><li><code>sync!(::P, device)</code>: mutate the internal parameters of a device       to match those of its drives.</li><li><code>map_values(::P, device, i::Int; result)</code>:       computes drive parameters from device parameters.</li><li><code>map_gradients(::P, device, i::Int; result)</code>:       computes drive gradients with respect to device parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/core/__deviceinterface.jl#L134-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.ReferenceType" href="#CtrlVQE.ModularFramework.ReferenceType"><code>CtrlVQE.ModularFramework.ReferenceType</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReferenceType{B}</code></pre><p>A protocol to prepare an initial statevector.</p><p><strong>Type Parameters</strong></p><ul><li><code>B&lt;:Bases.BasisType</code>: the basis that a reference was defined in</li></ul><p><strong>Implementation</strong></p><p>Subtypes <code>R</code> must implement the following methods:</p><ul><li><code>prepare(::R, device; result)</code>: constructs the initial statevector in the initbasis.</li></ul><p>While <code>initbasis</code> has a default implementation for singleton basis types,     this method will need to be overridden     if your reference is ever needed with more complex types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/core/__energyinterface.jl#L6-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.algebratype" href="#CtrlVQE.ModularFramework.algebratype"><code>CtrlVQE.ModularFramework.algebratype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">algebratype(object)</code></pre><p>Fetch the algebra type backing this object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/core/__deviceinterface.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.initbasis-Union{Tuple{CtrlVQE.ModularFramework.MeasurementType{B, O}}, Tuple{O}, Tuple{B}} where {B, O}" href="#CtrlVQE.ModularFramework.initbasis-Union{Tuple{CtrlVQE.ModularFramework.MeasurementType{B, O}}, Tuple{O}, Tuple{B}} where {B, O}"><code>CtrlVQE.ModularFramework.initbasis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initbasis(measurement)</code></pre><p>Fetch the basis that this measurement takes place in.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/core/__energyinterface.jl#L113-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.initbasis-Union{Tuple{CtrlVQE.ModularFramework.ReferenceType{B}}, Tuple{B}} where B" href="#CtrlVQE.ModularFramework.initbasis-Union{Tuple{CtrlVQE.ModularFramework.ReferenceType{B}}, Tuple{B}} where B"><code>CtrlVQE.ModularFramework.initbasis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initbasis(reference)</code></pre><p>Fetch the basis that this reference was defined in.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/core/__energyinterface.jl#L26-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.initframe-Union{Tuple{CtrlVQE.ModularFramework.MeasurementType{B, O}}, Tuple{O}, Tuple{B}} where {B, O}" href="#CtrlVQE.ModularFramework.initframe-Union{Tuple{CtrlVQE.ModularFramework.MeasurementType{B, O}}, Tuple{O}, Tuple{B}} where {B, O}"><code>CtrlVQE.ModularFramework.initframe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initframe(measurement)</code></pre><p>Fetch the frame that this measurement takes place in.</p><p>Specifically, this function fetches the static operator in the interacture picture,     so <code>STATIC</code> identifies the dressed frame and <code>IDENTITY</code> identifies the lab frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/core/__energyinterface.jl#L121-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.map_gradients" href="#CtrlVQE.ModularFramework.map_gradients"><code>CtrlVQE.ModularFramework.map_gradients</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_gradients(pmap::ParameterMap, device::ModularDevice, i::Int; result)</code></pre><p>Compute gradients for parameters in a drive term, with respect to each device parameter.</p><p><strong>Parameters</strong></p><ul><li><code>pmap</code>: the <code>ParameterMap</code> defining the family of functions to map parameters.</li><li><code>device</code>: the device, giving the device parameters (via <code>Parameters.values</code>).       Certain implementations of <code>ParameterMap</code> may have additional requirements.</li><li><code>i</code>: identifies which function in the family (i.e. indexes the drive).</li></ul><p><strong>Returns</strong></p><p>A matrix <code>g</code>, such that <code>g[k,j]</code> is <span>$∂_{x_k} y_j$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/core/__deviceinterface.jl#L193-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.map_values" href="#CtrlVQE.ModularFramework.map_values"><code>CtrlVQE.ModularFramework.map_values</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_values(pmap::ParameterMap, device, i::Int; result)</code></pre><p>Compute the parameters for a drive term, as a function of all device parameters.</p><p><strong>Parameters</strong></p><ul><li><code>pmap</code>: the <code>ParameterMap</code> defining the family of functions to map parameters.</li><li><code>device</code>: the device, giving the device parameters (via <code>Parameters.values</code>).       Certain implementations of <code>ParameterMap</code> may have additional requirements.</li><li><code>i</code>: identifies which function in the family (i.e. indexes the drive).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/core/__deviceinterface.jl#L178-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.measure" href="#CtrlVQE.ModularFramework.measure"><code>CtrlVQE.ModularFramework.measure</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measure(measurement, device, ψ)
measure(measurement, device, ψ, t)
measure(measurement, device, basis, ψ)
measure(measurement, device, basis, ψ, t)</code></pre><p>Measure the state ψ, provided in the given basis, at time t.</p><p><strong>Parameters</strong></p><ul><li><code>measurement::MeasurementType</code>: the measurement protocol.</li><li><code>device::DeviceType</code>: the device being measured.</li><li><code>basis::BasisType</code>: the basis that <code>ψ</code> is represented in.   Defaults to <code>initbasis</code> when omitted.</li><li><code>ψ::AbstractVector</code>: the state to measure.</li><li><code>t::Real</code>: the time at which <code>ψ</code> is being measured,   i.e. the time over which to evolve the frame operator.   When <code>t</code> is omitted, the frame rotation is skipped.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/core/__energyinterface.jl#L134-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.observables" href="#CtrlVQE.ModularFramework.observables"><code>CtrlVQE.ModularFramework.observables</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">observables(measurement, device; result=nothing)
observables(measurement, device, t; result=nothing)
observables(measurement, device, basis; result=nothing)
observables(measurement, device, basis, t; result=nothing)</code></pre><p>Constructs the Hermitian observables involved in this measurement.</p><p><strong>Parameters</strong></p><ul><li><code>measurement::MeasurementType</code>: the measurement protocol.</li><li><code>device::DeviceType</code>: the device being measured.</li><li><code>basis::BasisType</code>: the basis the observables are represented in.   Defaults to <code>initbasis</code> when omitted.</li><li><code>t::Real</code>: the time at which the measurement takes place,   i.e. the time over which to evolve the frame operator.   When <code>t</code> is omitted, the frame rotation is skipped.</li></ul><p>The returned result is also written to the <code>result</code> kwarg when provided.</p><p><strong>Returns</strong></p><p>A 3darray indexed such that <code>result[:,:,k]</code> is the kth matrix,     the same format required by the parameter Ō in <code>Evolutions.gradientsignal</code>. The size of the third dimension must be equal to <code>nobservables(measurement)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/core/__energyinterface.jl#L209-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.prepare" href="#CtrlVQE.ModularFramework.prepare"><code>CtrlVQE.ModularFramework.prepare</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepare(reference, device; result=nothing)
prepare(reference, device, basis; result=nothing)</code></pre><p>Prepare the state and represent it as a statevector in the given basis.</p><p><strong>Parameters</strong></p><ul><li><code>reference::ReferenceType</code>: the state preparation protocol.</li><li><code>device::DeviceType</code>: the device for which the state is being prepared.</li><li><code>basis::BasisType</code>: the basis to represent the reference state in   (defaults to <code>initbasis</code> when omitted).</li></ul><p>The returned result is also written to the <code>result</code> kwarg when provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/core/__energyinterface.jl#L34-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.sync!" href="#CtrlVQE.ModularFramework.sync!"><code>CtrlVQE.ModularFramework.sync!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sync!(device)
sync!(pmap::ParameterMap, device)</code></pre><p>Mutate the internal parameters of a device to match those of its drives.</p><p>The one-parameter signature requires <code>device</code> to have a property <code>pmap</code>,     which is the parameter map that will be used for dispatch. Both signatures require <code>device</code> to have the property <code>x</code>     which is a vector of all the parameters of <code>device</code>. Certain implementations of <code>ParameterMap</code> may have additional requirements.</p><p>This function may resize <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/core/__deviceinterface.jl#L158-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.LocalDevices.LocalDevice" href="#CtrlVQE.ModularFramework.LocalDevices.LocalDevice"><code>CtrlVQE.ModularFramework.LocalDevices.LocalDevice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LocalDevice(algebra, drift, drives, pmap, x)</code></pre><p>A totally modular device, with some restrictions (see below).</p><p><strong>Parameters</strong></p><ul><li><p><code>algebra::AlgebraType</code>: the algebra, defining the Hilbert space.</p></li><li><p><code>drift::DriftType</code>: the drift term, describing the static Hamiltonian.</p></li><li><p><code>drives::Vector{&lt;:DriveType}</code> a vector of drive terms,       describing the time-dependent Hamiltonian.</p></li><li><p><code>pmap::ParameterMap</code>: the parameter map,   defining the relationship between device and drive parameters.</p></li><li><p><code>x::Vector{&lt;:AbstractFloat}</code>: the initial device parameters</p><p>LocalDevice(F, algebra, drift, drives, pmap)</p></li></ul><p>The typical constructor for a <code>LocalDevice</code>.</p><p><strong>Parameters</strong></p><ul><li><code>F</code>: the float type for this device (typically <code>Float64</code>).</li><li><code>algebra::AlgebraType</code>: the algebra, defining the Hilbert space.</li><li><code>drift::DriftType</code>: the drift term, describing the static Hamiltonian.</li><li><code>drives::Vector{&lt;:DriveType}</code> a vector of drive terms,       describing the time-dependent Hamiltonian.</li><li><code>pmap::ParameterMap</code>: the parameter map,   defining the relationship between device and drive parameters.</li></ul><p>The device parameters are initialized to be consistent with <code>drives</code>     (though the <em>degree</em> of consistency is defined by <code>pmap</code>).</p><p><strong>Restrictions</strong></p><ul><li><p>Drift can&#39;t be parametric</p><ul><li>I could program around this, but it would add an unnecessary amount of code for a feature I may never use.</li><li>In principle, another type could relax this restriction if:<ul><li>compatible drift types implement the <code>Parameters</code> interface.</li><li>compatible parameter map types implement suitable versions   of <code>map_values</code> and <code>map_gradients</code></li><li>the <code>bind!</code> method clears relevant methods from the <code>Memoization.jl</code> cache.</li><li>all loops in this file with parameter manipulation include a step for the drift.</li></ul></li></ul></li><li><p>Only works with LocalDrives</p><ul><li>This restriction is necessary only due to lack of multiple inheritance in Julia. In other words, I <em>have</em> to subtype <code>LocallyDrivenDevice</code>     in order to get the fast evolution,     and that means I <em>have</em> to restrict the drives to those compatible with it. But <em>none</em> of the code here depends on it,     other than the parts implementing the interface for <code>LocallyDrivenDevice</code>.</li><li>In principle, another type could relax this restriction if:<ul><li>you copy and paste the whole file.</li><li>switch out <code>LocallDrivenDevice</code> for <code>LocalDevice</code></li><li>switch out <code>LocalDrive</code> with <code>DriveType</code>.</li><li>delete the parts with <code>drivequbit</code> and <code>gradequbit</code>.</li></ul></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/core/LocalDevices.jl#L13-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.Energies.Energy" href="#CtrlVQE.ModularFramework.Energies.Energy"><code>CtrlVQE.ModularFramework.Energies.Energy</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Energy(evolution, device, grid, reference, measurement)</code></pre><p>A totally modular energy function.</p><p><strong>Parameters</strong></p><ul><li><code>evolution::EvolutionType</code>: the time integration algorithm</li><li><code>device::DeviceType</code>: the device that gets evolved in time</li><li><code>grid::IntegrationType</code>: the time grid to integrate over</li><li><code>reference::ReferenceType</code>: the reference state to initialize the device to</li><li><code>measurement::MeasurementType</code>: the protocol to extract energies from evolved states</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/core/Energies.jl#L13-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.DrivePenalties.DrivePenalty" href="#CtrlVQE.ModularFramework.DrivePenalties.DrivePenalty"><code>CtrlVQE.ModularFramework.DrivePenalties.DrivePenalty</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DrivePenalty(device, penalties::AbstractVector{&lt;:CostFunctionType})</code></pre><p>The sum of several penalty functions acting on a device&#39;s drives.</p><p>In order for this type to be usable,     each penalty in <code>penalties</code> must act on parameters corresponding to     the drives contained in <code>device.drives</code>,     and device parameters must be mapped onto drives according to <code>device.pmap</code>. This interface is suitable for the <code>Device</code> types in <code>ModularFramework</code>.</p><p>This struct records the last values computed (value or gradient)     for each cost function in its <code>values</code> and <code>gradients</code> fields.</p><p>Beware that the <code>components</code> field is a vector with abstract eltype. This is a relatively mild form of type instability;     certain compiled code could hypothetically be sub-optimal. But it does not appear to cause any noticeable disadvantage;     see <code>Examples/CompositeCostFunctions</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/core/DrivePenalties.jl#L11-L31">source</a></section></article><h2 id="Device-Modules"><a class="docs-heading-anchor" href="#Device-Modules">Device Modules</a><a id="Device-Modules-1"></a><a class="docs-heading-anchor-permalink" href="#Device-Modules" title="Permalink"></a></h2><h3 id="Algebras"><a class="docs-heading-anchor" href="#Algebras">Algebras</a><a id="Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Algebras" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.TruncatedBosonicAlgebras.TruncatedBosonicAlgebra" href="#CtrlVQE.ModularFramework.TruncatedBosonicAlgebras.TruncatedBosonicAlgebra"><code>CtrlVQE.ModularFramework.TruncatedBosonicAlgebras.TruncatedBosonicAlgebra</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TruncatedBosonicAlgebra{m,n}()</code></pre><p>An algebra of <code>n</code> distinguishable bosonic modes, each represented with <code>m</code> levels.</p><p>This algebra is useful for transmon architectures.</p><pre><code class="language-julia-repl hljs">julia&gt; using CtrlVQE.ModularFramework;

julia&gt; A = TruncatedBosonicAlgebra{3,2};

julia&gt; validate(A());

julia&gt; nlevels(A)
3
julia&gt; nqubits(A)
2
julia&gt; noperators(A)
1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/basics/TruncatedBosonicAlgebras.jl#L6-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.PauliAlgebras.PauliAlgebra" href="#CtrlVQE.ModularFramework.PauliAlgebras.PauliAlgebra"><code>CtrlVQE.ModularFramework.PauliAlgebras.PauliAlgebra</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PauliAlgebra{n}()</code></pre><p>An algebra of <code>n</code> spinors, represented with the Pauli spin matrices.</p><pre><code class="language-julia-repl hljs">julia&gt; using CtrlVQE.ModularFramework;

julia&gt; A = PauliAlgebra{4};

julia&gt; validate(A());

julia&gt; nlevels(A)
2
julia&gt; nqubits(A)
4
julia&gt; noperators(A)
3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/basics/PauliAlgebras.jl#L6-L27">source</a></section></article><h3 id="Drifts"><a class="docs-heading-anchor" href="#Drifts">Drifts</a><a id="Drifts-1"></a><a class="docs-heading-anchor-permalink" href="#Drifts" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.TransmonDrifts.TransmonDrift" href="#CtrlVQE.ModularFramework.TransmonDrifts.TransmonDrift"><code>CtrlVQE.ModularFramework.TransmonDrifts.TransmonDrift</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TransmonDrift(ω, δ, g, quples)</code></pre><p>A static Hamiltonian for architectures of <code>n</code> transmons with fixed-couplings.</p><p>``\hat H<em>0 = \sum</em>q ω<em>q \hat a^\dagger</em>q \hat a_q</p><ul><li>\sum<em>q δ</em>q \hat a^\dagger<em>q \hat a^\dagger</em>q \hat a<em>q \hat a</em>q</li><li>\sum<em>{⟨pq⟩} g</em>{pq} (\hat a^\dagger<em>p \hat a</em>q + \hat a^\dagger<em>q \hat a</em>p)``</li></ul><p><strong>Parameters</strong></p><ul><li><code>ω</code>: a vector of <code>n</code> resonance frequencies</li><li><code>δ</code>: a vector of <code>n</code> anharmonicities</li><li><code>g</code>: a vector of coupling strengths</li><li><code>quples</code>: a vector of <code>Quple</code>   identifying the qubit pairs associated with each <code>g[i]</code></li></ul><pre><code class="language-julia-repl hljs">julia&gt; using CtrlVQE.ModularFramework;

julia&gt; A = TruncatedBosonicAlgebra{3,2};

julia&gt; drift = TransmonDrift{A}([4.82, 4.84], [0.30, 0.30], [0.02], [Quple(1,2)]);

julia&gt; validate(drift; algebra=A());

julia&gt; ā0 = Devices.localalgebra(A());

julia&gt; Devices.qubithamiltonian(drift, ā0, 1)
3×3 Matrix{ComplexF64}:
 0.0+0.0im   0.0+0.0im   0.0+0.0im
 0.0+0.0im  4.82+0.0im   0.0+0.0im
 0.0+0.0im   0.0+0.0im  9.34+0.0im

julia&gt; Devices.qubithamiltonian(drift, ā0, 2)
3×3 Matrix{ComplexF64}:
 0.0+0.0im   0.0+0.0im   0.0+0.0im
 0.0+0.0im  4.84+0.0im   0.0+0.0im
 0.0+0.0im   0.0+0.0im  9.38+0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/basics/TransmonDrifts.jl#L13-L54">source</a></section></article><h3 id="Drives"><a class="docs-heading-anchor" href="#Drives">Drives</a><a id="Drives-1"></a><a class="docs-heading-anchor-permalink" href="#Drives" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.DipoleDrives.DipoleDrive" href="#CtrlVQE.ModularFramework.DipoleDrives.DipoleDrive"><code>CtrlVQE.ModularFramework.DipoleDrives.DipoleDrive</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DipoleDrive(q, ω, Ω, Δ)</code></pre><p>A drive term representing interaction of a bosonic mode with an electric dipole,     in the rotating wave approximation.</p><p><span>$\hat V = Ω(t) e^{i [Δ(t)+ω] t} \hat a_q + {\rm h.t.}$</span></p><p><strong>Parameters</strong></p><ul><li><code>q</code>: the integer index identifying which qubit this drive applies to</li><li><code>ω</code>: the resonance frequency of the qubit</li><li><code>Ω</code>: a <code>SignalType</code> representing the complex drive strength over time</li><li><code>Δ</code>: a <code>SignalType</code> representing the detuning over time</li></ul><pre><code class="language-julia-repl hljs">julia&gt; grid = TemporalLattice(20.0, 400);

julia&gt; Ω = Constant(2.0+1.0im);

julia&gt; Δ = Constant(0.0);

julia&gt; using CtrlVQE.ModularFramework;

julia&gt; A = TruncatedBosonicAlgebra{3,2};

julia&gt; drive = DipoleDrive{A}(1, 4.82, Ω, Δ);

julia&gt; validate(drive; algebra=A(), grid=grid, t=10.0);

julia&gt; ā0 = Devices.localalgebra(A());

julia&gt; Devices.driveoperator(drive, ā0, 10.0)
3×3 Matrix{ComplexF64}:
        0.0+0.0im      -0.0693931-2.23499im         0.0+0.0im
 -0.0693931+2.23499im         0.0+0.0im      -0.0981367-3.16075im
        0.0+0.0im      -0.0981367+3.16075im         0.0+0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/basics/DipoleDrives.jl#L10-L49">source</a></section></article><h3 id="Parameter-Mappers"><a class="docs-heading-anchor" href="#Parameter-Mappers">Parameter Mappers</a><a id="Parameter-Mappers-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Mappers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.DisjointMappers.DisjointMapper" href="#CtrlVQE.ModularFramework.DisjointMappers.DisjointMapper"><code>CtrlVQE.ModularFramework.DisjointMappers.DisjointMapper</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DISJOINT</code></pre><p>Useful for when parameters for each drive are completely independent of one another.</p><p>In this case, all the parameters for drive 1     are followed by all the parameters for drive 2, and so on.</p><pre><code class="language-julia-repl hljs">julia&gt; using CtrlVQE.ModularFramework;

julia&gt; pmap = DISJOINT;

julia&gt; device = Prototype(LocalDevice{Float64}; n=3, pmap=pmap);

julia&gt; validate(pmap; device=device);

julia&gt; map_values(pmap, device, 1)
2-element Vector{Float64}:
 0.0
 0.0

julia&gt; Parameters.count(device)
6
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/basics/DisjointMappers.jl#L7-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.LinearMappers.LinearMapper" href="#CtrlVQE.ModularFramework.LinearMappers.LinearMapper"><code>CtrlVQE.ModularFramework.LinearMappers.LinearMapper</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearMapper(encoding::Vector{F}, size::Vector{Int})
LinearMapper(A::Array{F,3})</code></pre><p>Associate each device parameter with the weight of a basis vector for each drive.</p><p>The implemetation of this type is designed     around the assumption that each drive has the same number of parameters.</p><p>The linear map <code>A</code> is a 3d array such that <code>y[i] = A[:,:,i] * x</code>,     where <code>y[i]</code> is the parameter vector for drive <code>i</code>     and <code>x</code> is the parameter vector for the whole device.</p><p><code>A</code> is represented internally as a data vector <code>encoding</code> and shape vector <code>size</code>,     so that it can be resized in-place.</p><pre><code class="language-julia-repl hljs">julia&gt; using CtrlVQE.ModularFramework;

julia&gt; pmap = LinearMapper(ones(2,4,3));

julia&gt; device = Prototype(LocalDevice{Float64}; n=3, pmap=pmap);

julia&gt; validate(pmap; device=device);

julia&gt; map_values(pmap, device, 1)
2-element Vector{Float64}:
 0.0
 0.0

julia&gt; Parameters.count(device)
4
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/basics/LinearMappers.jl#L9-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.LinearMappers.addbasisvector!-Union{Tuple{F}, Tuple{CtrlVQE.ModularFramework.LinearMappers.LinearMapper{F}, AbstractMatrix{F}}} where F" href="#CtrlVQE.ModularFramework.LinearMappers.addbasisvector!-Union{Tuple{F}, Tuple{CtrlVQE.ModularFramework.LinearMappers.LinearMapper{F}, AbstractMatrix{F}}} where F"><code>CtrlVQE.ModularFramework.LinearMappers.addbasisvector!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addbasisvector!(pmap, a)</code></pre><p>Update a <code>LinearMapper</code> to add in a new device parameter.</p><p>You&#39;ll pretty much always need to <code>sync!</code> a device after calling this.</p><p><strong>Parameters</strong></p><ul><li><code>pmap</code>: the <code>LinearMapper</code> object to mutate.</li><li><code>a::AbstractMatrix</code>: a[:,i] contains the mapping   from the new device parameter to the parameters of drive <code>i</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/basics/LinearMappers.jl#L92-L104">source</a></section></article><h2 id="Energy-Modules"><a class="docs-heading-anchor" href="#Energy-Modules">Energy Modules</a><a id="Energy-Modules-1"></a><a class="docs-heading-anchor-permalink" href="#Energy-Modules" title="Permalink"></a></h2><h3 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.KetReferences.KetReference" href="#CtrlVQE.ModularFramework.KetReferences.KetReference"><code>CtrlVQE.ModularFramework.KetReferences.KetReference</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KetReference(basis::B, ket)</code></pre><p>Represents a basis state of the given basis <code>B</code>.</p><p><strong>Parameters</strong></p><ul><li><code>basis::Bases.BasisType</code>: the basis this ket is defined in.</li><li><code>ket</code>: a vector of integers representing the ket.   For example, <code>[0,1,1]</code> represents state <code>|011⟩</code>, the fourth basis state.   Note that index 1 of the ket is the <em>most significant</em> bit.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using CtrlVQE.ModularFramework;

julia&gt; reference = KetReference(BARE, [0,1]);

julia&gt; device = Prototype(LocalDevice{Float64}; n=2);

julia&gt; validate(reference; device=device);

julia&gt; prepare(reference, device)
4-element Vector{ComplexF64}:
 0.0 + 0.0im
 1.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/basics/KetReferences.jl#L8-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.DenseReferences.DenseReference" href="#CtrlVQE.ModularFramework.DenseReferences.DenseReference"><code>CtrlVQE.ModularFramework.DenseReferences.DenseReference</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DenseReference(basis::B, statevector; m, n)</code></pre><p>Represents an arbitrary statevector of the given basis <code>B</code>.</p><p><strong>Parameters</strong></p><ul><li><code>basis::Bases.BasisType</code>: the basis where <code>statevector</code> represents the reference.</li><li><code>statevector::AbstractVector</code>: a dense statevector.</li></ul><p>The kwargs <code>m</code> and <code>n</code> specify the number of levels and number of qubits     for which the statevector is defined. The reference state may be prepared on a device with the same number of qubits,     and at least as many levels. Typically, only one of <code>m</code> and <code>n</code> are provided,     and the other is inferred from the length of <code>statevector</code>. If neither is provided, <code>m</code> defaults to 2. If both are provided, an error will be thrown     if they are not consistent with the length of <code>statevector</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using CtrlVQE.ModularFramework;

julia&gt; reference = DenseReference(BARE, [0,1,0,0]);

julia&gt; device = Prototype(LocalDevice{Float64}; n=2);

julia&gt; validate(reference; device=device);

julia&gt; prepare(reference, device)
4-element Vector{ComplexF64}:
 0.0 + 0.0im
 1.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/basics/DenseReferences.jl#L10-L47">source</a></section></article><h3 id="Measurements"><a class="docs-heading-anchor" href="#Measurements">Measurements</a><a id="Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Measurements" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.PauliMeasurements.PauliMeasurement" href="#CtrlVQE.ModularFramework.PauliMeasurements.PauliMeasurement"><code>CtrlVQE.ModularFramework.PauliMeasurements.PauliMeasurement</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PauliMeasurement(basis, frame, X, Z, c)</code></pre><p>Represents a bare measurement of a linear combination of Paulis,     without any logical projection prior to frame rotation.</p><p>Paulis are encoded symplectically, as two length-<code>n</code> bitstrings labeled <code>x</code> and <code>z</code>. 1s in <code>x</code> indicate a Pauli X appears on that bit; 1s in <code>z</code> indicate the same for Z. When a bit has both an X and a Z, it is interpreted as having a Y. (You could think of it as Z*X = iY, except the implementation here ignores phase.)</p><p><strong>Parameters</strong></p><ul><li><code>basis</code>: the <code>BasisType</code> identifying the basis <code>observable</code> is written in.</li><li><code>frame</code>: the <code>OperatorType</code> identifying the frame where measurements are conducted.</li><li><code>X</code>: a vector of integers whose bitstrings give each <code>x</code>.</li><li><code>Z</code>: a vector of integers whose bitstrings give each <code>z</code>.</li><li><code>c</code>: a vector of floats giving the coefficients for each pauli word.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/basics/PauliMeasurements.jl#L15-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.PauliMeasurements.PauliMeasurement-Union{Tuple{F}, Tuple{O}, Tuple{B}, Tuple{B, O, AbstractMatrix{F}}} where {B, O, F}" href="#CtrlVQE.ModularFramework.PauliMeasurements.PauliMeasurement-Union{Tuple{F}, Tuple{O}, Tuple{B}, Tuple{B, O, AbstractMatrix{F}}} where {B, O, F}"><code>CtrlVQE.ModularFramework.PauliMeasurements.PauliMeasurement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PauliMeasurement(basis, frame, observable; eps=1e-10)</code></pre><p>A constructor accepting a dense matrix observable.</p><p>The Pauli coefficients are computed once from (a not very efficient implementation of)     the Hilbert-Schmidt inner product.</p><p><strong>Parameters</strong></p><ul><li><code>basis</code>: the <code>BasisType</code> identifying the basis <code>observable</code> is written in.</li><li><code>frame</code>: the <code>OperatorType</code> identifying the frame where measurements are conducted.</li><li><code>observable</code>: the dense matrix observable.</li><li><code>eps</code>: smallest coefficient to keep before discarding as negligible.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/basics/PauliMeasurements.jl#L125-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.PauliMeasurements.PauliMeasurement-Union{Tuple{O}, Tuple{B}, Tuple{B, O}} where {B, O}" href="#CtrlVQE.ModularFramework.PauliMeasurements.PauliMeasurement-Union{Tuple{O}, Tuple{B}, Tuple{B, O}} where {B, O}"><code>CtrlVQE.ModularFramework.PauliMeasurements.PauliMeasurement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PauliMeasurement(basis, frame; paulis...)</code></pre><p>A constructor accepting coefficients for each Pauli word.</p><p><strong>Parameters</strong></p><ul><li><code>basis</code>: the <code>BasisType</code> identifying the basis <code>observable</code> is written in.</li><li><code>frame</code>: the <code>OperatorType</code> identifying the frame where measurements are conducted.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li>Each key is a consistent-length string consisting only of &quot;I&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;.</li><li>Each value is the float coefficient for that Pauli word.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using CtrlVQE.ModularFramework;

julia&gt; I = [1 0; 0 1]; X = [0 1; 1 0]; Z = [1 0; 0 -1];

julia&gt; observable = (0.5 .* kron(X,Z)) .+ (1.0 .* kron(I, Z))
4×4 Matrix{Float64}:
 1.0   0.0  0.5   0.0
 0.0  -1.0  0.0  -0.5
 0.5   0.0  1.0   0.0
 0.0  -0.5  0.0  -1.0

julia&gt; measurement = PauliMeasurement(BARE, STATIC; XZ=0.5, IZ=1.0);

julia&gt; device = Prototype(LocalDevice{Float64}; n=2);

julia&gt; validate(measurement; device=device);

julia&gt; Ō = observables(measurement, device);

julia&gt; size(Ō)
(4, 4, 1)

julia&gt; observable ≈ reshape(Ō, (4,4))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/basics/PauliMeasurements.jl#L54-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.ModularFramework.DenseMeasurements.DenseMeasurement" href="#CtrlVQE.ModularFramework.DenseMeasurements.DenseMeasurement"><code>CtrlVQE.ModularFramework.DenseMeasurements.DenseMeasurement</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DenseMeasurement(basis, frame, observable)</code></pre><p>Represents a bare measurement of a matrix observable in a given basis and frame,     without any logical projection prior to frame rotation.</p><p><strong>Parameters</strong></p><ul><li><code>observable</code>: the dense matrix observable.</li><li><code>basis</code>: the <code>BasisType</code> identifying the basis <code>observable</code> is written in.</li><li><code>frame</code>: the <code>OperatorType</code> identifying the frame where measurements are conducted.</li></ul><p>Specifically, the operator identified by <code>frame</code>     is the one we rotate by for duration <code>t</code>     to move from the &quot;lab&quot; frame to the interaction picture. Use <code>IDENTITY</code> for the lab frame itslef, and <code>STATIC</code> for the dressed frame.</p><pre><code class="language-julia-repl hljs">julia&gt; using CtrlVQE.ModularFramework;

julia&gt; I = [1 0; 0 1]; X = [0 1; 1 0]; Z = [1 0; 0 -1];

julia&gt; observable = (0.5 .* kron(X,Z)) .+ (1.0 .* kron(I, Z))
4×4 Matrix{Float64}:
 1.0   0.0  0.5   0.0
 0.0  -1.0  0.0  -0.5
 0.5   0.0  1.0   0.0
 0.0  -0.5  0.0  -1.0

julia&gt; measurement = DenseMeasurement(BARE, STATIC, observable);

julia&gt; device = Prototype(LocalDevice{Float64}; n=2);

julia&gt; validate(measurement; device=device);

julia&gt; Ō = observables(measurement, device);

julia&gt; size(Ō)
(4, 4, 1)

julia&gt; observable ≈ reshape(Ō, (4,4))
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/a474d196c4fd1c0743ae12291d670dd1ba8a8144/src/modulars/basics/DenseMeasurements.jl#L11-L55">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../enums/">« Enumerations</a><a class="docs-footer-nextpage" href="../utils/">Utilities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Tuesday 11 March 2025 12:22">Tuesday 11 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
