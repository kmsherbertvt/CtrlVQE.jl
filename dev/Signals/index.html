<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Signals · CtrlVQE.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://kmsherbertvt.github.io/CtrlVQE.jl/Signals/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CtrlVQE.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">CtrlVQE</a></li><li><a class="tocitem" href="../Bases/">Bases</a></li><li><a class="tocitem" href="../Devices/">Devices</a></li><li><a class="tocitem" href="../Evolutions/">Evolutions</a></li><li><a class="tocitem" href="../LinearAlgebraTools/">LinearAlgebraTools</a></li><li><a class="tocitem" href="../Operators/">Operators</a></li><li><a class="tocitem" href="../Parameters/">Parameters</a></li><li class="is-active"><a class="tocitem" href>Signals</a><ul class="internal"><li><a class="tocitem" href="#Constant-Signals"><span>Constant Signals</span></a></li><li><a class="tocitem" href="#Interval-Signals"><span>Interval Signals</span></a></li><li><a class="tocitem" href="#Step-Function-Signals"><span>Step Function Signals</span></a></li><li><a class="tocitem" href="#Gaussian-Signals"><span>Gaussian Signals</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Signals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Signals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/main/docs/src/Signals.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Signals"><a class="docs-heading-anchor" href="#Signals">Signals</a><a id="Signals-1"></a><a class="docs-heading-anchor-permalink" href="#Signals" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals" href="#CtrlVQE.Signals"><code>CtrlVQE.Signals</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Signals</code></pre><p>Time-dependent functions suitable for control signals with variational parameters.</p><p>The main motivation of this module     is to provide a common interface for analytical gradients and optimization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/CtrlVQE.jl#L333-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.AbstractSignal" href="#CtrlVQE.Signals.AbstractSignal"><code>CtrlVQE.Signals.AbstractSignal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSignal{P,R}</code></pre><p>Super-type for all signal objects <span>$Ω(t)$</span>.</p><p><strong>Type Parameters</strong></p><ul><li><code>P</code> denotes the type of all variational parameters. Must be a real float.</li><li><code>R</code> denotes the type of <span>$Ω(t)$</span> itself. May be any number type.</li></ul><p><strong>Implementation</strong></p><p>Any concrete sub-type <code>S</code> must implement all functions in the <code>Parameters</code> module.</p><ul><li>In particular, <code>Parameters.values(Ω::S)</code> must return a vector of type <code>P</code>.</li><li>If you are trying to create your own signal type,   you <em>probably</em> want to implement a <code>ParametricSignal</code>,   which already has an implementation for the <code>Parameters</code> interface.</li></ul><p>In addition, the following methods must be implemented:</p><ul><li><p><code>(Ω::S)(t::Real)</code>:       the actual function <span>$Ω(t)$</span>. Must return a number of type <code>R</code>.</p></li><li><p><code>partial(i::Int, Ω::S, t::Real)</code>:       the partial derivative <span>$∂Ω/∂x_i$</span> evaluated at time <code>t</code>,       where <span>$x_i$</span> is Ω&#39;s i-th variational parameter (ie. <code>Parameters.names(Ω)[i]</code>).       Must return a number of type <code>R</code>.</p></li><li><p><code>Base.string(Ω::S, names::AbstractVector{String})</code>:       a human-readable description of the signal,       inserting each element of <code>names</code> in the place of the corresponding parameter.   For example, a complex constant signal might return a description like &quot;A + i B&quot;,       where <code>A</code> and <code>B</code> are the &quot;names&quot; given by the <code>names</code> argument.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Signals.jl#L7-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.AbstractSignal-Union{Tuple{AbstractVector{&lt;:Real}}, Tuple{R}, Tuple{P}} where {P, R}" href="#CtrlVQE.Signals.AbstractSignal-Union{Tuple{AbstractVector{&lt;:Real}}, Tuple{R}, Tuple{P}} where {P, R}"><code>CtrlVQE.Signals.AbstractSignal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(signal::AbstractSignal{P,R})(t̄::AbstractVector{&lt;:Real}; result=nothing)</code></pre><p>Vectorized version. Returns a vector of type <code>R</code>.</p><p>Optionally, pass a pre-allocated array of compatible type and shape as <code>result</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Signals.jl#L54-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.AbstractSignal-Union{Tuple{Real}, Tuple{R}, Tuple{P}} where {P, R}" href="#CtrlVQE.Signals.AbstractSignal-Union{Tuple{Real}, Tuple{R}, Tuple{P}} where {P, R}"><code>CtrlVQE.Signals.AbstractSignal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(signal::AbstractSignal{P,R})(t::Real)</code></pre><p>The signal at time <code>t</code>, ie. <span>$Ω(t)$</span>. Returns a number of type <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Signals.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.string-Tuple{CtrlVQE.Signals.AbstractSignal, AbstractVector{String}}" href="#Base.string-Tuple{CtrlVQE.Signals.AbstractSignal, AbstractVector{String}}"><code>Base.string</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.string(Ω::AbstractSignal, names::AbstractVector{String})</code></pre><p>Substitutes the default name of each variational parameter for the ones in <code>names</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Signals.jl#L121-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.string-Tuple{CtrlVQE.Signals.AbstractSignal}" href="#Base.string-Tuple{CtrlVQE.Signals.AbstractSignal}"><code>Base.string</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.string(Ω::AbstractSignal)</code></pre><p>A human-readable description of the signal. Returns type <code>string</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Signals.jl#L111-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.integrate_partials-Union{Tuple{R}, Tuple{P}, Tuple{CtrlVQE.Signals.AbstractSignal{P, R}, AbstractVector, AbstractVector, AbstractVector}} where {P, R}" href="#CtrlVQE.Signals.integrate_partials-Union{Tuple{R}, Tuple{P}, Tuple{CtrlVQE.Signals.AbstractSignal{P, R}, AbstractVector, AbstractVector, AbstractVector}} where {P, R}"><code>CtrlVQE.Signals.integrate_partials</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integrate_partials(signal::AbstractSignal{P,R}, τ̄, t̄, ϕ̄; result=nothing)</code></pre><p>Integrates each partial derivative <span>$∂Ω/∂x_i|_t$</span>, modulated by a function <span>$ϕ(t)$</span>.</p><p>Specifically, this method returns a vector of integrals <code>I</code>,     where <code>I[i]</code> is the <em>real part</em> of <span>$∫ ϕ(t) ⋅ ∂Ω/∂x_i|_t dt$</span>.</p><p>Taking the real part is a little ad hoc. If Ω and ϕ are complex functions -     let&#39;s just say <span>$Ω(t)=α(t)+i β(t)$</span> and <span>$ϕ(t)=ϕ_α(t) - i ϕ_β(t)$</span> -     the integrals become <span>$∫ ϕ_α(t) ⋅ ∂α/∂x_i|_t dt + ∫ ϕ_β(t) ⋅ ∂β/∂x_i|_t dt$</span>. This turns out to be the relevant quantity in many gradient calculations.</p><p><strong>Arguments</strong></p><ul><li>signal</li><li>τ̄: a vector of time spacings, as given by <code>Evolutions.trapezoidaltimegrid</code>.</li><li>t̄: a vector of time points, as given by <code>Evolutions.trapezoidaltimegrid</code>.</li><li>ϕ̄: a vector of the modulating function <span>$ϕ(t)$</span> evaluated at each point in <code>t̄</code>.</li></ul><p>Optionally, pass a pre-allocated array of compatible type and shape as <code>result</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Signals.jl#L134-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.integrate_signal-Union{Tuple{R}, Tuple{P}, Tuple{CtrlVQE.Signals.AbstractSignal{P, R}, AbstractVector, AbstractVector, AbstractVector}} where {P, R}" href="#CtrlVQE.Signals.integrate_signal-Union{Tuple{R}, Tuple{P}, Tuple{CtrlVQE.Signals.AbstractSignal{P, R}, AbstractVector, AbstractVector, AbstractVector}} where {P, R}"><code>CtrlVQE.Signals.integrate_signal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integrate_signal(signal::AbstractSignal{P,R}, τ̄, t̄, ϕ̄; result=nothing)</code></pre><p>Integrates a signal <span>$Ω(t)$</span>, modulated by a function <span>$ϕ(t)$</span>.</p><p>Specifically, this method returns the <em>real part</em> of <span>$∫ ϕ(t) ⋅ Ω(t) dt$</span>.</p><p>Taking the real part is a little ad hoc. If Ω and ϕ are complex functions -     let&#39;s just say <span>$Ω(t)=α(t)+i β(t)$</span> and <span>$ϕ(t)=t[ϕ_β(t) + i ϕ_α(t)]$</span> -     the integral becomes <span>$∫ t⋅ϕ_β(t)⋅α(t) dt - ∫ t⋅ϕ_α(t)⋅β(t) dt$</span>. This turns out to be the relevant quantity in transmon frequency gradient calculations.</p><p><strong>Arguments</strong></p><ul><li>signal</li><li>τ̄: a vector of time spacings, as given by <code>Evolutions.trapezoidaltimegrid</code>.</li><li>t̄: a vector of time points, as given by <code>Evolutions.trapezoidaltimegrid</code>.</li><li>ϕ̄: a vector of the modulating function <span>$ϕ(t)$</span> evaluated at each point in <code>t̄</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Signals.jl#L187-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.partial-Union{Tuple{R}, Tuple{P}, Tuple{Int64, CtrlVQE.Signals.AbstractSignal{P, R}, AbstractVector{&lt;:Real}}} where {P, R}" href="#CtrlVQE.Signals.partial-Union{Tuple{R}, Tuple{P}, Tuple{Int64, CtrlVQE.Signals.AbstractSignal{P, R}, AbstractVector{&lt;:Real}}} where {P, R}"><code>CtrlVQE.Signals.partial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partial(
    i::Int, signal::AbstractSignal{P,R}, t̄::AbstractVector{&lt;:Real};
    result=nothing,
)</code></pre><p>Vectorized version. Returns a vector of type <code>R</code>.</p><p>Optionally, pass a pre-allocated array of compatible type and shape as <code>result</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Signals.jl#L88-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.partial-Union{Tuple{R}, Tuple{P}, Tuple{Int64, CtrlVQE.Signals.AbstractSignal{P, R}, Real}} where {P, R}" href="#CtrlVQE.Signals.partial-Union{Tuple{R}, Tuple{P}, Tuple{Int64, CtrlVQE.Signals.AbstractSignal{P, R}, Real}} where {P, R}"><code>CtrlVQE.Signals.partial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partial(i::Int, signal::AbstractSignal{P,R}, t::Real)</code></pre><p>The partial derivative <span>$∂Ω/∂x_i|_t$</span>. Returns a number of type <code>R</code>.</p><p>Here <span>$x_i$</span> is the signal&#39;s i-th variational parameter     (ie. <code>Parameters.names(signal)[i]</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/Signals.jl#L74-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.ParametricSignals.ConstrainedSignal" href="#CtrlVQE.Signals.ParametricSignals.ConstrainedSignal"><code>CtrlVQE.Signals.ParametricSignals.ConstrainedSignal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstrainedSignal(constrained::&lt;:ParametricSignal, constraints::Vector{Symbol})</code></pre><p>The parametric signal <code>constrained</code>, freezing all fields in <code>constraints</code>.</p><p>Frozen parameters are omitted from the <code>Parameters</code> interface. In other words, they do not appear in <code>Parameters.names</code> or <code>Parameters.values</code>,     and they are not mutated by <code>Parameters.bind</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/signals/ParametricSignals.jl#L97-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.ParametricSignals.ConstrainedSignal-Tuple{CtrlVQE.Signals.ParametricSignals.ParametricSignal, Vararg{Symbol}}" href="#CtrlVQE.Signals.ParametricSignals.ConstrainedSignal-Tuple{CtrlVQE.Signals.ParametricSignals.ParametricSignal, Vararg{Symbol}}"><code>CtrlVQE.Signals.ParametricSignals.ConstrainedSignal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ConstrainedSignal(constrained::ParametricSignal, constraints::Symbol...)</code></pre><p>Alternate constructor, letting each field be passed as its own argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/signals/ParametricSignals.jl#L122-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.ParametricSignals.ParametricSignal" href="#CtrlVQE.Signals.ParametricSignals.ParametricSignal"><code>CtrlVQE.Signals.ParametricSignals.ParametricSignal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParametricSignal{P,R} ... end</code></pre><p>Super-type for user-defined signal objects <span>$Ω(t)$</span>.</p><p><strong>Type Parameters</strong></p><ul><li><code>P</code> denotes the type of all variational parameters. Must be a real float.</li><li><code>R</code> denotes the type of <span>$Ω(t)$</span> itself. May be any number type.</li></ul><p><strong>Implementation</strong></p><p>Any concrete sub-type <code>S</code> must be a mutable struct,     and all of its variational parameters are of type P. By default, <em>all</em> fields of type P are treated as variational parameters. You may optionally change this by implementing <code>parameters(::S)</code>,     which should return a vector of each variational parameter of <code>S</code>. But before you do that,     consider whether a <code>ConstrainedSignal</code> provides the desired behavior.</p><p>The following methods must be implemented:</p><ul><li><p><code>(Ω::S)(t::Real)</code>:       the actual function <span>$Ω(t)$</span>. Must return a number of type <code>R</code>.</p></li><li><p><code>partial(i::Int, Ω::S, t::Real)</code>:       the partial derivative <span>$∂Ω/∂x_i$</span> evaluated at time <code>t</code>,       where <span>$x_i$</span> is Ω&#39;s i-th variational parameter (ie. <code>Parameters.names(Ω)[i]</code>).       Must return a number of type <code>R</code>.</p></li><li><p><code>Base.string(Ω::S, names::AbstractVector{String})</code>:       a human-readable description of the signal,       inserting each element of <code>names</code> in the place of the corresponding parameter.   For example, a complex constant signal might return a description like &quot;A + i B&quot;,       where <code>A</code> and <code>B</code> are the &quot;names&quot; given by the <code>names</code> argument.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/signals/ParametricSignals.jl#L6-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.ParametricSignals.parameters-Union{Tuple{S}, Tuple{R}, Tuple{P}} where {P, R, S&lt;:CtrlVQE.Signals.ParametricSignals.ParametricSignal{P, R}}" href="#CtrlVQE.Signals.ParametricSignals.parameters-Union{Tuple{S}, Tuple{R}, Tuple{P}} where {P, R, S&lt;:CtrlVQE.Signals.ParametricSignals.ParametricSignal{P, R}}"><code>CtrlVQE.Signals.ParametricSignals.parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameters(::S&lt;:ParametricSignal{P,R})</code></pre><p>A vector of all the variational parameters in a signal of type <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/signals/ParametricSignals.jl#L60-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.ParametricSignals.parameters-Union{Tuple{Type{S}}, Tuple{S}, Tuple{R}, Tuple{P}} where {P, R, S&lt;:CtrlVQE.Signals.ParametricSignals.ParametricSignal{P, R}}" href="#CtrlVQE.Signals.ParametricSignals.parameters-Union{Tuple{Type{S}}, Tuple{S}, Tuple{R}, Tuple{P}} where {P, R, S&lt;:CtrlVQE.Signals.ParametricSignals.ParametricSignal{P, R}}"><code>CtrlVQE.Signals.ParametricSignals.parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameters(::Type{S&lt;:ParametricSignal{P,R}})</code></pre><p>A vector of all the variational parameters in a signal of type <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/signals/ParametricSignals.jl#L50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.WindowedSignals.WindowedSignal" href="#CtrlVQE.Signals.WindowedSignals.WindowedSignal"><code>CtrlVQE.Signals.WindowedSignals.WindowedSignal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WindowedSignal(windows, starttimes)</code></pre><p>A signal which applies a different function for each window.</p><p><strong>Arguments</strong></p><ul><li>windows: a vector of signals</li><li>starttimes: a vector of times transitioning each window</li></ul><p>Both <code>windows</code> and <code>starttimes</code> have the same length;     <code>starttimes[i]</code> indicates when <code>windows[i]</code> begins.</p><p>This signal is undefined for times <code>t &lt; starttimes[1]</code>. Normally, <code>starttimes[1] == 0</code>.</p><p>Note that each window must share the same type parameters <code>P</code> and <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/signals/WindowedSignals.jl#L6-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.WindowedSignals.get_window_from_parameter-Tuple{CtrlVQE.Signals.WindowedSignals.WindowedSignal, Int64}" href="#CtrlVQE.Signals.WindowedSignals.get_window_from_parameter-Tuple{CtrlVQE.Signals.WindowedSignals.WindowedSignal, Int64}"><code>CtrlVQE.Signals.WindowedSignals.get_window_from_parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_window_from_parameter(signal::WindowedSignal, i::Int)</code></pre><p>Identify the window index given a parameter index (by counting parameters in <code>windows</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/signals/WindowedSignals.jl#L67-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.WindowedSignals.get_window_from_time-Tuple{CtrlVQE.Signals.WindowedSignals.WindowedSignal, Real}" href="#CtrlVQE.Signals.WindowedSignals.get_window_from_time-Tuple{CtrlVQE.Signals.WindowedSignals.WindowedSignal, Real}"><code>CtrlVQE.Signals.WindowedSignals.get_window_from_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_window_from_time(signal::WindowedSignal, t::Real)</code></pre><p>Identify the window index given the time (by inspecting <code>starttimes</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/signals/WindowedSignals.jl#L55-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.CompositeSignals.CompositeSignal" href="#CtrlVQE.Signals.CompositeSignals.CompositeSignal"><code>CtrlVQE.Signals.CompositeSignals.CompositeSignal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompositeSignal(components::AbstractVector{&lt;:AbstractSignal{P,R}})</code></pre><p>A signal which is the sum of each sub-signal in <code>components</code>.</p><p>Note that each component must share the same type parameters <code>P</code> and <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/signals/CompositeSignals.jl#L5-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.CompositeSignals.CompositeSignal-Union{Tuple{Vararg{CtrlVQE.Signals.AbstractSignal{P, R}}}, Tuple{R}, Tuple{P}} where {P, R}" href="#CtrlVQE.Signals.CompositeSignals.CompositeSignal-Union{Tuple{Vararg{CtrlVQE.Signals.AbstractSignal{P, R}}}, Tuple{R}, Tuple{P}} where {P, R}"><code>CtrlVQE.Signals.CompositeSignals.CompositeSignal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CompositeSignal(components::AbstractSignal...)</code></pre><p>Alternate constructor, letting each component be passed as its own argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/signals/CompositeSignals.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.ModulatedSignals.ModulatedSignal" href="#CtrlVQE.Signals.ModulatedSignals.ModulatedSignal"><code>CtrlVQE.Signals.ModulatedSignals.ModulatedSignal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ModulatedSignal(components::AbstractVector{&lt;:AbstractSignal{P,R}})</code></pre><p>A signal which is the product of each sub-signal in <code>components</code>.</p><p>Note that each component must share the same type parameters <code>P</code> and <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/signals/ModulatedSignals.jl#L5-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.ModulatedSignals.ModulatedSignal-Union{Tuple{Vararg{CtrlVQE.Signals.AbstractSignal{P, R}}}, Tuple{R}, Tuple{P}} where {P, R}" href="#CtrlVQE.Signals.ModulatedSignals.ModulatedSignal-Union{Tuple{Vararg{CtrlVQE.Signals.AbstractSignal{P, R}}}, Tuple{R}, Tuple{P}} where {P, R}"><code>CtrlVQE.Signals.ModulatedSignals.ModulatedSignal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ModulatedSignal(components::AbstractSignal...)</code></pre><p>Alternate constructor, letting each component be passed as its own argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/signals/ModulatedSignals.jl#L21-L26">source</a></section></article><h2 id="Constant-Signals"><a class="docs-heading-anchor" href="#Constant-Signals">Constant Signals</a><a id="Constant-Signals-1"></a><a class="docs-heading-anchor-permalink" href="#Constant-Signals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.ConstantSignals.ComplexConstant" href="#CtrlVQE.Signals.ConstantSignals.ComplexConstant"><code>CtrlVQE.Signals.ConstantSignals.ComplexConstant</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ComplexConstant(A::F, B::F) where {F&lt;:AbstractFloat}</code></pre><p>The constant complex signal <span>$Ω(t) = A + iB$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/signals/ConstantSignals.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.ConstantSignals.Constant" href="#CtrlVQE.Signals.ConstantSignals.Constant"><code>CtrlVQE.Signals.ConstantSignals.Constant</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Constant(A::F) where {F&lt;:AbstractFloat}</code></pre><p>The constant real signal <span>$Ω(t) = A$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/signals/ConstantSignals.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.ConstantSignals.PolarComplexConstant" href="#CtrlVQE.Signals.ConstantSignals.PolarComplexConstant"><code>CtrlVQE.Signals.ConstantSignals.PolarComplexConstant</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PolarComplexConstant(r::F, ϕ::F) where {F&lt;:AbstractFloat}</code></pre><p>The constant complex signal <span>$Ω(t) = r exp(iϕ)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/signals/ConstantSignals.jl#L48-L53">source</a></section></article><h2 id="Interval-Signals"><a class="docs-heading-anchor" href="#Interval-Signals">Interval Signals</a><a id="Interval-Signals-1"></a><a class="docs-heading-anchor-permalink" href="#Interval-Signals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.IntervalSignals.ComplexInterval" href="#CtrlVQE.Signals.IntervalSignals.ComplexInterval"><code>CtrlVQE.Signals.IntervalSignals.ComplexInterval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ComplexInterval(A::F, B::F, s1::F, s2::F) where {F&lt;:AbstractFloat}</code></pre><p>The piecewise signal <span>$Ω(t) = A + iB$</span>, for times <code>t∈[s1,s2)</code>, and <span>$Ω(t) = 0$</span> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/signals/IntervalSignals.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.IntervalSignals.Interval" href="#CtrlVQE.Signals.IntervalSignals.Interval"><code>CtrlVQE.Signals.IntervalSignals.Interval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Interval(A::F, s1::F, s2::F) where {F&lt;:AbstractFloat}</code></pre><p>The piecewise signal <span>$Ω(t) = A$</span>, for times <code>t∈[s1,s2)</code>, and <span>$Ω(t) = 0$</span> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/signals/IntervalSignals.jl#L4-L9">source</a></section></article><h2 id="Step-Function-Signals"><a class="docs-heading-anchor" href="#Step-Function-Signals">Step Function Signals</a><a id="Step-Function-Signals-1"></a><a class="docs-heading-anchor-permalink" href="#Step-Function-Signals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.StepFunctionSignals.StepFunction" href="#CtrlVQE.Signals.StepFunctionSignals.StepFunction"><code>CtrlVQE.Signals.StepFunctionSignals.StepFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StepFunction(A::F, s::F) where {F&lt;:AbstractFloat}</code></pre><p>The piecewise signal <span>$Ω(t) = A⋅Θ(t-s)$</span>, where <span>$Θ$</span> is the Heaviside step function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/signals/StepFunctionSignals.jl#L4-L9">source</a></section></article><h2 id="Gaussian-Signals"><a class="docs-heading-anchor" href="#Gaussian-Signals">Gaussian Signals</a><a id="Gaussian-Signals-1"></a><a class="docs-heading-anchor-permalink" href="#Gaussian-Signals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CtrlVQE.Signals.GaussianSignals.Gaussian" href="#CtrlVQE.Signals.GaussianSignals.Gaussian"><code>CtrlVQE.Signals.GaussianSignals.Gaussian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Gaussian(A::F, σ::F, s::F) where {F&lt;:AbstractFloat}</code></pre><p>A Gaussian real signal <span>$Ω(t) = A exp( -((t-s)/σ)^2 / 2)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/30f3a3c79b8041384a2aa500c433c63165d49628/src/signals/GaussianSignals.jl#L4-L9">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Parameters/">« Parameters</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 9 June 2023 21:50">Friday 9 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
