var documenterSearchIndex = {"docs":
[{"location":"Parameters/","page":"Parameters","title":"Parameters","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"Parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"Parameters/","page":"Parameters","title":"Parameters","text":"Modules = [CtrlVQE.Parameters]","category":"page"},{"location":"Parameters/#CtrlVQE.Parameters","page":"Parameters","title":"CtrlVQE.Parameters","text":"Parameters\n\nStandardized interface for interacting with variational parameters.\n\nMost commonly implemented by Signals and Devices.\n\n\n\n\n\n","category":"module"},{"location":"Parameters/#CtrlVQE.Parameters.bind","page":"Parameters","title":"CtrlVQE.Parameters.bind","text":"bind(entity, x̄::AbstractVector)\n\nAssigns new values for each variational parameter in entity.\n\nImplementation\n\nThis method should mutate entity such that, for example,     the expression bind(entity, x̄); ȳ = values(entity); x̄ == ȳ evaluates true. There is no return value.\n\n\n\n\n\n","category":"function"},{"location":"Parameters/#CtrlVQE.Parameters.count","page":"Parameters","title":"CtrlVQE.Parameters.count","text":"count(entity)\n\nThe number of variational parameters in entity.\n\nImplementation\n\nMust return a non-negative integer.\n\n\n\n\n\n","category":"function"},{"location":"Parameters/#CtrlVQE.Parameters.names","page":"Parameters","title":"CtrlVQE.Parameters.names","text":"names(entity)\n\nAn ordered list of human-readable names for each variational parameter in entity.\n\nImplementation\n\nMust return a vector of strings.\n\n\n\n\n\n","category":"function"},{"location":"Parameters/#CtrlVQE.Parameters.values","page":"Parameters","title":"CtrlVQE.Parameters.values","text":"values(entity)\n\nAn ordered list of the numerical values for each variational parameter in entity.\n\nImplementation\n\nMust return a vector of some float type.\n\n\n\n\n\n","category":"function"},{"location":"Signals/","page":"Signals","title":"Signals","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"Signals/#Signals","page":"Signals","title":"Signals","text":"","category":"section"},{"location":"Signals/","page":"Signals","title":"Signals","text":"Modules = [\n    CtrlVQE.Signals,\n    CtrlVQE.ParametricSignals,\n    CtrlVQE.WindowedSignals,\n    CtrlVQE.CompositeSignals,\n    CtrlVQE.ModulatedSignals,\n]","category":"page"},{"location":"Signals/#CtrlVQE.Signals","page":"Signals","title":"CtrlVQE.Signals","text":"Signals\n\nTime-dependent functions suitable for control signals with variational parameters.\n\nThe main motivation of this module     is to provide a common interface for analytical gradients and optimization.\n\n\n\n\n\n","category":"module"},{"location":"Signals/#CtrlVQE.Signals.SignalType","page":"Signals","title":"CtrlVQE.Signals.SignalType","text":"SignalType{P,R}\n\nSuper-type for all signal objects Ω(t).\n\nType Parameters\n\nP denotes the type of all variational parameters. Must be a real float.\nR denotes the type of Ω(t) itself. May be any number type.\n\nImplementation\n\nAny concrete sub-type S must implement all functions in the Parameters module.\n\nIn particular, Parameters.values(Ω::S) must return a vector of type P.\nIf you are trying to create your own signal type,   you probably want to implement a ParametricSignal,   which already has an implementation for the Parameters interface.\n\nIn addition, the following methods must be implemented:\n\nvalueat(Ω::S, t::Real):       the actual function Ω(t). Must return a number of type R.\npartial(i::Int, Ω::S, t::Real):       the partial derivative Ωx_i evaluated at time t,       where x_i is Ω's i-th variational parameter (ie. Parameters.names(Ω)[i]).       Must return a number of type R.\nBase.string(Ω::S, names::AbstractVector{String}):       a human-readable description of the signal,       inserting each element of names in the place of the corresponding parameter.   For example, a complex constant signal might return a description like \"A + i B\",       where A and B are the \"names\" given by the names argument.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#CtrlVQE.Signals.SignalType-Tuple{Any}","page":"Signals","title":"CtrlVQE.Signals.SignalType","text":"(signal::SignalType{P,R})(t::Real)\n\nSyntactic sugar: if Ω is a SignalType, then Ω(t) gives valueat(Ω,t).\n\n\n\n\n\n","category":"method"},{"location":"Signals/#Base.string-Tuple{CtrlVQE.Signals.SignalType, AbstractVector{String}}","page":"Signals","title":"Base.string","text":"Base.string(Ω::SignalType, names::AbstractVector{String})\n\nSubstitutes the default name of each variational parameter for the ones in names.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#Base.string-Tuple{CtrlVQE.Signals.SignalType}","page":"Signals","title":"Base.string","text":"Base.string(Ω::SignalType)\n\nA human-readable description of the signal. Returns type string.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.Signals.partial-Union{Tuple{R}, Tuple{P}, Tuple{Int64, CtrlVQE.Signals.SignalType{P, R}, AbstractVector{<:Real}}} where {P, R}","page":"Signals","title":"CtrlVQE.Signals.partial","text":"partial(\n    i::Int, signal::SignalType{P,R}, t̄::AbstractVector{<:Real};\n    result=nothing,\n)\n\nVectorized version. Returns a vector of type R.\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.Signals.partial-Union{Tuple{R}, Tuple{P}, Tuple{Int64, CtrlVQE.Signals.SignalType{P, R}, Real}} where {P, R}","page":"Signals","title":"CtrlVQE.Signals.partial","text":"partial(i::Int, signal::SignalType{P,R}, t::Real)\n\nThe partial derivative Ωx_i_t. Returns a number of type R.\n\nHere x_i is the signal's i-th variational parameter     (ie. Parameters.names(signal)[i]).\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.Signals.valueat-Union{Tuple{R}, Tuple{P}, Tuple{CtrlVQE.Signals.SignalType{P, R}, AbstractVector{<:Real}}} where {P, R}","page":"Signals","title":"CtrlVQE.Signals.valueat","text":"valueat(signal::SignalType{P,R}, t̄::AbstractVector{<:Real}; result=nothing)\n\nVectorized version. Returns a vector of type R.\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.Signals.valueat-Union{Tuple{R}, Tuple{P}, Tuple{CtrlVQE.Signals.SignalType{P, R}, Real}} where {P, R}","page":"Signals","title":"CtrlVQE.Signals.valueat","text":"valueat(signal::SignalType{P,R}, t::Real)\n\nThe signal at time t, ie. Ω(t). Returns a number of type R.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.ParametricSignals.ConstrainedSignal","page":"Signals","title":"CtrlVQE.ParametricSignals.ConstrainedSignal","text":"ConstrainedSignal(constrained::<:ParametricSignal, constraints::Vector{Symbol})\n\nThe parametric signal constrained, freezing all fields in constraints.\n\nFrozen parameters are omitted from the Parameters interface. In other words, they do not appear in Parameters.names or Parameters.values,     and they are not mutated by Parameters.bind.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#CtrlVQE.ParametricSignals.ConstrainedSignal-Tuple{CtrlVQE.ParametricSignals.ParametricSignal, Vararg{Symbol}}","page":"Signals","title":"CtrlVQE.ParametricSignals.ConstrainedSignal","text":"ConstrainedSignal(constrained::ParametricSignal, constraints::Symbol...)\n\nAlternate constructor, letting each field be passed as its own argument.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.ParametricSignals.ParametricSignal","page":"Signals","title":"CtrlVQE.ParametricSignals.ParametricSignal","text":"ParametricSignal{P,R} ... end\n\nSuper-type for user-defined signal objects Ω(t).\n\nType Parameters\n\nP denotes the type of all variational parameters. Must be a real float.\nR denotes the type of Ω(t) itself. May be any number type.\n\nImplementation\n\nAny concrete sub-type S must be a mutable struct,     and all of its variational parameters are of type P. By default, all fields of type P are treated as variational parameters. You may optionally change this by implementing parameters(::S),     which should return a vector of each variational parameter of S. But before you do that,     consider whether a ConstrainedSignal provides the desired behavior.\n\nThe following methods must be implemented:\n\nSignals.valueat(Ω::S, t::Real):       the actual function Ω(t). Must return a number of type R.\nSignals.partial(i::Int, Ω::S, t::Real):       the partial derivative Ωx_i evaluated at time t,       where x_i is Ω's i-th variational parameter (ie. Parameters.names(Ω)[i]).       Must return a number of type R.\nBase.string(Ω::S, names::AbstractVector{String}):       a human-readable description of the signal,       inserting each element of names in the place of the corresponding parameter.   For example, a complex constant signal might return a description like \"A + i B\",       where A and B are the \"names\" given by the names argument.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#CtrlVQE.ParametricSignals.parameters-Union{Tuple{S}, Tuple{R}, Tuple{P}} where {P, R, S<:CtrlVQE.ParametricSignals.ParametricSignal{P, R}}","page":"Signals","title":"CtrlVQE.ParametricSignals.parameters","text":"parameters(::S<:ParametricSignal{P,R})\n\nA vector of all the variational parameters in a signal of type S.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.ParametricSignals.parameters-Union{Tuple{Type{S}}, Tuple{S}, Tuple{R}, Tuple{P}} where {P, R, S<:CtrlVQE.ParametricSignals.ParametricSignal{P, R}}","page":"Signals","title":"CtrlVQE.ParametricSignals.parameters","text":"parameters(::Type{S<:ParametricSignal{P,R}})\n\nA vector of all the variational parameters in a signal of type S.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.WindowedSignals.WindowedSignal","page":"Signals","title":"CtrlVQE.WindowedSignals.WindowedSignal","text":"WindowedSignal(windows, starttimes)\n\nA signal which applies a different function for each window.\n\nArguments\n\nwindows: a vector of signals\nstarttimes: a vector of times transitioning each window\n\nBoth windows and starttimes have the same length;     starttimes[i] indicates when windows[i] begins.\n\nThis signal is undefined for times t < starttimes[1]. Normally, starttimes[1] == 0.\n\nNote that each window must share the same type parameters P and R.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#CtrlVQE.WindowedSignals.get_window_from_parameter-Tuple{CtrlVQE.WindowedSignals.WindowedSignal, Int64}","page":"Signals","title":"CtrlVQE.WindowedSignals.get_window_from_parameter","text":"get_window_from_parameter(signal::WindowedSignal, i::Int)\n\nIdentify the window index given a parameter index (by counting parameters in windows).\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.WindowedSignals.get_window_from_time-Tuple{CtrlVQE.WindowedSignals.WindowedSignal, Real}","page":"Signals","title":"CtrlVQE.WindowedSignals.get_window_from_time","text":"get_window_from_time(signal::WindowedSignal, t::Real)\n\nIdentify the window index given the time (by inspecting starttimes).\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.CompositeSignals.CompositeSignal","page":"Signals","title":"CtrlVQE.CompositeSignals.CompositeSignal","text":"CompositeSignal(components::AbstractVector{<:SignalType{P,R}})\n\nA signal which is the sum of each sub-signal in components.\n\nNote that each component must share the same type parameters P and R.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#CtrlVQE.CompositeSignals.CompositeSignal-Union{Tuple{Vararg{CtrlVQE.Signals.SignalType{P, R}}}, Tuple{R}, Tuple{P}} where {P, R}","page":"Signals","title":"CtrlVQE.CompositeSignals.CompositeSignal","text":"CompositeSignal(components::SignalType...)\n\nAlternate constructor, letting each component be passed as its own argument.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.ModulatedSignals.ModulatedSignal","page":"Signals","title":"CtrlVQE.ModulatedSignals.ModulatedSignal","text":"ModulatedSignal(components::AbstractVector{<:SignalType{P,R}})\n\nA signal which is the product of each sub-signal in components.\n\nNote that each component must share the same type parameters P and R.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#CtrlVQE.ModulatedSignals.ModulatedSignal-Union{Tuple{Vararg{CtrlVQE.Signals.SignalType{P, R}}}, Tuple{R}, Tuple{P}} where {P, R}","page":"Signals","title":"CtrlVQE.ModulatedSignals.ModulatedSignal","text":"ModulatedSignal(components::SignalType...)\n\nAlternate constructor, letting each component be passed as its own argument.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#Constant-Signals","page":"Signals","title":"Constant Signals","text":"","category":"section"},{"location":"Signals/","page":"Signals","title":"Signals","text":"Modules = [CtrlVQE.ConstantSignals]","category":"page"},{"location":"Signals/#CtrlVQE.ConstantSignals.ComplexConstant","page":"Signals","title":"CtrlVQE.ConstantSignals.ComplexConstant","text":"ComplexConstant(A::F, B::F) where {F<:AbstractFloat}\n\nThe constant complex signal Ω(t) = A + iB.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#CtrlVQE.ConstantSignals.Constant","page":"Signals","title":"CtrlVQE.ConstantSignals.Constant","text":"Constant(A::F) where {F<:AbstractFloat}\n\nThe constant real signal Ω(t) = A.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#CtrlVQE.ConstantSignals.PolarComplexConstant","page":"Signals","title":"CtrlVQE.ConstantSignals.PolarComplexConstant","text":"PolarComplexConstant(r::F, ϕ::F) where {F<:AbstractFloat}\n\nThe constant complex signal Ω(t) = r exp(iϕ).\n\n\n\n\n\n","category":"type"},{"location":"Signals/#Interval-Signals","page":"Signals","title":"Interval Signals","text":"","category":"section"},{"location":"Signals/","page":"Signals","title":"Signals","text":"Modules = [CtrlVQE.IntervalSignals]","category":"page"},{"location":"Signals/#CtrlVQE.IntervalSignals.ComplexInterval","page":"Signals","title":"CtrlVQE.IntervalSignals.ComplexInterval","text":"ComplexInterval(A::F, B::F, s1::F, s2::F) where {F<:AbstractFloat}\n\nThe piecewise signal Ω(t) = A + iB, for times t∈[s1,s2), and Ω(t) = 0 otherwise.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#CtrlVQE.IntervalSignals.Interval","page":"Signals","title":"CtrlVQE.IntervalSignals.Interval","text":"Interval(A::F, s1::F, s2::F) where {F<:AbstractFloat}\n\nThe piecewise signal Ω(t) = A, for times t∈[s1,s2), and Ω(t) = 0 otherwise.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#Step-Function-Signals","page":"Signals","title":"Step Function Signals","text":"","category":"section"},{"location":"Signals/","page":"Signals","title":"Signals","text":"Modules = [CtrlVQE.StepFunctionSignals]","category":"page"},{"location":"Signals/#CtrlVQE.StepFunctionSignals.StepFunction","page":"Signals","title":"CtrlVQE.StepFunctionSignals.StepFunction","text":"StepFunction(A::F, s::F) where {F<:AbstractFloat}\n\nThe piecewise signal Ω(t) = AΘ(t-s), where Θ is the Heaviside step function.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#Gaussian-Signals","page":"Signals","title":"Gaussian Signals","text":"","category":"section"},{"location":"Signals/","page":"Signals","title":"Signals","text":"Modules = [CtrlVQE.GaussianSignals]","category":"page"},{"location":"Signals/#CtrlVQE.GaussianSignals.Gaussian","page":"Signals","title":"CtrlVQE.GaussianSignals.Gaussian","text":"Gaussian(A::F, σ::F, s::F) where {F<:AbstractFloat}\n\nA Gaussian real signal Ω(t) = A exp( -((t-s)σ)^2  2).\n\n\n\n\n\n","category":"type"},{"location":"Bases/","page":"Bases","title":"Bases","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"Bases/#Bases","page":"Bases","title":"Bases","text":"","category":"section"},{"location":"Bases/","page":"Bases","title":"Bases","text":"Modules = [CtrlVQE.Bases]","category":"page"},{"location":"Bases/#CtrlVQE.Bases","page":"Bases","title":"CtrlVQE.Bases","text":"Bases\n\nEnumerates various linear-algebraic bases for representing statevectors and matrices.\n\n\n\n\n\n","category":"module"},{"location":"Bases/#CtrlVQE.Bases.Coordinate","page":"Bases","title":"CtrlVQE.Bases.Coordinate","text":"Coordinate(), aka COORDINATE\n\nThe eigenbasis of local quadrature operators Q  (a + a)2.\n\n\n\n\n\n","category":"type"},{"location":"Bases/#CtrlVQE.Bases.Dressed","page":"Bases","title":"CtrlVQE.Bases.Dressed","text":"Dressed(), aka DRESSED\n\nThe eigenbasis of the static Hamiltonian associated with a Device. Eigenvectors are ordered to maximize similarity with an identity matrix. Phases are fixed so that the diagonal is real.\n\n\n\n\n\n","category":"type"},{"location":"Bases/#CtrlVQE.Bases.Momentum","page":"Bases","title":"CtrlVQE.Bases.Momentum","text":"Momentum(), aka MOMENTUM\n\nThe eigenbasis of local quadrature operators P  i(a - a)2.\n\n\n\n\n\n","category":"type"},{"location":"Bases/#CtrlVQE.Bases.Occupation","page":"Bases","title":"CtrlVQE.Bases.Occupation","text":"Occupation(), aka OCCUPATION\n\nThe eigenbasis of local number operators n  aa. Generally equivalent to what is called the \"Z basis\", or the \"computational basis\".\n\n\n\n\n\n","category":"type"},{"location":"Integrations/","page":"Integrations","title":"Integrations","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"Integrations/#Integrations","page":"Integrations","title":"Integrations","text":"","category":"section"},{"location":"Integrations/","page":"Integrations","title":"Integrations","text":"Modules = [CtrlVQE.Integrations]","category":"page"},{"location":"Integrations/#CtrlVQE.Integrations","page":"Integrations","title":"CtrlVQE.Integrations","text":"Integrations\n\nEncapsulations of everything you need to know to integrate over time.\n\n\n\n\n\n","category":"module"},{"location":"Integrations/#CtrlVQE.Integrations.IntegrationType","page":"Integrations","title":"CtrlVQE.Integrations.IntegrationType","text":"IntegrationType{F}\n\nSuper-type for all time grids, which encapsulate everything needed to integrate over time.\n\nType Parameters\n\nF denotes the type for time values. Must be a real float.\n\nImplementation\n\nAny concrete sub-type G must implement the following methods:\n\nnsteps(::G): the total number of finite jumps within this time grid.\nThis is the maximum index of the timeat and stepat functions,       but it is NOT the length of the lattice, since the minimum index is 0.\ntimeat(::G, i::Int): time at index i (which may be zero)\nstepat(::G, i::Int): stepsize at index i (which may be zero)\nLet r be the number of steps, T be the duration,       and τ_i the step at index i.   Then _i=0^r τ_i = T.\nBase.reverse(::G): a new integration, identical except bounds are reversed\n\n\n\n\n\n","category":"type"},{"location":"Integrations/#Base.reverse-Tuple{CtrlVQE.Integrations.IntegrationType}","page":"Integrations","title":"Base.reverse","text":"Base.reverse(grid::IntegrationType)\n\nConstruct a new integration, identical except bounds are reversed.\n\n\n\n\n\n","category":"method"},{"location":"Integrations/#CtrlVQE.Integrations.duration-Tuple{CtrlVQE.Integrations.IntegrationType}","page":"Integrations","title":"CtrlVQE.Integrations.duration","text":"duration(grid::IntegrationType)\n\nThe total duration, ie. the last time point minus the first.\n\n\n\n\n\n","category":"method"},{"location":"Integrations/#CtrlVQE.Integrations.endtime-Tuple{CtrlVQE.Integrations.IntegrationType}","page":"Integrations","title":"CtrlVQE.Integrations.endtime","text":"endtime(grid::IntegrationType)\n\nUpper bound of time integral.\n\n\n\n\n\n","category":"method"},{"location":"Integrations/#CtrlVQE.Integrations.integrate","page":"Integrations","title":"CtrlVQE.Integrations.integrate","text":"integrate(grid::IntegrationType{F}, Φ)\n\nCompute the integral _0^T Φ(t)dt. Φ is a univariate scalar function of time, returning type F.\n\nintegrate(grid::IntegrationType, f̄::AbstractVector)\n\nTreat the elements of f̄ as the function evaluations Φ(t) above. The length of f̄ must be nsteps(grid) + 1 and its eltype must be real.\n\nintegrate(grid::IntegrationType, Φ, f̄s::AbstractVector...)\n\nCompute the integral _0^T Φ(t f1 f2)dt,     where f1 is the value of f̄s[1] at the index corresponding to time t, etc. Φ is a multivariate scalar function,     of time and one argument for each f̄, returning type F. The length of each element in f̄s must be nsteps(grid) + 1.\n\n\n\n\n\n","category":"function"},{"location":"Integrations/#CtrlVQE.Integrations.lattice-Tuple{CtrlVQE.Integrations.IntegrationType}","page":"Integrations","title":"CtrlVQE.Integrations.lattice","text":"lattice(grid::IntegrationType)\n\nA vector of time points.\n\nThis is a regular vector, meaning it indexes from 1. This is offset by one from the timeat and stepat functions!\n\nNOTE: This function is memoized, so DO NOT mutate its return value!\n\n\n\n\n\n","category":"method"},{"location":"Integrations/#CtrlVQE.Integrations.nsteps-Tuple{CtrlVQE.Integrations.IntegrationType}","page":"Integrations","title":"CtrlVQE.Integrations.nsteps","text":"nsteps(grid::IntegrationType)\n\nThe total number of finite jumps within this time grid.\n\nThis is the maximum index of the timeat and stepat functions,     but it is NOT the length of the lattice, since the minimum index is 0.\n\n\n\n\n\n","category":"method"},{"location":"Integrations/#CtrlVQE.Integrations.starttime-Tuple{CtrlVQE.Integrations.IntegrationType}","page":"Integrations","title":"CtrlVQE.Integrations.starttime","text":"starttime(grid::IntegrationType)\n\nLower bound of time integral.\n\n\n\n\n\n","category":"method"},{"location":"Integrations/#CtrlVQE.Integrations.stepat-Union{Tuple{F}, Tuple{CtrlVQE.Integrations.IntegrationType{F}, Int64}} where F","page":"Integrations","title":"CtrlVQE.Integrations.stepat","text":"stepat(grid::IntegrationType, i::Int)\n\nThe stepsize at index i (which may be zero).\n\nLet r be the number of steps, T be the duration,     and τ_i the step at index i. Then _i=0^r τ_i = T.\n\n\n\n\n\n","category":"method"},{"location":"Integrations/#CtrlVQE.Integrations.stepsize-Tuple{CtrlVQE.Integrations.IntegrationType}","page":"Integrations","title":"CtrlVQE.Integrations.stepsize","text":"stepsize(grid::IntegrationType)\n\nThe average step size, ie. duration divided by number of steps.\n\n\n\n\n\n","category":"method"},{"location":"Integrations/#CtrlVQE.Integrations.timeat-Union{Tuple{F}, Tuple{CtrlVQE.Integrations.IntegrationType{F}, Int64}} where F","page":"Integrations","title":"CtrlVQE.Integrations.timeat","text":"timeat(grid::IntegrationType, i::Int)\n\nThe time at index i (which may be zero).\n\n\n\n\n\n","category":"method"},{"location":"Integrations/#First-Order-Integrations","page":"Integrations","title":"First-Order Integrations","text":"","category":"section"},{"location":"Integrations/","page":"Integrations","title":"Integrations","text":"Modules = [\n    CtrlVQE.TrapezoidalIntegrations,\n]","category":"page"},{"location":"Integrations/#CtrlVQE.TrapezoidalIntegrations.TrapezoidalIntegration","page":"Integrations","title":"CtrlVQE.TrapezoidalIntegrations.TrapezoidalIntegration","text":"TrapezoidalIntegration(t0::F, tf::F, r::Int)\n\nFirst-order grid using a trapezoidal rule time integration.\n\nArguments\n\nt0, tf: lower and upper bounds of the integral\nr: the number of time steps (remember number of lattice points is r+1)\n\nExplanation\n\nThis grid gives a first-order quadrature,     meaning every step takes you forward in time.\n\nAdditionally, this grid uses uniform spacing. You'd think that would mean stepat(grid, i) would give τ_i = τ for every i,     where τ  T  r and T  tf - t0. But careful! The sum of all τ_i must match the length of the integral, ie. T. But there are r+1 points, and (r+1)⋅τ > T. How do we reconcile this? A \"Left Hand Sum\" would omit t=T from the time points;     a \"Right Hand Sum\" would omit t=0. The trapezoidal rule omits half a point from each.\n\nThat sounds awfully strange, but it's mathematically sound! We only integrate through half of each boundary time point t=0 and t=T. Thus, those points, and only those points, have a spacing of τ/2.\n\n\n\n\n\n","category":"type"},{"location":"CostFunctions/","page":"Cost Functions","title":"Cost Functions","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"CostFunctions/#Cost-Functions","page":"Cost Functions","title":"Cost Functions","text":"","category":"section"},{"location":"CostFunctions/","page":"Cost Functions","title":"Cost Functions","text":"Modules = [CtrlVQE.CostFunctions]","category":"page"},{"location":"CostFunctions/#CtrlVQE.CostFunctions","page":"Cost Functions","title":"CtrlVQE.CostFunctions","text":"CostFunctions\n\nInterfaces time-evolution and penalty functions to interface directly with optimization.\n\nEach distinct cost function is implemented in a sub-module,     alongside its gradient function. The sub-module implements a functions method which constructs a cost function     and its corresponding gradient function. Thus, all you need to run a gradient based optimization is:\n\nimport CostFunctions.MySubModule: functions\nf, g = functions(args...)\n\n\n\n\n\n","category":"module"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.CompositeCostFunction","page":"Cost Functions","title":"CtrlVQE.CostFunctions.CompositeCostFunction","text":"CompositeCostFunction(components::AbstractVector{CostFunctionType})\n\nThe sum of several cost-functions.\n\nUse this eg. to combine an energy function with one or more penalty functions.\n\nNote that all components must have matching eltype and length.\n\nAs a practical convenience, this struct maintains some dynamic attributes     so that results for each component function can be inspected     in the middle of an optimization. I don't really consider them an official part of the interface,     but feel free to use them. Although...they aren't technically \"thread-safe\". ^_^\n\n\n\n\n\n","category":"type"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.CompositeCostFunction-Union{Tuple{Vararg{CtrlVQE.CostFunctions.CostFunctionType{F}}}, Tuple{F}} where F","page":"Cost Functions","title":"CtrlVQE.CostFunctions.CompositeCostFunction","text":"CompositeCostFunction(f̄::CostFunctionType{F}...)\n\nAlternate constructor, letting each function be passed as its own argument.\n\n\n\n\n\n","category":"method"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.CostFunctionType","page":"Cost Functions","title":"CtrlVQE.CostFunctions.CostFunctionType","text":"CostFunctionType{F}\n\nSuper-type for \"cost functions\", to be plugged directly into optimization algorithms.\n\nImplementation\n\nAny concrete sub-type CF must implement the following methods:\n\nBase.length(::CF):       the number of parameters this cost function takes\ncost_function(::CF):       returns a Function which takes a parameter vector           and returns the output of the cost function       ie. a callable expression (x::Vector) -> f(x)\ngrad_function_inplace(::CF):       returns a mutating Function which takes a gradient vector (to be mutated)           and a parameter vector, and writes the gradient vector to the first argument.       As a matter of habit, the resulting gradient vector should also be returned.\n\nIf your cost function involves calculating the expectation value of a time-evolved state,     you should implement an EnergyFunction (even if it isn't strictly an energy). This type has a couple extra requirements to allow energy trajectories over the evolution.\n\n\n\n\n\n","category":"type"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.CostFunctionType-Tuple{AbstractVector}","page":"Cost Functions","title":"CtrlVQE.CostFunctions.CostFunctionType","text":"(fn::CostFunctionType)(x̄::AbstractVector)\n\nEvaluate the value of fn at the point x̄.\n\nThis is syntactic sugar for constructing a dedicated cost_function and calling it. It will not normally take advantage of cached work variables,     so avoid using it in high-performance code.\n\n\n\n\n\n","category":"method"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.EnergyFunction","page":"Cost Functions","title":"CtrlVQE.CostFunctions.EnergyFunction","text":"EnergyFunction{F}\n\nSuper-type for cost functions calculating the expectation value of a time-evolved state.\n\nImplementation\n\nAny concrete sub-type CF must implement     everything required in the CostFunctionType interface,     so consult the documentation for CostFunctionType carefully.\n\nIn additon, the following method must be implemented:\n\ntrajectory_callback(::CF, E::AbstractVector; callback=nothing)       returns a Function compatible with Evolutions.evolve callback           ie. a callable expression (i::Int, t::Real, ψ::Vector) -> Nothing       which sets E[i] to the energy of a partially evolved wavefunction ψ.       If callback is provided, the function calls that callback afterwards.\n\nFinally, the following methods must now accept a keyword argument:\n\ncost_function(::CF; callback=nothing):       When callback is provided, the time evolution must call it at each timestep.\ngrad_function_inplace(::CF; ϕ=nothing):       When ϕ is provided, write the gradient signals to it.\n\n\n\n\n\n","category":"type"},{"location":"CostFunctions/#Base.eltype-Union{Tuple{CtrlVQE.CostFunctions.CostFunctionType{F}}, Tuple{F}} where F","page":"Cost Functions","title":"Base.eltype","text":"Base.eltype(fn::CostFunctionType)\n\nGives the number type for parameters of this cost function.\n\n\n\n\n\n","category":"method"},{"location":"CostFunctions/#Base.length-Tuple{CtrlVQE.CostFunctions.CostFunctionType}","page":"Cost Functions","title":"Base.length","text":"Base.length(fn::CostFunctionType)\n\nGives the number of parameters for this cost function.\n\n\n\n\n\n","category":"method"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.cost_function-Union{Tuple{CtrlVQE.CostFunctions.CostFunctionType{F}}, Tuple{F}} where F","page":"Cost Functions","title":"CtrlVQE.CostFunctions.cost_function","text":"cost_function(fn::CostFunctionType)\n\nConverts the struct fn into a literal Function of a parameter vector.\n\nThe function accepts a parameter vector x̄     which should have the type and length given by eltype(fn) and length(fn). The function returns the value of fn at the point x̄.\n\n\n\n\n\n","category":"method"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.cost_function-Union{Tuple{CtrlVQE.CostFunctions.EnergyFunction{F}}, Tuple{F}} where F","page":"Cost Functions","title":"CtrlVQE.CostFunctions.cost_function","text":"cost_function(fn::CostFunctionType; callback=nothing)\n\nSame as for CostFunctionType except that whenever the function is called,     the time evolution calls callback (if provided) in each time step.\n\n\n\n\n\n","category":"method"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.grad_function-Union{Tuple{CtrlVQE.CostFunctions.CostFunctionType{F}}, Tuple{F}} where F","page":"Cost Functions","title":"CtrlVQE.CostFunctions.grad_function","text":"grad_function(fn::CostFunctionType)\n\nConstructs a Function to calculate the gradient of fn at a particular point.\n\nThe function accepts a parameter vector x̄     which should have the type and length given by eltype(fn) and length(fn). The function returns the gradient (a vector) of fn at the point x̄.\n\n\n\n\n\n","category":"method"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.grad_function_inplace-Union{Tuple{CtrlVQE.CostFunctions.CostFunctionType{F}}, Tuple{F}} where F","page":"Cost Functions","title":"CtrlVQE.CostFunctions.grad_function_inplace","text":"grad_function_inplace(fn::CostFunctionType)\n\nConstructs a (mutating) Function to calculate the gradient of fn at a particular point.\n\nThe function accepts a gradient vector ∇f̄ (to be mutated) and a parameter vector x̄. Both should have the type and length given by eltype(fn) and length(fn). After the function is called, ∇f̄ contains the gradient of fn at the point x̄.\n\n\n\n\n\n","category":"method"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.grad_function_inplace-Union{Tuple{CtrlVQE.CostFunctions.EnergyFunction{F}}, Tuple{F}} where F","page":"Cost Functions","title":"CtrlVQE.CostFunctions.grad_function_inplace","text":"grad_function_inplace(fn::CostFunctionType; ϕ=nothing)\n\nSame as for CostFunctionType except that whenever the function is called,     ϕ (if provided) is updated to contain the gradient signals.\n\n\n\n\n\n","category":"method"},{"location":"CostFunctions/#Energy-Functions","page":"Cost Functions","title":"Energy Functions","text":"","category":"section"},{"location":"CostFunctions/","page":"Cost Functions","title":"Cost Functions","text":"Modules = [\n    CtrlVQE.BareEnergies,\n    CtrlVQE.ProjectedEnergies,\n    CtrlVQE.NormalizedEnergies,\n    CtrlVQE.Normalizations,\n]","category":"page"},{"location":"CostFunctions/#CtrlVQE.BareEnergies.BareEnergy","page":"Cost Functions","title":"CtrlVQE.BareEnergies.BareEnergy","text":"BareEnergy(evolution, device, basis, frame, grid, ψ0, O0; kwargs...)\n\nExpectation value of a Hermitian observable.\n\nThis type is called \"bare\" because it does not perform any projection steps     (except perhaps what is hard-coded into the structure of the observable O0).\n\nArguments\n\nevolution::Evolutions.EvolutionType: the algorithm with which to evolve ψ0       A sensible choice is ToggleEvolutions.TOGGLE\ndevice::Devices.DeviceType: the device, which determines the time-evolution of ψ0\nbasis::Bases.BasisType: the measurement basis       ALSO determines the basis which ψ0 and O0 are understood to be given in.       An intuitive choice is Bases.OCCUPATION, aka. the qubits' Z basis.       That said, there is some doubt whether, experimentally,           projective measurement doesn't actually project on the device's eigenbasis,           aka Bases.DRESSED.       Note that you probably want to rotate ψ0 and O0 if you change this argument.\nframe::Operators.StaticOperator: the measurement frame       Think of this as a time-dependent basis rotation, which is applied to O0.       A sensible choice is Operators.STATIC for the \"drive frame\",           which ensures a zero pulse (no drive) system retains the same energy for any T.       Alternatively, use Operators.UNCOUPLED for the interaction frame,           a (presumably) classically tractable approximation to the drive frame,           or Operators.IDENTITY to omit the time-dependent rotation entirely.\ngrid::TrapezoidalIntegration: defines the time integration bounds (eg. from 0 to T)\nψ0: the reference state, living in the physical Hilbert space of device.\nO0: a Hermitian matrix, living in the physical Hilbert space of device.\n\n\n\n\n\n","category":"type"},{"location":"CostFunctions/#CtrlVQE.ProjectedEnergies.ProjectedEnergy","page":"Cost Functions","title":"CtrlVQE.ProjectedEnergies.ProjectedEnergy","text":"ProjectedEnergy(evolution, device, basis, frame, grid, ψ0, O0; kwargs...)\n\nExpectation value of a Hermitian observable.\n\nThe statevector is projected onto a binary logical space after time evolution,     modeling an ideal quantum measurement where leakage is fully characterized.\n\nArguments\n\nevolution::Evolutions.EvolutionType: the algorithm with which to evolve ψ0       A sensible choice is ToggleEvolutions.TOGGLE\ndevice::Devices.DeviceType: the device, which determines the time-evolution of ψ0\nbasis::Bases.BasisType: the measurement basis       ALSO determines the basis which ψ0 and O0 are understood to be given in.       An intuitive choice is Bases.OCCUPATION, aka. the qubits' Z basis.       That said, there is some doubt whether, experimentally,           projective measurement doesn't actually project on the device's eigenbasis,           aka Bases.DRESSED.       Note that you probably want to rotate ψ0 and O0 if you change this argument.\nframe::Operators.StaticOperator: the measurement frame       Think of this as a time-dependent basis rotation, which is applied to O0.       A sensible choice is Operators.STATIC for the \"drive frame\",           which ensures a zero pulse (no drive) system retains the same energy for any T.       Alternatively, use Operators.UNCOUPLED for the interaction frame,           a (presumably) classically tractable approximation to the drive frame,           or Operators.IDENTITY to omit the time-dependent rotation entirely.\ngrid::TrapezoidalIntegration: defines the time integration bounds (eg. from 0 to T)\nψ0: the reference state, living in the physical Hilbert space of device.\nO0: a Hermitian matrix, living in the physical Hilbert space of device.\n\n\n\n\n\n","category":"type"},{"location":"CostFunctions/#CtrlVQE.NormalizedEnergies.NormalizedEnergy","page":"Cost Functions","title":"CtrlVQE.NormalizedEnergies.NormalizedEnergy","text":"NormalizedEnergy(evolution, device, basis, frame, grid, ψ0, O0; kwargs...)\n\nExpectation value of a Hermitian observable.\n\nThe statevector is projected onto a binary logical space after time evolution,     and then renormalized,     modeling quantum measurement where leakage is completely obscured.\n\nArguments\n\nevolution::Evolutions.EvolutionType: the algorithm with which to evolve ψ0       A sensible choice is ToggleEvolutions.TOGGLE\ndevice::Devices.DeviceType: the device, which determines the time-evolution of ψ0\nbasis::Bases.BasisType: the measurement basis       ALSO determines the basis which ψ0 and O0 are understood to be given in.       An intuitive choice is Bases.OCCUPATION, aka. the qubits' Z basis.       That said, there is some doubt whether, experimentally,           projective measurement doesn't actually project on the device's eigenbasis,           aka Bases.DRESSED.       Note that you probably want to rotate ψ0 and O0 if you change this argument.\nframe::Operators.StaticOperator: the measurement frame       Think of this as a time-dependent basis rotation, which is applied to O0.       A sensible choice is Operators.STATIC for the \"drive frame\",           which ensures a zero pulse (no drive) system retains the same energy for any T.       Alternatively, use Operators.UNCOUPLED for the interaction frame,           a (presumably) classically tractable approximation to the drive frame,           or Operators.IDENTITY to omit the time-dependent rotation entirely.\ngrid::TrapezoidalIntegration: defines the time integration bounds (eg. from 0 to T)\nψ0: the reference state, living in the physical Hilbert space of device.\nO0: a Hermitian matrix, living in the physical Hilbert space of device.\n\n\n\n\n\n","category":"type"},{"location":"CostFunctions/#CtrlVQE.Normalizations.Normalization","page":"Cost Functions","title":"CtrlVQE.Normalizations.Normalization","text":"Normalization(evolution, device, basis, grid, ψ0; kwargs...)\n\nThe norm of a statevector in a binary logical space.\n\nArguments\n\nevolution::Evolutions.EvolutionType: the algorithm with which to evolve ψ0       A sensible choice is ToggleEvolutions.TOGGLE\ndevice::Devices.DeviceType: the device, which determines the time-evolution of ψ0\nbasis::Bases.BasisType: the measurement basis       ALSO determines the basis which ψ0 is understood to be given in.       An intuitive choice is Bases.OCCUPATION, aka. the qubits' Z basis.       That said, there is some doubt whether, experimentally,           projective measurement doesn't actually project on the device's eigenbasis,           aka Bases.DRESSED.       Note that you probably want to rotate ψ0 if you change this argument.\ngrid::TrapezoidalIntegration: defines the time integration bounds (eg. from 0 to T)\nψ0: the reference state, living in the physical Hilbert space of device.\n\n\n\n\n\n","category":"type"},{"location":"CostFunctions/#Penalty-Functions","page":"Cost Functions","title":"Penalty Functions","text":"","category":"section"},{"location":"CostFunctions/","page":"Cost Functions","title":"Cost Functions","text":"Modules = [\n    CtrlVQE.GlobalAmplitudeBounds,\n    CtrlVQE.AmplitudeBounds,\n    CtrlVQE.SmoothBounds,\n    CtrlVQE.HardBounds,\n    CtrlVQE.SoftBounds,\n]","category":"page"},{"location":"CostFunctions/#CtrlVQE.SmoothBounds.SmoothBound","page":"Cost Functions","title":"CtrlVQE.SmoothBounds.SmoothBound","text":"SmoothBound(λ̄, x̄R, x̄L, σ̄)\n\nA smooth exponential penalty for each parameter exceeding its bounds.\n\nArguments\n\nλ̄: vector of weights for each penalty       Set λ̄[i]=0 to skip penalties for the ith parameter.\nx̄R: vector of upper bounds for each parameter\nx̄L: vector of lower bounds for each parameter\nσ̄: vector of scalings (smaller=steeper) for each penalty\n\n\n\n\n\n","category":"type"},{"location":"CostFunctions/#CtrlVQE.HardBounds.HardBound","page":"Cost Functions","title":"CtrlVQE.HardBounds.HardBound","text":"HardBound(λ̄, x̄L, x̄R, σ̄)\n\nA steep exponential penalty for each parameter exceeding its bounds.\n\nArguments\n\nλ̄: vector of weights for each penalty       Set λ̄[i]=0 to skip penalties for the ith parameter.\nx̄L: vector of lower bounds for each parameter\nx̄R: vector of upper bounds for each parameter\nσ̄: vector of scalings (smaller=steeper) for each penalty\n\n\n\n\n\n","category":"type"},{"location":"CostFunctions/#CtrlVQE.SoftBounds.SoftBound","page":"Cost Functions","title":"CtrlVQE.SoftBounds.SoftBound","text":"SoftBound(λ̄, μ̄, σ̄)\n\nA shallow quadratic penalty for each parameter's deviation from mean.\n\nArguments\n\nλ̄: vector of weights for each penalty       Set λ̄[i]=0 to skip penalties for the ith parameter.\nμ̄: vector of means for each parameter\nσ̄: vector of scalings (smaller=steeper) for each penalty\n\n\n\n\n\n","category":"type"},{"location":"Operators/","page":"Operators","title":"Operators","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"Operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"Operators/","page":"Operators","title":"Operators","text":"Modules = [CtrlVQE.Operators]","category":"page"},{"location":"Operators/#CtrlVQE.Operators","page":"Operators","title":"CtrlVQE.Operators","text":"Operators\n\nEnumerates various categories of Hermitian observable related to a device.\n\n\n\n\n\n","category":"module"},{"location":"Operators/#CtrlVQE.Operators.Channel","page":"Operators","title":"CtrlVQE.Operators.Channel","text":"Channel(i,t)\n\nAn individual drive term (indexed by i) at a specific time t.\n\nFor example, in a transmon device,     Channel(q,t) might represent Ω_q(t) exp(iν_qt) a_q + exp(-iν_qt) a_q,     the drive for a single qubit.\n\nNote that you are free to have multiple channels for each qubit,     or channels which operate on multiple qubits.\n\n\n\n\n\n","category":"type"},{"location":"Operators/#CtrlVQE.Operators.Coupling","page":"Operators","title":"CtrlVQE.Operators.Coupling","text":"Coupling(), aka COUPLING\n\nThe components of the static Hamiltonian which are non-local to any one qubit.\n\nFor example, in a transmon device,     Coupling() represents the sum _pq g_pq (a_pa_q + a_qa_p).\n\n\n\n\n\n","category":"type"},{"location":"Operators/#CtrlVQE.Operators.Drive","page":"Operators","title":"CtrlVQE.Operators.Drive","text":"Drive(t)\n\nThe sum of all drive terms at a specific time t.\n\nThis represents the sum of each Qubit(i),     where i iterates over each drive term in the device.\n\nFor example, in a transmon device,     Drive(t) might represent _q Ω_q(t) exp(iν_qt) a_q + exp(-iν_qt) a_q.\n\n\n\n\n\n","category":"type"},{"location":"Operators/#CtrlVQE.Operators.Gradient","page":"Operators","title":"CtrlVQE.Operators.Gradient","text":"Gradient(j,t)\n\nAn individual gradient operator (indexed by j) at a specific time t.\n\nThe gradient operators appear in the derivation of each gradient signal,     which are used to calculate analytical gradients of each variational parameter. The gradient operators are very closely related to individual channel operators,     but sufficiently distinct that they need to be treated separately.\n\nFor example, for a transmon device,     each channel operator Ω_q(t) exp(iν_qt) a_q + exp(-iν_qt) a_q     is associated with two gradient operators:\n\nexp(iν_qt) a_q + exp(-iν_qt) a_q\niexp(iν_qt) a_q - exp(-iν_qt) a_q\n\n\n\n\n\n","category":"type"},{"location":"Operators/#CtrlVQE.Operators.Hamiltonian","page":"Operators","title":"CtrlVQE.Operators.Hamiltonian","text":"Hamiltonian(t)\n\nThe full Hamiltonian at a specific time t.\n\nThis represents the sum of Static() and Drive(t).\n\n\n\n\n\n","category":"type"},{"location":"Operators/#CtrlVQE.Operators.Identity","page":"Operators","title":"CtrlVQE.Operators.Identity","text":"Identity(), aka IDENTITY\n\nThe identity operator.\n\n\n\n\n\n","category":"type"},{"location":"Operators/#CtrlVQE.Operators.Qubit","page":"Operators","title":"CtrlVQE.Operators.Qubit","text":"Qubit(q)\n\nThe component of the static Hamiltonian which is local to qubit q.\n\nFor example, in a transmon device,     Qubit(2) represents a term ω_q a_qa_q - δ_q2 a_qa_qa_q a_q.\n\n\n\n\n\n","category":"type"},{"location":"Operators/#CtrlVQE.Operators.Static","page":"Operators","title":"CtrlVQE.Operators.Static","text":"Static(), aka STATIC\n\nAll components of the static Hamiltonian.\n\nThis represents the sum of Uncoupled() and Coupled()\n\n\n\n\n\n","category":"type"},{"location":"Operators/#CtrlVQE.Operators.Uncoupled","page":"Operators","title":"CtrlVQE.Operators.Uncoupled","text":"Uncoupled(), aka UNCOUPLED\n\nThe components of the static Hamiltonian which are local to each qubit.\n\nThis represents the sum of each Qubit(q),     where q iterates over each qubit in the device.\n\nFor example, in a transmon device,     Uncoupled() represents the sum _q (ω_q a_qa_q - δ_q2 a_qa_qa_q a_q).\n\n\n\n\n\n","category":"type"},{"location":"LinearAlgebraTools/","page":"LinearAlgebraTools","title":"LinearAlgebraTools","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"LinearAlgebraTools/#LinearAlgebraTools","page":"LinearAlgebraTools","title":"LinearAlgebraTools","text":"","category":"section"},{"location":"LinearAlgebraTools/","page":"LinearAlgebraTools","title":"LinearAlgebraTools","text":"Modules = [CtrlVQE.LinearAlgebraTools]","category":"page"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools","text":"LinearAlgebraTools\n\nImplement some frequently-used linear-algebraic operations.\n\nMuch of this functionality is available in Julia's standard LinearAlgebra library,     but the implementations here might take advantage of pre-allocated TempArrays     and (sometimes) efficient tensor contractions.\n\n\n\n\n\n","category":"module"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.MatrixList","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.MatrixList","text":"MatrixList{T}\n\nSemantic alias for a 3d array which explicitly represents a list of matrices.\n\nThink of a MatrixList Ā as a list where each A[i] = Ā[:,:,i] is a matrix.\n\n\n\n\n\n","category":"type"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.VectorList","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.VectorList","text":"VectorList{T}\n\nSemantic alias for Matrix which explicitly represents a distinct vector in each column.\n\nThink of a VectorList v̄ as a list where each v[i] = v̄[:,i] is a vector.\n\n\n\n\n\n","category":"type"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.basisvector-Tuple{Int64, Int64}","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.basisvector","text":"basisvector(N::Int, i::Int)\n\nA vector of N Bools, all zero except for index i, which is one.\n\n\n\n\n\n","category":"method"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.braket-Tuple{AbstractVector, AbstractMatrix, AbstractVector}","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.braket","text":"braket(x1::AbstractVector, A::AbstractMatrix, x2::AbstractVector)\n\nCompute the braket ⟨x1|A|x2⟩.\n\n\n\n\n\n","category":"method"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.braket-Union{Tuple{F_}, Tuple{AbstractVector, AbstractArray{F_, 3}, AbstractVector}} where F_","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.braket","text":"braket(x1::AbstractVector, ā::MatrixList, x2::AbstractVector)\n\nCompute the braket ⟨x1|kron(ā)|x2⟩, but somewhat more efficiently.\n\n\n\n\n\n","category":"method"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.cis!","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.cis!","text":"cis!(A::AbstractMatrix, x=1)\n\nCalculates exp(ixA) for a Hermitian matrix A.\n\nThe name comes from the identity exp(ix) = Cos(x) + I Sin(x).\n\nNote that this method mutates A itself to the calculated exponential. Therefore, A must have a complex float type, and it must not be an immutable view. For example, even though A must be Hermitian for this method to work correctly,     it can't actually be a LinearAlgebra.Hermitian view.\n\n\n\n\n\n","category":"function"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.cis_type-Tuple{Any}","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.cis_type","text":"cis_type(x)\n\nPromote the number type of x to a complex float (compatible with cis operations).\n\nThe argument x may be a number, an array of numbers, or a number type itself.\n\n\n\n\n\n","category":"method"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.expectation-Tuple{AbstractArray{T, 3} where T, AbstractVector}","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.expectation","text":"expectation(ā::MatrixList, x::AbstractVector)\n\nCompute the braket ⟨x|kron(ā)|x⟩, but somewhat more efficiently.\n\n\n\n\n\n","category":"method"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.expectation-Tuple{AbstractMatrix, AbstractVector}","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.expectation","text":"expectation(A::AbstractMatrix, x::AbstractVector)\n\nCompute the braket xAx.\n\n\n\n\n\n","category":"method"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.kron-Union{Tuple{AbstractArray{F, 3}}, Tuple{F}} where F","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.kron","text":"kron(Ā::MatrixList; result=nothing)\n\nThe kronecker product of each matrix in Ā.\n\n\n\n\n\n","category":"method"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.kron-Union{Tuple{AbstractMatrix{F}}, Tuple{F}} where F","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.kron","text":"kron(v̄::VectorList; result=nothing)\n\nThe kronecker product of each vector in v̄.\n\nOrdering: [x1 x2] ⊗ [y1 y2] = [x1⋅y1  x1⋅y2  x2⋅y1  x2⋅y2]\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\n\n\n\n\n","category":"method"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.rotate!","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.rotate!","text":"rotate!(R, x)\n\nApply the rotation R to the object x, mutating x.\n\nGenerally, R is a unitary (or orthogonal) matrix. If x is a vector, rotate! computes x  Rx. If x is a matrix, rotate! computes x  RxR.\n\nYou may also pass R as a MatrixList,     which is interpreted as a rotation with a factorized tensor structure. In other words, if r̄ is a MatrixList,     rotate!(r̄, x) is equivalent to rotate!(kron(r̄), x),     except that the former has a more efficient implementation.\n\nSince this method mutates x,     the number type of x must be sufficiently expressive. For example, if R is a unitary matrix, x had better be a vector of complex floats.\n\n\n\n\n\n","category":"function"},{"location":"QubitOperators/","page":"QubitOperators","title":"QubitOperators","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"QubitOperators/#QubitOperators","page":"QubitOperators","title":"QubitOperators","text":"","category":"section"},{"location":"QubitOperators/","page":"QubitOperators","title":"QubitOperators","text":"Modules = [CtrlVQE.QubitOperators]","category":"page"},{"location":"QubitOperators/#CtrlVQE.QubitOperators","page":"QubitOperators","title":"CtrlVQE.QubitOperators","text":"QubitOperators\n\nInterfaces arbitrary physical Hilbert space with a strictly binary logical Hilbert space.\n\nNOTE: I don't especially like how this module is organized,     so consider this code subject to change.\n\n\n\n\n\n","category":"module"},{"location":"QubitOperators/#CtrlVQE.QubitOperators.localqubitisometries-Tuple{CtrlVQE.Devices.DeviceType}","page":"QubitOperators","title":"CtrlVQE.QubitOperators.localqubitisometries","text":"localqubitprojectors(device::Devices.DeviceType)\n\nA matrix list of local qubit isometries for each individual qubit in the device.\n\n\n\n\n\n","category":"method"},{"location":"QubitOperators/#CtrlVQE.QubitOperators.localqubitprojectors-Tuple{CtrlVQE.Devices.DeviceType}","page":"QubitOperators","title":"CtrlVQE.QubitOperators.localqubitprojectors","text":"localqubitprojectors(device::Devices.DeviceType)\n\nA matrix list of local qubit projectors for each individual qubit in the device.\n\n\n\n\n\n","category":"method"},{"location":"QubitOperators/#CtrlVQE.QubitOperators.nqubits-Tuple{AbstractVecOrMat}","page":"QubitOperators","title":"CtrlVQE.QubitOperators.nqubits","text":"nqubits(H)\n\nInfer the number of qubits of a statevector or matrix living in a logical qubit space.\n\nIn other words, calculates n assuming the dimension of H is 2^n.\n\n\n\n\n\n","category":"method"},{"location":"QubitOperators/#CtrlVQE.QubitOperators.project-Union{Tuple{F}, Tuple{AbstractVector{F}, CtrlVQE.Devices.DeviceType}} where F","page":"QubitOperators","title":"CtrlVQE.QubitOperators.project","text":"project(A, device::Devices.DeviceType)\n\nExtend a statevector or matrix living in a two-level space onto a physical Hilbert space.\n\n\n\n\n\n","category":"method"},{"location":"QubitOperators/#CtrlVQE.QubitOperators.qubitisometry-Tuple{CtrlVQE.Devices.DeviceType}","page":"QubitOperators","title":"CtrlVQE.QubitOperators.qubitisometry","text":"qubitisometry(device::Devices.DeviceType)\n\nAn isometry from the physical Hilbert space of a device onto a logical two-level space.\n\nIf Φ is the isometry, and |ψ⟩ is a statevector living in the full Hilbert space,     the vector Φ|ψ⟩ is a smaller vector living in the two-level space.\n\n\n\n\n\n","category":"method"},{"location":"QubitOperators/#CtrlVQE.QubitOperators.qubitprojector-Tuple{CtrlVQE.Devices.DeviceType}","page":"QubitOperators","title":"CtrlVQE.QubitOperators.qubitprojector","text":"qubitprojector(device::Devices.DeviceType)\n\nA projector from the physical Hilbert space of a device onto a logical two-level space.\n\nThe projector Π does not reduce the size of its operand;     it only removes support on the non-logical states. If you want to change the size, use qubitisometry instead.\n\n\n\n\n\n","category":"method"},{"location":"QubitOperators/#CtrlVQE.QubitOperators.reference-Tuple{AbstractMatrix}","page":"QubitOperators","title":"CtrlVQE.QubitOperators.reference","text":"reference(H)\n\nThe basis state which minimizes the matrix H.\n\n\n\n\n\n","category":"method"},{"location":"Devices/","page":"Devices","title":"Devices","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"Devices/#Devices","page":"Devices","title":"Devices","text":"","category":"section"},{"location":"Devices/","page":"Devices","title":"Devices","text":"Modules = [CtrlVQE.Devices]","category":"page"},{"location":"Devices/#CtrlVQE.Devices","page":"Devices","title":"CtrlVQE.Devices","text":"Devices\n\nIn silico representation of quantum devices, in which quantum states evolve in time.\n\nIn this package,     the \"static\" components (ie. qubit frequencies, couplings, etc.)     and the \"drive\" components (ie. control signal, variational parameters, etc.)     are all integrated into a single DeviceType object. All you need to know how a quantum state ψ evolves up time T is in the device.\n\n\n\n\n\n","category":"module"},{"location":"Devices/#CtrlVQE.Devices.DeviceType","page":"Devices","title":"CtrlVQE.Devices.DeviceType","text":"DeviceType{F,FΩ}\n\nSuper-type for all device objects.\n\nType Parameters\n\nF: the float type associated with a device\nFΩ: the number type associated with the device's drive signals. May be complex.\n\nImplementation\n\nAny concrete sub-type D must implement all functions in the Parameters module.\n\nIn particular, if any static operators in your device depend on variational parameters,   you should consult the \"Note on Caching\" below.\n\nIn addition, all methods in the following sections must be implemented.\n\nCounting methods\nAlgebra methods\nOperator methods\nType methods\nFrequency methods\nSignal methods\nGradient methods\n\nIf your device's drive channels are all local,     you should implement a LocallyDrivenDevice,     which has a few extra requirements.\n\nCounting methods:\n\nnqubits(::D): the number of qubits in the device - call this n.\nnlevels(::D): the number of physical levels in each \"qubit\" - call this m.\nndrives(::D): the number of distinct drive channels.\nngrades(::D): the number of distinct gradient operators.\n\nEach of these methods returns an integer.\n\nAlgebra methods:\n\nlocalloweringoperator(::D):       an m × m matrix applying the lowering operator a to a single qubit.\n\nThis method should define result=nothing as a keyword argument;     when passed, use it as the array to store your result in.\n\nOperator methods:\n\nqubithamiltonian(::D, ā, q::Int):       the static components of the device Hamiltonian local to qubit q.\nstaticcoupling(::D, ā):       the static components of the device Hamiltonian nonlocal to any one qubit.\ndriveoperator(::D, ā, i::Int, t::Real):       the distinct drive operator for channel i at time t\ngradeoperator(::D, ā, j::Int, t::Real):       the distinct gradient operator indexed by j at time t\n\nEach of these methods should define result=nothing as a keyword argument;     when passed, use it as the array to store your result in.\n\nEach of these methods takes a 3darray ā;     the annihilation operator a_q is given by the matrix ā[:,:,q]. These methods should construct a new matrix as a function of each a_q. Usually, each ā[:,:,q] is defined on the full Hilbert space (ie. m^n × m^n),     but sometimes the code exploits a simple tensor structure     by passing in local m × m operators instead,     so do not assume a specific size a priori.\n\nThe annihilation operators a_q and their adjoints a_q form a complete algebra,     so it is always possible to express any operator given just ā. For example, the Pauli spin matrices in a two-level system can be expressed     as X=a+a, Y=i(a-a), and Z=aa. If you really want to write your operators as functions of something other than a_q,     you may \"hack\" in a new algebra by implementing new methods     for this module's eltype_algebra, algebra, and localalgebra functions.\n\nType methods:\n\neltype_localloweringoperator(::D)\neltype_qubithamiltonian(::D)\neltype_staticcoupling(::D)\neltype_driveoperator(::D)\neltype_gradeoperator(::D)\n\nEach of these methods gives the number type of the corresponding operator. Implement these methods based only on your implementation of the methods,     ie. they should be independent of the type of ā.\n\nFrequency methods:\n\nresonancefrequency(::D, q::Int)\ndrivefrequency(::D, i::Int)\n\nEach of these methods gives a scalar.\n\nDrive methods:\n\ndrivesignal(::D, i::Int)\n\nEach of these methods gives some SignalType.\n\nGradient methods:\n\ngradient(::D, grid::Integrations.IntegrationType, ϕ̄):       the gradient vector for each variational parameter in the device.\n\nEach partial is generally an integral over at least one gradient signal. The argument grid identifies the temporal lattice on which ϕ̄ is defined. The argument ϕ̄ is a 2d array; ϕ̄[:,:,j] contains the jth gradient signal     ϕ_j(t) evaluated at each point in grid.\n\nThis method should define result=nothing as a keyword argument;     when passed, use it as the array to store your result in.\n\nNotes on Caching\n\nThis module uses the Memoization package to cache some arrays as they are calculated.\n\nThis does not apply to any method which depends on an absolute time t,     though it does apply to methods depending only on a relative time τ. For example, the propagator for a static Hamiltonian is cached,     but not one for a drive Hamiltonian. No caching happens for any method if its result keyword argument is used.\n\nUsually, variational parameters only affect time-dependent methods,     but if any of your device's static operators do depend on a variational parameter,     you should be careful to empty the cache when Parameters.bind is called.\n\nYou can completely clear everything in the cache with:\n\nMemoization.empty_all_caches!()\n\nAlternatively, selectively clear caches for affected functions via:\n\nMemoization.empty_cache!(fn)\n\nI don't know if it's possible to selectively clear cached values for specific methods. If it can be done, it would require obtaining the actual Dict     being used as a cache for a particular function,     figuring out exactly how that cache is indexed,     and manually removing elements matching your targeted method signature.\n\n\n\n\n\n","category":"type"},{"location":"Devices/#CtrlVQE.Devices.LocallyDrivenDevice","page":"Devices","title":"CtrlVQE.Devices.LocallyDrivenDevice","text":"LocallyDrivenDevice\n\nSuper-type for device objects whose drive channels act locally on individual qubits.\n\nInherit from this type if your driveoperator and gradeoperator methods     depend only on a single annihilation operator ā[:,:,q]. This enables more efficient propagation methods which exploit a tensor product structure.\n\nImplementation\n\nAny concrete sub-type D must implement     everything required in the DeviceType interface,     so consult the documentation for DeviceType carefully.\n\nIn addition, the following methods must be implemented:\n\ndrivequbit(::D, i::Int): index of the qubit on which channel i is applied.\ngradequbit(::D, j::Int): index of the qubit associated with the jth gradient operator.\n\nIt's usually trivial to infer the channel index i associated with each gradient operator,     in which case gradequbit(device, j) = drivequbit(device, i),     but this is left as an implementation detail.\n\n\n\n\n\n","category":"type"},{"location":"Devices/#Base.eltype-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType}","page":"Devices","title":"Base.eltype","text":"Base.eltype(op::Operators.OperatorType, device::DeviceType[, basis::Bases.BasisType])\n\nThe number type of the matrix returned by operator(op, device, basis).\n\nWhen omitted, the basis defaults to Bases.OCCUPATION.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.algebra","page":"Devices","title":"CtrlVQE.Devices.algebra","text":"algebra(device::DeviceType[, basis::Bases.BasisType])\n\nA matrix list ā, where ā[:,:,q] represents the annihilation operator a_q.\n\nWhen omitted, the basis defaults to Bases.OCCUPATION.\n\nEach ā[:,:,q] acts globally on the full Hilbert space of the device,     even in bases where it acts trivially on states outside the local space of qubit q. To construct local operators, use localalgebra instead.\n\n\n\n\n\n","category":"function"},{"location":"Devices/#CtrlVQE.Devices.basisrotation-Tuple{CtrlVQE.Bases.BasisType, CtrlVQE.Bases.BasisType, CtrlVQE.Devices.DeviceType}","page":"Devices","title":"CtrlVQE.Devices.basisrotation","text":"basisrotation(tgt::Bases.BasisType, src::Bases.BasisType, device::DeviceType)\n\nCalculate the basis rotation U which transforms ψ_src  ψ_tgt = Uψ_src.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.basisrotation-Tuple{CtrlVQE.Bases.LocalBasis, CtrlVQE.Bases.LocalBasis, CtrlVQE.Devices.DeviceType, Int64}","page":"Devices","title":"CtrlVQE.Devices.basisrotation","text":"basisrotation(tgt::Bases.LocalBasis, src::Bases.LocalBasis, device::DeviceType, q::Int)\n\nSame as above, except that U acts on the local Hilbert space of qubit q.\n\nThis is used elsewhere for more efficient rotations exploiting tensor structure.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.braket-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, AbstractVector, AbstractVector}","page":"Devices","title":"CtrlVQE.Devices.braket","text":"braket(op, device[, basis], ψ1, ψ2)\n\nThe braket of an operator describing a device with respect to states ψ1 and ψ2.\n\nIf A is the operator specified by op, this method calculates ψ1Aψ2.\n\nArguments\n\nop::Operators.OperatorType: which operator to estimate (eg. static, drive, etc.).\ndevice::DeviceType: which device is being described.\nbasis::Bases.BasisType: which basis the state ψ is represented in.       Defaults to Bases.OCCUPATION when omitted.\nψ1, ψ2: Statevectors defined over the full Hilbert space of the device.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.detuningfrequency-Tuple{CtrlVQE.Devices.DeviceType, Int64, Int64}","page":"Devices","title":"CtrlVQE.Devices.detuningfrequency","text":"detuningfrequency(device::DeviceType, q::Int, i::Int)\n\nCalculate the difference between qubit resonance and drive frequency.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.diagonalize","page":"Devices","title":"CtrlVQE.Devices.diagonalize","text":"diagonalize(basis::Bases.BasisType, device::DeviceType)\n\nCompute the vector of eigenvalues Λ and the rotation matrix U for a given basis.\n\nU is an operator acting on the global Hilbert space of the device.\n\nThe result is packed into a LinearAlgebra.Eigen object,     but it may be unpacked by Λ, U = diagonalize(basis, device).\n\ndiagonalize(basis::Bases.LocalBasis, device::DeviceType, q::Int)\n\nSame as above, except that U acts on the local Hilbert space of qubit q.\n\nNote that you can still construct     the global rotation matrix of a local basis by using the first method.\n\n\n\n\n\n","category":"function"},{"location":"Devices/#CtrlVQE.Devices.drivefrequency-Union{Tuple{FΩ}, Tuple{F}, Tuple{CtrlVQE.Devices.DeviceType{F, FΩ}, Int64}} where {F, FΩ}","page":"Devices","title":"CtrlVQE.Devices.drivefrequency","text":"drivesignal(device::DeviceType, i::Int)\n\nThe drive frequency for a given pulse index.\n\nNOTE: At present, the drive frequency is assumed to be constant.     We may change it someday to a generic Signal,         where the typical use-case is to use a real Constant signal.     In any case it shall be real.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.driveoperator-Tuple{CtrlVQE.Devices.DeviceType, AbstractArray{T, 3} where T, Int64, Real}","page":"Devices","title":"CtrlVQE.Devices.driveoperator","text":"driveoperator(device::DeviceType, ā::MatrixList, i::Int, t::Real; result=nothing)\n\nThe distinct drive operator for channel i at time t.\n\nThis method is a function of annihilation operators a_q given by ā[:,:,q],     which are matrices acting globally on the physical Hilbert space. If device is a LocallyDrivenDevice,     the matrices may also act on a local physical Hilbert space for each individual qubit.\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.drivequbit-Tuple{CtrlVQE.Devices.LocallyDrivenDevice, Int64}","page":"Devices","title":"CtrlVQE.Devices.drivequbit","text":"drivequbit(device, i::Int)\n\nIndex of the qubit on which channel i is applied.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.drivesignal-Union{Tuple{FΩ}, Tuple{F}, Tuple{CtrlVQE.Devices.DeviceType{F, FΩ}, Int64}} where {F, FΩ}","page":"Devices","title":"CtrlVQE.Devices.drivesignal","text":"drivesignal(device::DeviceType, i::Int)\n\nThe time-dependent signal for a given pulse index.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.eltype_algebra","page":"Devices","title":"CtrlVQE.Devices.eltype_algebra","text":"eltype_algebra(device::DeviceType[, basis::Bases.BasisType])\n\nThe number type of each annihilation operator a_j represented in the given basis.\n\nWhen omitted, the basis defaults to Bases.OCCUPATION.\n\n\n\n\n\n","category":"function"},{"location":"Devices/#CtrlVQE.Devices.eltype_driveoperator-Tuple{CtrlVQE.Devices.DeviceType}","page":"Devices","title":"CtrlVQE.Devices.eltype_driveoperator","text":"eltype_driveoperator(device::DeviceType)\n\nThe number type of the time-dependent drive channels for this device.\n\nThe number type of the algebra ā is ignored for the purposes of this method.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.eltype_gradeoperator-Tuple{CtrlVQE.Devices.DeviceType}","page":"Devices","title":"CtrlVQE.Devices.eltype_gradeoperator","text":"eltype_gradeoperator(device::DeviceType)\n\nThe number type of the gradient operators for this device.\n\nThe number type of the algebra ā is ignored for the purposes of this method.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.eltype_localloweringoperator-Tuple{CtrlVQE.Devices.DeviceType}","page":"Devices","title":"CtrlVQE.Devices.eltype_localloweringoperator","text":"eltype_localloweringoperator(device::DeviceType)\n\nThe number type of a local lowering operator for this device.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.eltype_qubithamiltonian-Tuple{CtrlVQE.Devices.DeviceType}","page":"Devices","title":"CtrlVQE.Devices.eltype_qubithamiltonian","text":"eltype_qubithamiltonian(device::DeviceType)\n\nThe number type of the local static components of the Hamiltonian for this device.\n\nThe number type of the algebra ā is ignored for the purposes of this method.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.eltype_staticcoupling-Tuple{CtrlVQE.Devices.DeviceType}","page":"Devices","title":"CtrlVQE.Devices.eltype_staticcoupling","text":"eltype_staticcoupling(device::DeviceType)\n\nThe number type of the non-local static components of the Hamiltonian for this device.\n\nThe number type of the algebra ā is ignored for the purposes of this method.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.evolve!-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, Real, AbstractVecOrMat{<:Complex{<:AbstractFloat}}}","page":"Devices","title":"CtrlVQE.Devices.evolve!","text":"evolve!(op, device[, basis], t, ψ)\n\nPropagate a state ψ by a time t under the Hermitian op describing a device.\n\nThis function is identical to propagate!,     except that the cache is not used for intermediate propagator matrices,     and that it is undefined for time-dependent operators. Look to the Evolutions module for algorithms compatible with time-dependence!\n\nArguments\n\nop::Operators.OperatorType: which operator to evolve under (eg. static, drive, etc.).\ndevice::DeviceType: which device is being described.\nbasis::Bases.BasisType: which basis the state ψ is represented in.       Defaults to Bases.OCCUPATION when omitted.\nt::Real: the amount to move forward in time by.\nψ: Either a vector or a matrix, defined over the full Hilbert space of the device.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.evolver-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, Real}","page":"Devices","title":"CtrlVQE.Devices.evolver","text":"evolver(op, device[, basis], t; kwargs...)\n\nA unitary propagator describing evolution under a Hermitian operator for an time t.\n\nThis function is identical to propagator,     except that the argument t is considered an absolute time so it is never cached,     and that it is undefined for time-dependent operators. It exists solely to perform rotating-frame rotations at every time-step     without worrying about over-caching.\n\nArguments\n\nop::Operators.OperatorType: which operator to evolve under (eg. static, drive, etc.).\ndevice::DeviceType: which device is being described.\nbasis::Bases.BasisType: which basis the operator will be represented in.       Defaults to Bases.OCCUPATION when omitted.\nt::Real: the amount to move forward in time by.\n\nKeyword Arguments\n\nresult: a pre-allocated array of compatible type and shape, used to store the result.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.expectation-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, AbstractVector}","page":"Devices","title":"CtrlVQE.Devices.expectation","text":"expectation(op, device[, basis], ψ)\n\nThe expectation value of an operator describing a device with respect to the state ψ.\n\nIf A is the operator specified by op, this method calculates ψAψ.\n\nArguments\n\nop::Operators.OperatorType: which operator to estimate (eg. static, drive, etc.).\ndevice::DeviceType: which device is being described.\nbasis::Bases.BasisType: which basis the state ψ is represented in.       Defaults to Bases.OCCUPATION when omitted.\nψ: A statevector defined over the full Hilbert space of the device.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.globalize-Union{Tuple{F}, Tuple{CtrlVQE.Devices.DeviceType, AbstractMatrix{F}, Int64}} where F","page":"Devices","title":"CtrlVQE.Devices.globalize","text":"globalize(device::DeviceType, op::AbstractMatrix, q::Int; result=nothing)\n\nExtend a local operator op acting on qubit q into the global Hilbert space.\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.gradeoperator-Tuple{CtrlVQE.Devices.DeviceType, AbstractArray{T, 3} where T, Int64, Real}","page":"Devices","title":"CtrlVQE.Devices.gradeoperator","text":"gradeoperator(device::DeviceType, ā::MatrixList, j::Int, t::Real; result=nothing)\n\nThe distinct gradient operator indexed by j at time t.\n\nI have defined the \"gradient operator\" A_j as the Hermitian operator     for which the jth gradient signal is ϕ_j = λ(iA_j)ψ + ht.\n\nThis method is a function of annihilation operators a_q given by ā[:,:,q],     which are matrices acting globally on the physical Hilbert space. If device is a LocallyDrivenDevice,     the matrices may also act on a local physical Hilbert space for each individual qubit.\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.gradequbit-Tuple{CtrlVQE.Devices.LocallyDrivenDevice, Int64}","page":"Devices","title":"CtrlVQE.Devices.gradequbit","text":"gradequbit(device, j::Int)\n\nIndex of the qubit associated with the jth gradient operator.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.gradient-Tuple{CtrlVQE.Devices.DeviceType, CtrlVQE.Integrations.IntegrationType, AbstractMatrix}","page":"Devices","title":"CtrlVQE.Devices.gradient","text":"gradient(::DeviceType, grid::Integrations.IntegrationType, ϕ̄; result=nothing)\n\nThe gradient vector of partials for each variational parameter in the device.\n\nEach partial is generally an integral over at least one gradient signal. The argument grid identifies the temporal lattice on which ϕ̄ is defined. The argument ϕ̄ is a 2d array; ϕ̄[:,:,j] contains the jth gradient signal     ϕ_j(t) evaluated at each point in grid.\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.localalgebra","page":"Devices","title":"CtrlVQE.Devices.localalgebra","text":"localalgebra(device::DeviceType[, basis::Bases.LocalBasis])\n\nA matrix list ā, where ā[:,:,q] represents the annihilation operator a_q.\n\nWhen omitted, the basis defaults to Bases.OCCUPATION.\n\nEach ā[:,:,q] acts locally on the physical Hilbert space of qubit q. Note that you can construct global operators in a local basis by using algebra instead.\n\n\n\n\n\n","category":"function"},{"location":"Devices/#CtrlVQE.Devices.localbasisrotations-Tuple{CtrlVQE.Bases.LocalBasis, CtrlVQE.Bases.LocalBasis, CtrlVQE.Devices.DeviceType}","page":"Devices","title":"CtrlVQE.Devices.localbasisrotations","text":"localbasisrotations(tgt::Bases.LocalBasis, src::Bases.LocalBasis, device::DeviceType)\n\nA matrix list ū, where ū[:,:,q] is a local basis rotation on qubit q.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.localdriveoperators-Tuple{CtrlVQE.Devices.LocallyDrivenDevice, Real}","page":"Devices","title":"CtrlVQE.Devices.localdriveoperators","text":"localdriveoperators(device[, basis], t; kwargs...)\n\nA matrix list v̄, where v̄[:,:,q] represents a sum of all drives acting on qubit q.\n\nArguments\n\ndevice::DeviceType: which device is being described.\nbasis::Bases.BasisType: which basis the operators will be represented in.       Defaults to Bases.OCCUPATION when omitted.\nt::Real: the time each drive operator is evaluated at.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.localdrivepropagators-Tuple{CtrlVQE.Devices.LocallyDrivenDevice, Real, Real}","page":"Devices","title":"CtrlVQE.Devices.localdrivepropagators","text":"localdrivepropagators(device[, basis], τ, t; kwargs...)\n\nA matrix list ū, where ū[:,:,q] is the propagator for a local drive term.\n\nArguments\n\ndevice::DeviceType: which device is being described.\nbasis::Bases.BasisType: which basis the operators will be represented in.       Defaults to Bases.OCCUPATION when omitted.\nτ::Real: the amount to move forward in time by.       Note that the propagation is only approximate for time-dependent operators.       The smaller τ is, the more accurate the approximation.\nt::Real: the time each drive operator is evaluated at.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.localloweringoperator-Tuple{CtrlVQE.Devices.DeviceType}","page":"Devices","title":"CtrlVQE.Devices.localloweringoperator","text":"localloweringoperator(device::DeviceType; result=nothing)\n\nThe lowering operator a acting on the Hilbert space of a single physical qubit.\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.localqubitevolvers-Tuple{CtrlVQE.Devices.DeviceType, Real}","page":"Devices","title":"CtrlVQE.Devices.localqubitevolvers","text":"localqubitevolvers(device[, basis], τ; kwargs...)\n\nA matrix list ū, where each ū[:,:,q] is a propagator for a local qubit hamiltonian.\n\nThis function is identical to localqubitevolvers,     except that the argument t is considered an absolute time so it is never cached.\n\nArguments\n\ndevice::DeviceType: which device is being described.\nbasis::Bases.BasisType: which basis the operator will be represented in.       Defaults to Bases.OCCUPATION when omitted.\nτ::Real: the amount to move forward in time by.       Note that the propagation is only approximate for time-dependent operators.       The smaller τ is, the more accurate the approximation.\n\nKeyword Arguments\n\nresult: a pre-allocated array of compatible type and shape, used to store the result.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.localqubitoperators-Tuple{CtrlVQE.Devices.DeviceType}","page":"Devices","title":"CtrlVQE.Devices.localqubitoperators","text":"localqubitoperators(device[, basis]; kwargs...)\n\nA matrix list h̄, where each h̄[:,:,q] represents a local qubit hamiltonian.\n\nArguments\n\ndevice::DeviceType: which device is being described.\nbasis::Bases.BasisType: which basis the operators will be represented in.       Defaults to Bases.OCCUPATION when omitted.\n\nKeyword Arguments\n\nresult: a pre-allocated array of compatible type and shape, used to store the result.\nlocalqubitoperators(device, basis, :cache)\n\nFor internal use only. The extra positional argument enables dispatch to a cached function when appropriate.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.localqubitpropagators-Tuple{CtrlVQE.Devices.DeviceType, Real}","page":"Devices","title":"CtrlVQE.Devices.localqubitpropagators","text":"localqubitpropagators(device[, basis], τ; kwargs...)\n\nA matrix list ū, where each ū[:,:,q] is a propagator for a local qubit hamiltonian.\n\nArguments\n\ndevice::DeviceType: which device is being described.\nbasis::Bases.BasisType: which basis the operator will be represented in.       Defaults to Bases.OCCUPATION when omitted.\nτ::Real: the amount to move forward in time by.\n\nKeyword Arguments\n\nresult: a pre-allocated array of compatible type and shape, used to store the result.\nlocalqubitpropagators(device, basis, τ, :cache)\n\nFor internal use only. The extra positional argument enables dispatch to a cached function when appropriate.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.ndrives-Tuple{CtrlVQE.Devices.DeviceType}","page":"Devices","title":"CtrlVQE.Devices.ndrives","text":"ndrives(device::DeviceType)\n\nThe number of distinct drive channels.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.ngrades-Tuple{CtrlVQE.Devices.DeviceType}","page":"Devices","title":"CtrlVQE.Devices.ngrades","text":"ngrades(device::DeviceType)\n\nThe number of distinct gradient operators.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.nlevels-Tuple{CtrlVQE.Devices.DeviceType}","page":"Devices","title":"CtrlVQE.Devices.nlevels","text":"nlevels(device::DeviceType)\n\nThe number of physical levels in each \"qubit\".\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.nqubits-Tuple{CtrlVQE.Devices.DeviceType}","page":"Devices","title":"CtrlVQE.Devices.nqubits","text":"nqubits(device::DeviceType)\n\nThe number of qubits in the device.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.nstates-Tuple{CtrlVQE.Devices.DeviceType}","page":"Devices","title":"CtrlVQE.Devices.nstates","text":"nstates(device::DeviceType)\n\nThe total number of states in the physical Hilbert space of the device.\n\n(This is as opposed to nlevels(device),     the number of states in the physical Hilbert space of a single independent qubit.)\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.operator-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType}","page":"Devices","title":"CtrlVQE.Devices.operator","text":"operator(op, device[, basis]; kwargs...)\n\nA Hermitian operator describing a device, represented in the given basis.\n\nFor example, to construct the static Hamiltonian of a device in the dressed basis,     call operator(Operators.STATIC, device, Bases.DRESSED).\n\nArguments\n\nop::Operators.OperatorType: which operator to construct (eg. static, drive, etc.).\ndevice::DeviceType: which device is being described.\nbasis::Bases.BasisType: which basis the operator will be represented in.       Defaults to Bases.OCCUPATION when omitted.\n\nKeyword Arguments\n\nresult: a pre-allocated array of compatible type and shape, used to store the result.\noperator(op, device, basis, :cache)\n\nFor internal use only. The extra positional argument enables dispatch to a cached function when appropriate.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.propagate!-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, Real, AbstractVecOrMat{<:Complex{<:AbstractFloat}}}","page":"Devices","title":"CtrlVQE.Devices.propagate!","text":"propagate!(op, device[, basis], τ, ψ)\n\nPropagate a state ψ by a small time τ under the Hermitian op describing a device.\n\nArguments\n\nop::Operators.OperatorType: which operator to evolve under (eg. static, drive, etc.).\ndevice::DeviceType: which device is being described.\nbasis::Bases.BasisType: which basis the state ψ is represented in.       Defaults to Bases.OCCUPATION when omitted.\nτ::Real: the amount to move forward in time by.       Note that the propagation is only approximate for time-dependent operators.       The smaller τ is, the more accurate the approximation.\nψ: Either a vector or a matrix, defined over the full Hilbert space of the device.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.propagator-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, Real}","page":"Devices","title":"CtrlVQE.Devices.propagator","text":"propagator(op, device[, basis], τ; kwargs...)\n\nA unitary propagator describing evolution under a Hermitian operator for a small time τ.\n\nArguments\n\nop::Operators.OperatorType: which operator to evolve under (eg. static, drive, etc.).\ndevice::DeviceType: which device is being described.\nbasis::Bases.BasisType: which basis the operator will be represented in.       Defaults to Bases.OCCUPATION when omitted.\nτ::Real: the amount to move forward in time by.       Note that the propagation is only approximate for time-dependent operators.       The smaller τ is, the more accurate the approximation.\n\nKeyword Arguments\n\nresult: a pre-allocated array of compatible type and shape, used to store the result.\npropagator(op, device, basis, τ, :cache)\n\nFor internal use only. The extra positional argument enables dispatch to a cached function when appropriate.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.qubithamiltonian-Tuple{CtrlVQE.Devices.DeviceType, AbstractArray{T, 3} where T, Int64}","page":"Devices","title":"CtrlVQE.Devices.qubithamiltonian","text":"qubithamiltonian(device::DeviceType, ā::MatrixList, q::Int; result=nothing)\n\nThe static components of the device Hamiltonian local to qubit q.\n\nThis method is a function of annihilation operators a_q given by ā[:,:,q],     which may be matrices acting on a physical Hilbert space either globally or locally.\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.resonancefrequency-Union{Tuple{FΩ}, Tuple{F}, Tuple{CtrlVQE.Devices.DeviceType{F, FΩ}, Int64}} where {F, FΩ}","page":"Devices","title":"CtrlVQE.Devices.resonancefrequency","text":"resonancefrequency(device::DeviceType, q::Int)\n\nThe energy gap betwen the logical |0⟩ and |1⟩ states of a given qubit index.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.staticcoupling-Tuple{CtrlVQE.Devices.DeviceType, AbstractArray{T, 3} where T}","page":"Devices","title":"CtrlVQE.Devices.staticcoupling","text":"staticcoupling(device::DeviceType, ā::MatrixList, q::Int; result=nothing)\n\nThe static components of the device Hamiltonian nonlocal to any one qubit.\n\nThis method is a function of annihilation operators a_q given by ā[:,:,q],     which are matrices acting globally on the physical Hilbert space.\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#Transmon-Devices","page":"Devices","title":"Transmon Devices","text":"","category":"section"},{"location":"Devices/","page":"Devices","title":"Devices","text":"Modules = [CtrlVQE.TransmonDevices]","category":"page"},{"location":"Devices/#CtrlVQE.TransmonDevices.FixedFrequencyTransmonDevice","page":"Devices","title":"CtrlVQE.TransmonDevices.FixedFrequencyTransmonDevice","text":"FixedFrequencyTransmonDevice(ω̄, δ̄, ḡ, quples, q̄, ν̄, Ω̄, m)\n\nA transmon device, modeling for example IBM's superconducting quantum computers.\n\nVariational parameters include ONLY the shape parameters in each pulse. Pulse frequencies are \"frozen\".\n\nArguments\n\nω̄: a vector of angular frequencies specifying the resonance frequency of each qubit.\nδ̄: a vector of angular frequencies specifying the anharmonicity of each qubit.\nḡ: a vector of angular frequencies specifying the strength of each coupling.\nquples: a vector of Quple identifying whcih qubits participate in each coupling.\nq̄: a vector of indices specifying the target qubit for each drive channel.\nν̄: a vector of angular frequencies specifying the pulse frequencies for each channel.\nΩ̄: a vector of signals specifying the shape of the pulse for each channel.\nm: an integer specifying the number of physical levels to retain for each qubit.\n\n\n\n\n\n","category":"type"},{"location":"Devices/#CtrlVQE.TransmonDevices.TransmonDevice","page":"Devices","title":"CtrlVQE.TransmonDevices.TransmonDevice","text":"TransmonDevice(ω̄, δ̄, ḡ, quples, q̄, ν̄, Ω̄, m)\n\nA transmon device, modeling for example IBM's superconducting quantum computers.\n\nVariational parameters include the shape parameters in each pulse,     and the pulse frequencies.\n\nArguments\n\nω̄: a vector of angular frequencies specifying the resonance frequency of each qubit.\nδ̄: a vector of angular frequencies specifying the anharmonicity of each qubit.\nḡ: a vector of angular frequencies specifying the strength of each coupling.\nquples: a vector of Quple identifying whcih qubits participate in each coupling.\nq̄: a vector of indices specifying the target qubit for each drive channel.\nν̄: a vector of angular frequencies specifying the pulse frequencies for each channel.\nΩ̄: a vector of signals specifying the shape of the pulse for each channel.\nm: an integer specifying the number of physical levels to retain for each qubit.\n\n\n\n\n\n","category":"type"},{"location":"Evolutions/","page":"Evolutions","title":"Evolutions","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"Evolutions/#Evolutions","page":"Evolutions","title":"Evolutions","text":"","category":"section"},{"location":"Evolutions/","page":"Evolutions","title":"Evolutions","text":"Modules = [CtrlVQE.Evolutions]","category":"page"},{"location":"Evolutions/#CtrlVQE.Evolutions","page":"Evolutions","title":"CtrlVQE.Evolutions","text":"Evolutions\n\nAlgorithms to run time evolution, and related constructs like gradient signals.\n\nNOTE: the trapezoidaltimegrid function is a utility.     But it is implicitly tied to evolutions. I'm not sure what to do about it.     It is an awkward space, similar to QubitOperators below.\n\n\n\n\n\n","category":"module"},{"location":"Evolutions/#CtrlVQE.Evolutions.EvolutionType","page":"Evolutions","title":"CtrlVQE.Evolutions.EvolutionType","text":"EvolutionType\n\nSuper-type for all evolution algorithms.\n\nImplementation\n\nAny concrete sub-type A must implement the following methods:\n\nworkbasis(::A): which Bases.BasisType the evolution algorithm uses\nevolve!(::A, device, grid, ψ; callback=nothing): evolve ψ (in-place) on a time grid                                   (you may assume the basis of ψ is the work basis)\n\nYou are allowed to implement evolve! for restricted types of grid     (eg. require it to be a TrapezoidalIntegration),     so long as you are clear in your documentation.\n\n\n\n\n\n","category":"type"},{"location":"Evolutions/#CtrlVQE.Evolutions.evolve","page":"Evolutions","title":"CtrlVQE.Evolutions.evolve","text":"evolve(evolution, device, [basis, ]grid, ψ0; result=nothing, kwargs...)\n\nEvolve a state ψ0 over time grid under a device Hamiltonian, without mutating ψ0.\n\nThis method simply copies ψ0 (to result if provided, or else to a new array),     then calls the mutating function evolve! on the copy. Please see evolve! for detailed documentation.\n\n\n\n\n\n","category":"function"},{"location":"Evolutions/#CtrlVQE.Evolutions.evolve!","page":"Evolutions","title":"CtrlVQE.Evolutions.evolve!","text":"evolve!(evolution, device, [basis, ]T, ψ; basis=nothing, callback=nothing)\n\nEvolve a state ψ by time T under a device Hamiltonian.\n\nThis method both mutates and returns ψ.\n\nArguments\n\nevolution::EvolutionType: which evolution algorithm to use.\ndevice::Devices.DeviceType: specifies which Hamiltonian to evolve under.\nbasis::Bases.BasisType: which basis ψ is represented in.       Implicitly defaults to workbasis(evolution).\ngrid::TrapezoidalIntegration: defines the time integration bounds (eg. from 0 to T)\nψ: the initial statevector, defined on the full Hilbert space of the device.\n\nKeyword Arguments\n\ncallback: a function which is called at each iteration of the time evolution.       The function is passed three arguments:       - i: indexes the iteration       - t: the current time point       - ψ: the current statevector, in the work basis       The function is called after having evolved ψ into |ψ(t)⟩.\n\n\n\n\n\n","category":"function"},{"location":"Evolutions/#CtrlVQE.Evolutions.gradientsignals-Tuple{CtrlVQE.Evolutions.EvolutionType, CtrlVQE.Devices.DeviceType, Vararg{Any}}","page":"Evolutions","title":"CtrlVQE.Evolutions.gradientsignals","text":"gradientsignals(device[, basis], grid, ψ0, r, O; kwargs...)\n\nThe gradient signals associated with a given device Hamiltonian, and an observable O.\n\nGradient signals are used to calculate analytical derivatives of a control pulse.\n\nNOTE: Currently, this method assumes a trapezoidal rule,     so only TrapezoidalIntegration grids are allowed.\n\nArguments\n\nevolution::EvolutionType how to initialize the co-state |λ⟩       A standard choice would be ToggleEvolutions.Toggle(r).\ndevice::Devices.DeviceType: specifies which Hamiltonian to evolve under.       Also identifies each of the gradient operators used to calculate gradient signals.\nbasis::Bases.BasisType: which basis ψ is represented in.       ALSO determines the basis in which calculations are carried out.       Defaults to Bases.OCCUPATION.\ngrid::TrapezoidalIntegration: defines the time integration bounds (eg. from 0 to T)\nψ0: the initial statevector, defined on the full Hilbert space of the device.\nO: a Hermitian observable, represented as a matrix.   Gradients are calculated with respect to the expectation ⟨O⟩ at time T.\n\nKeyword Arguments\n\nresult: an (optional) pre-allocated array to store gradient signals\ncallback: a function called at each iteration of the gradient signal calculation.       The function is passed three arguments:       - i: indexes the iteration       - t: the current time point       - ψ: the current statevector, in the OCCUPATION basis       The function is called after having evolved ψ into |ψ(t)⟩,           but before calculating ϕ̄[i,:]. Evolution here runs backwards.\n\nReturns\n\nA vector list ϕ̄, where each ϕ̄[:,j] is the gradient signal ϕ_j(t)     evaluated on the given time grid.\n\nExplanation\n\nA gradient signal ϕ_j(t) is defined with respect to a gradient operator A_j,     an observable O, a time-dependent state |ψ(t)⟩, and total pulse duration T.\n\nLet us define the expectation value E(T)  ψ(T)Oψ(T).\n\nDefine the co-state λ(t) as the (un-normalized) statevector     which satisfies E(T)=λ(t)ψ(t) for any time t∊[0,T]. The gradient signal is defined as ϕ_j(t)  λ(t)(iA_j)ψ(t) + ht.\n\ngradientsignals(device[, basis], T, ψ0, r, Ō; kwargs...)\n\nWhen the matrix argument O is replaced by a matrix list Ō,     each Ō[:,:,k] represents a different Hermitian observable O_k. In this case, a different set of gradient signals is computed for each O_k.\n\nReturns\n\nA 3d array ϕ̄, where each ϕ̄[:,j,k] is the gradient signal ϕ_j(t)     defined with respect to the observable O_k.\n\nExplanation\n\nMultiple sets of gradient signals may be useful     if you want to compute gradients with respect to multiple observables. For example, gradients with respect to a normalized molecular energy     include contributions from both a molecular Hamiltonian and a leakage operator. This method enables such calculations using only a single \"pass\" through time.\n\n\n\n\n\n","category":"method"},{"location":"Evolutions/#CtrlVQE.Evolutions.workbasis-Tuple{CtrlVQE.Evolutions.EvolutionType}","page":"Evolutions","title":"CtrlVQE.Evolutions.workbasis","text":"workbasis(evolution::EvolutionType)\n\nWhich basis the evolution algorithm works in.\n\nAlso defines the default basis to interpret ψ as, in evolution methods.\n\n\n\n\n\n","category":"method"},{"location":"Evolutions/#Trotter-Evolutions","page":"Evolutions","title":"Trotter Evolutions","text":"","category":"section"},{"location":"Evolutions/","page":"Evolutions","title":"Evolutions","text":"Modules = [\n    CtrlVQE.ToggleEvolutions,\n    CtrlVQE.DirectEvolutions,\n]","category":"page"},{"location":"Evolutions/#CtrlVQE.ToggleEvolutions.Toggle","page":"Evolutions","title":"CtrlVQE.ToggleEvolutions.Toggle","text":"Toggle\n\nA Trotterization method (using r steps) alternately propagating static and drive terms.\n\nThe work basis for this algorithm is Bases.OCCUPATION,     since the time-dependent \"Drive\" operator at each step is usually qubit-local.\n\nNOTE: This method assumes a trapezoidal rule,     so only TrapezoidalIntegration grids are allowed.\n\n\n\n\n\n","category":"type"},{"location":"Evolutions/#CtrlVQE.DirectEvolutions.Direct","page":"Evolutions","title":"CtrlVQE.DirectEvolutions.Direct","text":"Direct\n\nA Trotterization method (using r steps) calculating drive terms in the rotation-frame.\n\nThe work basis for this algorithm is Bases.DRESSED,     since the rotating-frame evolution U_t  exp(-itH_0) happens at each step.\n\nThis algorithm exponentiates the matrix U_t V(t) U_t at each time step,     so it is not terribly efficient.\n\nNOTE: Currently, this method assumes a trapezoidal rule,     so only TrapezoidalIntegration grids are allowed. TODO (mid): Actually I'm pretty sure this one doesn't have any reason to...\n\n\n\n\n\n","category":"type"},{"location":"","page":"CtrlVQE","title":"CtrlVQE","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"#CtrlVQE","page":"CtrlVQE","title":"CtrlVQE","text":"","category":"section"},{"location":"","page":"CtrlVQE","title":"CtrlVQE","text":"Documentation for CtrlVQE.","category":"page"},{"location":"#Main-Modules","page":"CtrlVQE","title":"Main Modules","text":"","category":"section"},{"location":"","page":"CtrlVQE","title":"CtrlVQE","text":"Pages = [\n    \"Parameters.md\",\n    \"Bases.md\",\n    \"Operators.md\",\n    \"LinearAlgebraTools.md\",\n    \"Integrations.md\",\n    \"Devices.md\",\n    \"Signals.md\",\n    \"Evolutions.md\",\n    \"QubitOperators.md\",\n    \"CostFunctions.md\",\n]","category":"page"},{"location":"#Recipes","page":"CtrlVQE","title":"Recipes","text":"","category":"section"},{"location":"","page":"CtrlVQE","title":"CtrlVQE","text":"Modules = [CtrlVQE]","category":"page"},{"location":"#CtrlVQE.FullyTrotterized-Tuple{CtrlVQE.Signals.SignalType, Real, Int64}","page":"CtrlVQE","title":"CtrlVQE.FullyTrotterized","text":"FullyTrotterized(signal::Signals.SignalType, T::Real, r::Int)\n\nBreak a signal up so that each time-step is parameterized separately.\n\nUsually you'll want to use this with constant signals.\n\n\n\n\n\n","category":"method"},{"location":"#CtrlVQE.Systematic-Tuple{Type{<:CtrlVQE.TransmonDevices.AbstractTransmonDevice}, Int64, Any}","page":"CtrlVQE","title":"CtrlVQE.Systematic","text":"Systematic(TransmonDeviceType, n, pulses; kwargs...)\n\nStandardized constructor for a somewhat realistic transmon device, but of arbitrary size.\n\nThis is a linearly coupled device,     with uniformly-spaced resonance frequencies,     and with all coupling and anharmonicity constants equal for each qubit. The actual values of each constant are meant to roughly approximate a typical IBM device.\n\nArguments\n\nTransmonDeviceType: the type of the device to be constructed\nn::Int: the number of qubits in the device\npulses: a vector of control signals (Signals.SignalType), or one to be copied\n\nKeyword Arguments\n\nm::Int: the number of transmon levels to include in simulations (defaults to 2)\nF: the float type to use for device parameters (defaults to Float64)\n\n\n\n\n\n","category":"method"},{"location":"#CtrlVQE.TemporalLattice-Tuple{AbstractFloat, Int64}","page":"CtrlVQE","title":"CtrlVQE.TemporalLattice","text":"TemporalLattice(T::AbstractFloat, r::Int)\n\nSemantic shorthand for constructing a TrapezoidalIntegration,     which is the only one supported for, probably, all time. ^_^\n\nArguments\n\nT::AbstractFloat: the total pulse duration\nr::Int: the number of Trotter steps\n\n\n\n\n\n","category":"method"},{"location":"#CtrlVQE.UniformWindowed-Tuple{CtrlVQE.Signals.SignalType, Real, Int64}","page":"CtrlVQE","title":"CtrlVQE.UniformWindowed","text":"UniformWindowed(signal::Signals.SignalType, T::Real, W::Int)\n\nBreak a signal up into equal-sized windows.\n\nUsually you'll want to use this with constant signals.\n\n\n\n\n\n","category":"method"},{"location":"#Miscellaneous-Modules","page":"CtrlVQE","title":"Miscellaneous Modules","text":"","category":"section"},{"location":"#Quples","page":"CtrlVQE","title":"Quples","text":"","category":"section"},{"location":"","page":"CtrlVQE","title":"CtrlVQE","text":"Modules = [Quples]","category":"page"},{"location":"#CtrlVQE.Quples","page":"CtrlVQE","title":"CtrlVQE.Quples","text":"Quples\n\nQubit tuples: simple types to represent couplings within a device.\n\n\n\n\n\n","category":"module"},{"location":"#CtrlVQE.Quples.Quple","page":"CtrlVQE","title":"CtrlVQE.Quples.Quple","text":"Quple(q1,q2)\n\nA (symmetric) coupling between qubits indexed by q1 and q2.\n\nNote that the order is irrelevant: Quple(q1,q2) == Quple(q2,q1).\n\n\n\n\n\n","category":"type"},{"location":"#TempArrays","page":"CtrlVQE","title":"TempArrays","text":"","category":"section"},{"location":"","page":"CtrlVQE","title":"CtrlVQE","text":"TempArrays\nTempArrays.array","category":"page"},{"location":"#CtrlVQE.TempArrays","page":"CtrlVQE","title":"CtrlVQE.TempArrays","text":"TempArrays\n\nMaintain caches for pre-allocated arrays used only temporarily within a function.\n\nDo NOT use this module for arrays     whose data are accessible outside the function in which they are created.\n\n\n\n\n\n","category":"module"},{"location":"#CtrlVQE.TempArrays.array","page":"CtrlVQE","title":"CtrlVQE.TempArrays.array","text":"array(::F, shape::Tuple, index=nothing)\n\nFetch a temporary array with type F and shape shape.\n\nThe index parameter is an additional unique key,     allowing the module to cache mulitple arrays of the same type and shape. You should pass index=Symbol(@__MODULE__) to prevent collisions across modules. You may pass a tuple, eg. index=(Symbol(@__MODULE__), :otherkey)     to prevent collisions within a module.\n\n\n\n\n\narray(F::Type{<:Number}, shape::Tuple, index=nothing)\n\nSame as above but passing the type directly, rather than an instance of the type.\n\n\n\n\n\n","category":"function"}]
}
