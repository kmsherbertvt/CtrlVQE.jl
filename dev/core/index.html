<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Core Interface · CtrlVQE.jl</title><meta name="title" content="Core Interface · CtrlVQE.jl"/><meta property="og:title" content="Core Interface · CtrlVQE.jl"/><meta property="twitter:title" content="Core Interface · CtrlVQE.jl"/><meta name="description" content="Documentation for CtrlVQE.jl."/><meta property="og:description" content="Documentation for CtrlVQE.jl."/><meta property="twitter:description" content="Documentation for CtrlVQE.jl."/><meta property="og:url" content="https://kmsherbertvt.github.io/CtrlVQE.jl/core/"/><meta property="twitter:url" content="https://kmsherbertvt.github.io/CtrlVQE.jl/core/"/><link rel="canonical" href="https://kmsherbertvt.github.io/CtrlVQE.jl/core/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CtrlVQE.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">CtrlVQE</a></li><li><a class="tocitem" href="../basics/">Basic Implementations</a></li><li class="is-active"><a class="tocitem" href>Core Interface</a><ul class="internal"><li><a class="tocitem" href="#Integrations"><span>Integrations</span></a></li><li><a class="tocitem" href="#Signals"><span>Signals</span></a></li><li><a class="tocitem" href="#Devices"><span>Devices</span></a></li><li><a class="tocitem" href="#Evolutions"><span>Evolutions</span></a></li><li><a class="tocitem" href="#Cost-Functions"><span>Cost Functions</span></a></li></ul></li><li><a class="tocitem" href="../enums/">Enumerations</a></li><li><a class="tocitem" href="../modulars/">Modular Framework</a></li><li><a class="tocitem" href="../utils/">Utilities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Core Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Core Interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/kmsherbertvt/CtrlVQE.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/main/docs/src/core.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Core-Interface"><a class="docs-heading-anchor" href="#Core-Interface">Core Interface</a><a id="Core-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Interface" title="Permalink"></a></h1><ul><li><a href="#Integrations">Integrations</a></li><li><a href="#Signals">Signals</a></li><li><a href="#Devices">Devices</a></li><li><a href="#Evolutions">Evolutions</a></li><li><a href="#Cost-Functions">Cost Functions</a></li></ul><h2 id="Integrations"><a class="docs-heading-anchor" href="#Integrations">Integrations</a><a id="Integrations-1"></a><a class="docs-heading-anchor-permalink" href="#Integrations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Integrations" href="#CtrlVQE.Integrations"><code>CtrlVQE.Integrations</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Integrations</code></pre><p>Everything you need to know how to integrate over time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Integrations.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Integrations.IntegrationType" href="#CtrlVQE.Integrations.IntegrationType"><code>CtrlVQE.Integrations.IntegrationType</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntegrationType{F}</code></pre><p>Encapsulates a time-grid, used to decide how to integrate over time.</p><p><strong>Type Parameters</strong></p><ul><li><code>F</code> denotes the type for time values. Must be a real float.</li></ul><p><strong>Implementation</strong></p><p>Any concrete sub-type <code>G</code> must implement the <code>Prototypes</code> interface.</p><p>In addition, the following methods must be implemented.</p><ul><li><p><code>nsteps(::G)</code>: the total number of finite jumps within this time grid.</p><p>This is the maximum index of the <code>timeat</code> and <code>stepat</code> functions,       but it is NOT the length of the lattice, since the minimum index is 0.</p></li><li><p><code>timeat(::G, i::Int)</code>: time at index i (which may be zero)</p></li><li><p><code>stepat(::G, i::Int)</code>: stepsize at index i (which may be zero)</p><p>Let <span>$r$</span> be the number of steps, <span>$T$</span> be the duration,       and <span>$τ_i$</span> the step at index <span>$i$</span>.   Then <span>$∑_{i=0}^r τ_i = T$</span>.</p></li><li><p><code>Prototype(::Type{G}, r::Int; T, kwargs...)</code>:   construct a prototypical grid of type <code>G</code> with <code>r</code> steps.</p></li></ul><p><strong><code>AbstractVector</code> Interface</strong></p><p>This type implements the AbstractVector interface,     defined so that <code>grid[i] == timeat(grid, i)</code>, where <code>grid</code> is the IntegrationType. Note that <code>i</code> here starts from 0. The <code>collect</code> function produces a concrete vector, in which <code>i</code> starts from 1. The <code>lattice</code> function does the same thing, but permits an allocation-free signature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Integrations/__abstractinterface.jl#L1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Integrations.duration-Tuple{CtrlVQE.Integrations.IntegrationType}" href="#CtrlVQE.Integrations.duration-Tuple{CtrlVQE.Integrations.IntegrationType}"><code>CtrlVQE.Integrations.duration</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">duration(grid::IntegrationType)</code></pre><p>The total duration, ie. the last time point minus the first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Integrations/__concreteinterface.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Integrations.endtime-Tuple{CtrlVQE.Integrations.IntegrationType}" href="#CtrlVQE.Integrations.endtime-Tuple{CtrlVQE.Integrations.IntegrationType}"><code>CtrlVQE.Integrations.endtime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">endtime(grid::IntegrationType)</code></pre><p>Upper bound of a time integral.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Integrations/__concreteinterface.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Integrations.integrate" href="#CtrlVQE.Integrations.integrate"><code>CtrlVQE.Integrations.integrate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate(grid::IntegrationType{F}, Φ)</code></pre><p>Compute the integral <span>$∫_0^T Φ(t)⋅dt$</span>. <code>Φ</code> is a univariate scalar function of time, returning type F.</p><pre><code class="nohighlight hljs">integrate(grid::IntegrationType, f̄::AbstractVector)</code></pre><p>Treat the elements of <code>f̄</code> as the function evaluations <code>Φ(t)</code> above. The length of <code>f̄</code> must be <code>length(grid)</code> and its eltype must be real.</p><pre><code class="nohighlight hljs">integrate(grid::IntegrationType, Φ, f̄s::AbstractVector...)</code></pre><p>Compute the integral <span>$∫_0^T Φ(t, f1, f2...)⋅dt$</span>,     where <code>f1</code> is the value of <code>f̄s[1]</code> at the index corresponding to time <code>t</code>, etc. <code>Φ</code> is a multivariate scalar function,     of time and one argument for each f̄, returning type F. The length of each element in <code>f̄s</code> must be <code>length(grid)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Integrations/__concreteinterface.jl#L61-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Integrations.lattice-Tuple{CtrlVQE.Integrations.IntegrationType}" href="#CtrlVQE.Integrations.lattice-Tuple{CtrlVQE.Integrations.IntegrationType}"><code>CtrlVQE.Integrations.lattice</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lattice(grid::IntegrationType; result=nothing)</code></pre><p>A vector of all time points.</p><p>This is equivalent to <code>collect(grid)</code> except for the <code>result</code> kwarg,     which allows the caller to provide a pre-allocated array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Integrations/__concreteinterface.jl#L44-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Integrations.nsteps" href="#CtrlVQE.Integrations.nsteps"><code>CtrlVQE.Integrations.nsteps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nsteps(grid::IntegrationType)::Int</code></pre><p>The total number of finite jumps within this time grid.</p><p>This is the maximum index of the <code>timeat</code> and <code>stepat</code> functions,     but it is NOT the length of the lattice, since the minimum index is 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Integrations/__abstractinterface.jl#L41-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Integrations.starttime-Tuple{CtrlVQE.Integrations.IntegrationType}" href="#CtrlVQE.Integrations.starttime-Tuple{CtrlVQE.Integrations.IntegrationType}"><code>CtrlVQE.Integrations.starttime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">starttime(grid::IntegrationType)</code></pre><p>Lower bound of a time integral.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Integrations/__concreteinterface.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Integrations.stepat" href="#CtrlVQE.Integrations.stepat"><code>CtrlVQE.Integrations.stepat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stepat(grid::IntegrationType{F}, i::Int)::F</code></pre><p>The stepsize at index i (which may be zero).</p><p>Let <span>$r$</span> be the number of steps, <span>$T$</span> be the duration,     and <span>$τ_i$</span> the step at index <span>$i$</span>. Then <span>$∑_{i=0}^r τ_i = T$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Integrations/__abstractinterface.jl#L60-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Integrations.stepsize-Tuple{CtrlVQE.Integrations.IntegrationType}" href="#CtrlVQE.Integrations.stepsize-Tuple{CtrlVQE.Integrations.IntegrationType}"><code>CtrlVQE.Integrations.stepsize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stepsize(grid::IntegrationType)</code></pre><p>The average step size, ie. duration divided by number of steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Integrations/__concreteinterface.jl#L34-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Integrations.timeat" href="#CtrlVQE.Integrations.timeat"><code>CtrlVQE.Integrations.timeat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">timeat(grid::IntegrationType{F}, i::Int)::F</code></pre><p>The time at index i (which may be zero).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Integrations/__abstractinterface.jl#L52-L57">source</a></section></article><h2 id="Signals"><a class="docs-heading-anchor" href="#Signals">Signals</a><a id="Signals-1"></a><a class="docs-heading-anchor-permalink" href="#Signals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Signals" href="#CtrlVQE.Signals"><code>CtrlVQE.Signals</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Signals</code></pre><p>Time-dependent functions suitable for control signals with variational parameters.</p><p>The main motivation of this module     is to provide a common interface for analytical gradients and optimization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Signals.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Signals.ConstrainedSignal" href="#CtrlVQE.Signals.ConstrainedSignal"><code>CtrlVQE.Signals.ConstrainedSignal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConstrainedSignal(template::&lt;:ParametricSignal, constraints::Vector{Symbol})</code></pre><p>The parametric signal <code>template</code>, freezing all fields specified by <code>constraints</code>.</p><p>Frozen parameters are omitted from the <code>Parameters</code> interface. In other words, they do not appear in <code>Parameters.names</code> or <code>Parameters.values</code>,     and they are not mutated by <code>Parameters.bind!</code>.</p><p><strong>Example</strong></p><p>Say you have a <code>Trigonometric</code> signal sub-typing <code>ParametricSignal</code>,     where all fields amplitude <code>A</code>, phase <code>ϕ</code>, and frequency <code>ν</code>     are registered as variational parameters. You want to run an optimization where the frequency <code>ν</code> is fixed to 4.608. Rather than implementing a whole new ParametricSignal     identical except for a different implementation of the <code>parameters</code> function,     use a ConstrainedSignal:</p><pre><code class="nohighlight hljs">template = Trigonometric(0.0, 0.0, 4.608)   # Initialize A and ϕ to 0.0
signal = Constrained(template, :ν)</code></pre><p>Note that the <code>Constrained</code> constructor above is just syntactic sugar for:</p><pre><code class="nohighlight hljs">signal = ConstrainedSignal(template, [:ν])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Signals/__constrainedsignals.jl#L6-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Signals.ParametricSignal" href="#CtrlVQE.Signals.ParametricSignal"><code>CtrlVQE.Signals.ParametricSignal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParametricSignal{P,R}</code></pre><p>The super-type for simple user-defined SignalTypes.</p><p><strong>Type Parameters</strong></p><ul><li><code>P</code> denotes the type of all variational parameters. Must be a real float.</li><li><code>R</code> denotes the type of <span>$Ω(t)$</span> itself. May be any number type.</li></ul><p><strong>Implementation</strong></p><p>Concrete sub-types <code>S</code> must be mutable structs,     and all of its variational parameters     (as indicated by the <code>parameters</code> function) must have type <code>P</code>.</p><p>The following methods must be implemented:</p><ul><li><p><code>Signals.parameters(Ω::S)</code>:       returns a tuple of the fields in <code>S</code> treated as variational parameters.</p></li><li><p><code>Signals.valueat(Ω::S, t::Real)</code>:       the actual function <span>$Ω(t)$</span>. Must return a number of type <code>R</code>.</p></li><li><p><code>Signals.partial(k::Int, Ω::S, t::Real)</code>:       the partial derivative <span>$∂Ω/∂x_k$</span> evaluated at time <code>t</code>,       where <span>$x_k$</span> is Ω&#39;s k-th variational parameter       (ie. <code>Parameters.names(Ω)[k]</code>).       Must return a number of type <code>R</code>.</p></li><li><p><code>Base.string(Ω::S, names::AbstractVector{String})</code>:       a human-readable description of the signal,       inserting each element of <code>names</code> in the place of the corresponding parameter.   For example, complex constant signals may return a description like &quot;A + i B&quot;,       where <code>A</code> and <code>B</code> are the &quot;names&quot; given by the <code>names</code> argument.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Signals/__parametric__abstractinterface.jl#L3-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Signals.SignalType" href="#CtrlVQE.Signals.SignalType"><code>CtrlVQE.Signals.SignalType</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SignalType{P,R}</code></pre><p>Encapsulates a parametric and differntiable scalar function <span>$Ω(t)$</span>.</p><p><strong>Type Parameters</strong></p><ul><li><code>P</code> denotes the type of all variational parameters. Must be a real float.</li><li><code>R</code> denotes the type of <span>$Ω(t)$</span> itself. May be any number type.</li></ul><p><strong>Implementation</strong></p><p>Any concrete sub-type <code>S</code> must implement all the <code>Parameters</code> interface.</p><ul><li>In particular, <code>Parameters.values(Ω::S)</code> must return a vector of type <code>P</code>.</li><li>If you are trying to create your own signal type,   you <em>probably</em> want to implement a <code>ParametricSignal</code>,   which already has an implementation for the <code>Parameters</code> interface.</li></ul><p>In addition, the following methods must be implemented:</p><ul><li><p><code>valueat(Ω::S, t::Real)</code>:       the actual function <span>$Ω(t)$</span>. Must return a number of type <code>R</code>.</p></li><li><p><code>partial(i::Int, Ω::S, t::Real)</code>:       the partial derivative <span>$∂Ω/∂x_i$</span> evaluated at time <code>t</code>,       where <span>$x_i$</span> is Ω&#39;s i-th variational parameter (ie. <code>Parameters.names(Ω)[i]</code>).       Must return a number of type <code>R</code>.</p></li><li><p><code>Base.string(Ω::S, names::AbstractVector{String})</code>:       a human-readable description of the signal,       inserting each element of <code>names</code> in the place of the corresponding parameter.   For example, a complex constant signal might return a description like &quot;A + i B&quot;,       where <code>A</code> and <code>B</code> are the &quot;names&quot; given by the <code>names</code> argument.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Signals/__abstractinterface.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Signals.SignalType-Tuple{Any}" href="#CtrlVQE.Signals.SignalType-Tuple{Any}"><code>CtrlVQE.Signals.SignalType</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(signal::SignalType{P,R})(t)</code></pre><p>Syntactic sugar: if Ω is a <code>SignalType</code>, then <code>Ω(t)</code> gives <code>valueat(Ω,t)</code>.</p><p>The time <code>t</code> may be a scalar time, (abstract) vector of times, or an <code>IntegrationType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Signals/__concreteinterface.jl#L21-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.string-Tuple{CtrlVQE.Signals.SignalType, AbstractVector{String}}" href="#Base.string-Tuple{CtrlVQE.Signals.SignalType, AbstractVector{String}}"><code>Base.string</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.string(Ω::SignalType, names::AbstractVector{String})::String</code></pre><p>Substitutes the default name of each variational parameter for the ones in <code>names</code>.</p><p>Note that this is not the usual signature for Base.string!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Signals/__abstractinterface.jl#L57-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.string-Tuple{CtrlVQE.Signals.SignalType}" href="#Base.string-Tuple{CtrlVQE.Signals.SignalType}"><code>Base.string</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.string(Ω::SignalType)</code></pre><p>A human-readable string description of the signal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Signals/__concreteinterface.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Signals.Constrained-Tuple{CtrlVQE.Signals.ParametricSignal, Vararg{Symbol}}" href="#CtrlVQE.Signals.Constrained-Tuple{CtrlVQE.Signals.ParametricSignal, Vararg{Symbol}}"><code>CtrlVQE.Signals.Constrained</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Constrained(template::ParametricSignal, constraints::Symbol...)</code></pre><p>Construct a <code>ConstrainedSignal</code> from a <code>ParametricSignal</code> and the fields to freeze.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Signals/__constrainedsignals.jl#L50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Signals.parameters" href="#CtrlVQE.Signals.parameters"><code>CtrlVQE.Signals.parameters</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parameters(::S&lt;:ParametricSignal{P,R})::Tuple{Symbol...}</code></pre><p>Returns a tuple of the fields in <code>S</code> treated as variational parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Signals/__parametric__abstractinterface.jl#L41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Signals.parametertype-Union{Tuple{CtrlVQE.Signals.SignalType{P, R}}, Tuple{R}, Tuple{P}} where {P, R}" href="#CtrlVQE.Signals.parametertype-Union{Tuple{CtrlVQE.Signals.SignalType{P, R}}, Tuple{R}, Tuple{P}} where {P, R}"><code>CtrlVQE.Signals.parametertype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parametertype(signal)</code></pre><p>Returns the number type for parameters in <code>signal</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Signals/__concreteinterface.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Signals.partial" href="#CtrlVQE.Signals.partial"><code>CtrlVQE.Signals.partial</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">partial(k::Int, signal::SignalType{P,R}, t::Real)::R</code></pre><p>The partial derivative <span>$∂Ω/∂x_k|_t$</span>.</p><p>Here <span>$x_k$</span> is the signal&#39;s k-th variational parameter     (ie. <code>Parameters.names(signal)[k]</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Signals/__abstractinterface.jl#L46-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Signals.partial-Union{Tuple{R}, Tuple{P}, Tuple{Int64, CtrlVQE.Signals.SignalType{P, R}, CtrlVQE.Integrations.IntegrationType}} where {P, R}" href="#CtrlVQE.Signals.partial-Union{Tuple{R}, Tuple{P}, Tuple{Int64, CtrlVQE.Signals.SignalType{P, R}, CtrlVQE.Integrations.IntegrationType}} where {P, R}"><code>CtrlVQE.Signals.partial</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">partial(i, signal, t̄; result=nothing)</code></pre><p>Evaluate the partial at each point in the time lattice defined by an integration.</p><p><strong>Parameters</strong></p><ul><li>i: indexes which parameter to take the partial derivative with respect to</li><li>signal: the <code>SignalType</code>.</li><li>grid: an <code>IntegrationType</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li>result: if provided, a pre-allocated array to store the returned vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Signals/__concreteinterface.jl#L69-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Signals.returntype-Union{Tuple{CtrlVQE.Signals.SignalType{P, R}}, Tuple{R}, Tuple{P}} where {P, R}" href="#CtrlVQE.Signals.returntype-Union{Tuple{CtrlVQE.Signals.SignalType{P, R}}, Tuple{R}, Tuple{P}} where {P, R}"><code>CtrlVQE.Signals.returntype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">returntype(signal)</code></pre><p>Returns the number type for function values of <code>signal</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Signals/__concreteinterface.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Signals.valueat" href="#CtrlVQE.Signals.valueat"><code>CtrlVQE.Signals.valueat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">valueat(signal::SignalType{P,R}, t::Real)::R</code></pre><p>The signal at time <code>t</code>, ie. <span>$Ω(t)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Signals/__abstractinterface.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Signals.valueat-Union{Tuple{R}, Tuple{P}, Tuple{CtrlVQE.Signals.SignalType{P, R}, CtrlVQE.Integrations.IntegrationType}} where {P, R}" href="#CtrlVQE.Signals.valueat-Union{Tuple{R}, Tuple{P}, Tuple{CtrlVQE.Signals.SignalType{P, R}, CtrlVQE.Integrations.IntegrationType}} where {P, R}"><code>CtrlVQE.Signals.valueat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">valueat(signal, grid; result=nothing)</code></pre><p>Evaluate the signal at each point in the time lattice defined by an integration.</p><p><strong>Parameters</strong></p><ul><li>signal: the <code>SignalType</code>.</li><li>grid: an <code>IntegrationType</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li>result: if provided, a pre-allocated array to store the returned vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Signals/__concreteinterface.jl#L43-L55">source</a></section></article><h2 id="Devices"><a class="docs-heading-anchor" href="#Devices">Devices</a><a id="Devices-1"></a><a class="docs-heading-anchor-permalink" href="#Devices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices" href="#CtrlVQE.Devices"><code>CtrlVQE.Devices</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Devices</code></pre><p><em>In silico</em> representation of quantum devices, in which quantum states evolve in time.</p><p>In this package,     the &quot;static&quot; components (e.g., qubit frequencies, couplings, etc.)     and the &quot;drive&quot; components (e.g., control signal, variational parameters, etc.)     are <em>all</em> integrated into a single <code>DeviceType</code> object. All you need to know how a quantum state <code>ψ</code> evolves up time <code>T</code> is in the device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.DeviceType" href="#CtrlVQE.Devices.DeviceType"><code>CtrlVQE.Devices.DeviceType</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DeviceType{F}</code></pre><p>Encapuslates a device Hamiltonian, under which quantum computational states evolve.</p><p><strong>Type Parameters</strong></p><ul><li><code>F</code>: the float type associated with a device</li></ul><p><strong>Implementation</strong></p><p>Any concrete sub-type <code>D</code> must implement the <code>Prototypes</code> and <code>Parameters</code> interfaces.</p><ul><li>In particular, if any static operators in your device depend on variational parameters,   you should consult the &quot;Note on Caching&quot; below.</li></ul><p>In addition, all methods in the following sections must be implemented.</p><ul><li>Counting methods</li><li>Algebra methods</li><li>Operator methods</li><li>Gradient methods</li><li>Benchmarking methods</li></ul><p>If your device&#39;s drive channels are all local (acting on one qubit at a time),     you should implement a <code>LocallyDrivenDevice</code>,     which has a few extra requirements.</p><p><strong>Counting methods:</strong></p><ul><li><code>nqubits(::D)</code>: the number of qubits in the device - call this <code>n</code>.</li><li><code>nlevels(::D)</code>: the number of physical levels in each &quot;qubit&quot; - call this <code>m</code>.</li><li><code>ndrives(::D)</code>: the number of distinct drive channels.</li><li><code>ngrades(::D)</code>: the number of distinct gradient operators.</li><li><code>noperators(::D)</code>: the number of operators used to define an algebra for each &quot;qubit&quot;.</li></ul><p>Each of these methods returns an integer.</p><p><strong>Algebra methods:</strong></p><ul><li><code>localalgebra(::D)</code>: a 4d array ā   where ā[:,:,σ,q] is the σ&#39;th algebraic operator on qubit q, in the bare basis.</li></ul><p>This method should define <code>result=nothing</code> as a keyword argument;     when passed, use it as the array to store your result in.</p><p><strong>Operator methods:</strong></p><ul><li><p><code>qubithamiltonian(::D, ā, q::Int)</code>:       the static components of the device Hamiltonian local to qubit q.</p></li><li><p><code>staticcoupling(::D, ā)</code>:       the static components of the device Hamiltonian nonlocal to any one qubit.</p></li><li><p><code>driveoperator(::D, ā, i::Int, t::Real)</code>:       the distinct drive operator for channel <code>i</code> at time <code>t</code></p></li><li><p><code>gradeoperator(::D, ā, j::Int, t::Real)</code>:       the distinct gradient operator indexed by <code>j</code> at time <code>t</code></p></li></ul><p>Each of these methods should define <code>result=nothing</code> as a keyword argument;     when passed, use it as the array to store your result in. When <code>result</code> is not passed, you should return a new array of type <code>Complex{eltype(D)}</code>. Aside from this, do your best to minimize allocations.</p><p>Each of these methods takes a 4darray <code>ā</code>, indexed as described in <code>localalgebra</code>. For example, for an algebra defined in terms of bosonic ladder operators,     <span>$\hat a_q$</span> might be accessed with <code>ā[:,:,1,q]</code>     and <span>$\hat a_q^\dagger$</span> with <code>ā[:,:,1,q]&#39;</code>. For an algebra defined in terms of Pauli operators,     <span>$X_q$</span> might be accessed with <code>ā[:,:,1,q]</code>,     <span>$Y_q$</span> with <code>ā[:,:,2,q]</code>, and <span>$Z_q$</span> with <code>ā[:,:,3,q]</code>.</p><p>Usually, each <code>ā[:,:,σ,q]</code> is defined on the full Hilbert space (ie. <code>m^n × m^n</code>),     but sometimes the code exploits a simple tensor structure     by passing in local <code>m × m</code> operators instead,     so do not assume a specific size a priori. Do NOT modify these operators, as they are usually drawn from a cache.</p><p><strong>Gradient methods:</strong></p><ul><li><code>gradient(::D, grid::Integrations.IntegrationType, ϕ̄)</code>:       the gradient vector for each variational parameter in the device.</li></ul><p>Each partial is generally an integral over at least one gradient signal. The argument <code>grid</code> identifies the temporal lattice on which ϕ̄ is defined. The argument <code>ϕ̄</code> is a 2d array; <code>ϕ̄[:,:,j]</code> contains the jth gradient signal     <span>$ϕ_j(t)$</span> evaluated at each point in <code>grid</code>.</p><p>This method should define <code>result=nothing</code> as a keyword argument;     when passed, use it as the array to store your result in.</p><p><strong>Notes on Caching</strong></p><p>This module uses the <code>Memoization</code> package to cache some arrays as they are calculated.</p><p>This does not apply to any method which depends on an absolute time t,     though it does apply to methods depending only on a relative time τ. For example, the propagator for a static Hamiltonian is cached,     but not one for a drive Hamiltonian.</p><p>Usually, variational parameters only affect time-dependent methods,     but if any of your device&#39;s static operators do depend on a variational parameter,     you should be careful to empty the cache when <code>Parameters.bind!</code> is called.</p><p>You can completely clear everything in the cache with:</p><pre><code class="nohighlight hljs">Memoization.empty_all_caches!()</code></pre><p>Alternatively, selectively clear caches for affected functions via:</p><pre><code class="nohighlight hljs">Memoization.empty_cache!(fn)</code></pre><p>I don&#39;t know if it&#39;s possible to selectively clear cached values for specific methods. If it can be done, it would require obtaining the actual <code>Dict</code>     being used as a cache for a particular function,     figuring out exactly how that cache is indexed,     and manually removing elements matching your targeted method signature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__abstractinterface.jl#L3-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.LocallyDrivenDevice" href="#CtrlVQE.Devices.LocallyDrivenDevice"><code>CtrlVQE.Devices.LocallyDrivenDevice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LocallyDrivenDevice</code></pre><p>Super-type for device objects whose drive channels act locally on individual qubits.</p><p>Inherit from this type if your <code>driveoperator</code> and <code>gradeoperator</code> methods     depend only on a single qubit, i.e. <code>ā[:,:,:,q]</code>. This enables more efficient propagation methods which exploit a tensor product structure.</p><p><strong>Implementation</strong></p><p>Any concrete sub-type <code>D</code> must implement     <em>everything</em> required in the <code>DeviceType</code> interface,     so consult the documentation for <code>DeviceType</code> carefully.</p><p>In addition, the following methods must be implemented:</p><ul><li><code>drivequbit(::D, i::Int)</code>: index of the qubit on which channel <code>i</code> is applied.</li><li><code>gradequbit(::D, j::Int)</code>: index of the qubit associated with the jth gradient operator.</li></ul><p>It&#39;s usually trivial to infer the channel index i associated with each gradient operator,     in which case <code>gradequbit(device, j) = drivequbit(device, i)</code>,     but this is left as an implementation detail.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__local__abstractinterface.jl#L3-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.basisrotation-Tuple{CtrlVQE.Bases.BasisType, CtrlVQE.Bases.BasisType, CtrlVQE.Devices.DeviceType}" href="#CtrlVQE.Devices.basisrotation-Tuple{CtrlVQE.Bases.BasisType, CtrlVQE.Bases.BasisType, CtrlVQE.Devices.DeviceType}"><code>CtrlVQE.Devices.basisrotation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">basisrotation(tgt::Bases.BasisType, src::Bases.BasisType, device::DeviceType)</code></pre><p>Calculate the basis rotation <code>U</code> which transforms <span>$|ψ_{src}⟩ → |ψ_{tgt}⟩ = U|ψ_{src}⟩$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__concreteinterface.jl#L169-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.braket-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, AbstractVector, AbstractVector}" href="#CtrlVQE.Devices.braket-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, AbstractVector, AbstractVector}"><code>CtrlVQE.Devices.braket</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">braket(op, device[, basis], ψ1, ψ2)</code></pre><p>The braket of an operator describing a <code>device</code> with respect to states <code>ψ1</code> and <code>ψ2</code>.</p><p>If <span>$A$</span> is the operator specified by <code>op</code>, this method calculates <span>$⟨ψ1|A|ψ2⟩$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>op::Operators.OperatorType</code>: which operator to estimate (eg. static, drive, etc.).</li><li><code>device::DeviceType</code>: which device is being described.</li><li><code>basis::Bases.BasisType</code>: which basis the state <code>ψ</code> is represented in.       Defaults to <code>Bases.BARE</code> when omitted.</li><li><code>ψ1</code>, <code>ψ2</code>: Statevectors defined over the full Hilbert space of the device.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__opfun__brakets.jl#L41-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.dress-Tuple{CtrlVQE.Devices.DeviceType}" href="#CtrlVQE.Devices.dress-Tuple{CtrlVQE.Devices.DeviceType}"><code>CtrlVQE.Devices.dress</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dress(device::DeviceType)</code></pre><p>Diagonalize the static Hamiltonian and apply some post-processing     to define the so-called <code>DRESSED</code> basis.</p><p>Compute the vector of eigenvalues <code>Λ</code> and the rotation matrix <code>U</code> for a given basis.</p><p><code>U</code> is an operator acting on the global Hilbert space of the device.</p><p>The result is packed into a <code>LinearAlgebra.Eigen</code> object. It may be unpacked directly into a vector eigenvalues Λ and a matrix of eigenvectors U by</p><pre><code class="nohighlight hljs">Λ, U = dress(device)</code></pre><p>Alternatively:</p><pre><code class="nohighlight hljs">ΛU = dress(device)
Λ = ΛU.values
U = ΛU.vectors</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__concreteinterface.jl#L100-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.driveoperator" href="#CtrlVQE.Devices.driveoperator"><code>CtrlVQE.Devices.driveoperator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">driveoperator(device::DeviceType, ā, i::Int, t::Real; result=nothing)</code></pre><p>The distinct drive operator for channel <code>i</code> at time <code>t</code>.</p><p>This method is a function of algebraic operators given by <code>ā[:,:,σ,q]</code>,     constructed the <code>globalalgebra</code> method. If <code>device</code> is a <code>LocallyDrivenDevice</code>,     <code>ā</code> may also have been constructed from the <code>localalgebra</code> method.</p><p>The array is stored in <code>result</code> if provided. If <code>result</code> is not provided, the array is of type <code>Complex{eltype(device)}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__abstractinterface.jl#L223-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.drivequbit" href="#CtrlVQE.Devices.drivequbit"><code>CtrlVQE.Devices.drivequbit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">drivequbit(device, i::Int)::Int</code></pre><p>Index of the qubit on which channel <code>i</code> is applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__local__abstractinterface.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.evolve!-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, Real, AbstractVecOrMat{&lt;:Complex{&lt;:AbstractFloat}}}" href="#CtrlVQE.Devices.evolve!-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, Real, AbstractVecOrMat{&lt;:Complex{&lt;:AbstractFloat}}}"><code>CtrlVQE.Devices.evolve!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evolve!(op, device[, basis], t, ψ)</code></pre><p>Propagate a state <code>ψ</code> by a time <code>t</code> under the Hermitian <code>op</code> describing a <code>device</code>.</p><p>This function is identical to <code>propagate!</code>,     except that the cache is not used for intermediate propagator matrices,     and that it is undefined for time-dependent operators. Look to the <code>Evolutions</code> module for algorithms compatible with time-dependence!</p><p><strong>Arguments</strong></p><ul><li><code>op::Operators.OperatorType</code>: which operator to evolve under (eg. static, drive, etc.).</li><li><code>device::DeviceType</code>: which device is being described.</li><li><code>basis::Bases.BasisType</code>: which basis the state <code>ψ</code> is represented in.       Defaults to <code>Bases.BARE</code> when omitted.</li><li><code>t::Real</code>: the amount to move forward in time by.</li><li><code>ψ</code>: Either a vector or a matrix, defined over the full Hilbert space of the device.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__opfun__evolution.jl#L140-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.evolver-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, Real}" href="#CtrlVQE.Devices.evolver-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, Real}"><code>CtrlVQE.Devices.evolver</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evolver(op, device[, basis], t; kwargs...)</code></pre><p>A unitary propagator describing evolution under a Hermitian operator for a time t.</p><p>This function is identical to <code>propagator</code>,     except that the argument <code>t</code> is considered an absolute time so it is never cached,     and that it is undefined for time-dependent operators. It exists solely to perform rotating-frame rotations at every time-step     without worrying about over-caching.</p><p><strong>Arguments</strong></p><ul><li><code>op::Operators.OperatorType</code>: which operator to evolve under (eg. static, drive, etc.).</li><li><code>device::DeviceType</code>: which device is being described.</li><li><code>basis::Bases.BasisType</code>: which basis the operator will be represented in.       Defaults to <code>Bases.BARE</code> when omitted.</li><li><code>t::Real</code>: the amount to move forward in time by.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>result</code>: a pre-allocated array of compatible type and shape, used to store the result.</p><p>Omitting <code>result</code> returns an array of type <code>Complex{eltype(device)}</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__opfun__evolution.jl#L10-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.expectation-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, AbstractVector}" href="#CtrlVQE.Devices.expectation-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, AbstractVector}"><code>CtrlVQE.Devices.expectation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">expectation(op, device[, basis], ψ)</code></pre><p>The expectation value of an operator describing a <code>device</code> with respect to the state <code>ψ</code>.</p><p>If <span>$A$</span> is the operator specified by <code>op</code>, this method calculates <span>$⟨ψ|A|ψ⟩$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>op::Operators.OperatorType</code>: which operator to estimate (eg. static, drive, etc.).</li><li><code>device::DeviceType</code>: which device is being described.</li><li><code>basis::Bases.BasisType</code>: which basis the state <code>ψ</code> is represented in.       Defaults to <code>Bases.BARE</code> when omitted.</li><li><code>ψ</code>: A statevector defined over the full Hilbert space of the device.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__opfun__brakets.jl#L10-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.globalalgebra" href="#CtrlVQE.Devices.globalalgebra"><code>CtrlVQE.Devices.globalalgebra</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">globalalgebra(device::DeviceType[, basis::Bases.BasisType])</code></pre><p>A globalized version of the matrix list defined by <code>localalgebra</code>.</p><p>That is, each operator <code>ā[:,:,q,σ]</code> is an N⨯N matrix acting on the whole Hilbert space,     rather than an m⨯m matrix acting on the space of a single qubit.</p><p>(N is used throughout the docs for <code>nstates(device)</code> and m for <code>nlevels(device)</code>.)</p><p>The array is stored in <code>result</code> or, if not provided, returned from a cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__concreteinterface.jl#L53-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.gradeoperator" href="#CtrlVQE.Devices.gradeoperator"><code>CtrlVQE.Devices.gradeoperator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradeoperator(device::DeviceType, ā, j::Int, t::Real; result=nothing)</code></pre><p>The distinct gradient operator indexed by <code>j</code> at time <code>t</code>.</p><p>I have defined the &quot;gradient operator&quot; <span>$Â_j$</span> as the Hermitian operator     for which the jth gradient signal is <span>$ϕ_j = ⟨λ|(iÂ_j)|ψ⟩ + h.t.$</span>.</p><p>This method is a function of algebraic operators given by <code>ā[:,:,σ,q]</code>,     constructed the <code>globalalgebra</code> method. If <code>device</code> is a <code>LocallyDrivenDevice</code>,     <code>ā</code> may also have been constructed from the <code>localalgebra</code> method.</p><p>The array is stored in <code>result</code> if provided. If <code>result</code> is not provided, the array is of type <code>Complex{eltype(device)}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__abstractinterface.jl#L239-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.gradequbit" href="#CtrlVQE.Devices.gradequbit"><code>CtrlVQE.Devices.gradequbit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradequbit(device, j::Int)::Int</code></pre><p>Index of the qubit associated with the jth gradient operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__local__abstractinterface.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.gradient" href="#CtrlVQE.Devices.gradient"><code>CtrlVQE.Devices.gradient</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradient(::DeviceType, grid::Integrations.IntegrationType, ϕ; result=nothing)</code></pre><p>The gradient vector of partials for each variational parameter in the device.</p><p>Each partial is generally an integral over at least one gradient signal. The argument <code>grid</code> identifies the temporal lattice on which ϕ is defined. The argument <code>ϕ</code> is a 2d array; <code>ϕ[:,j]</code> contains the jth gradient signal     <span>$ϕ_j(t)$</span> evaluated at each point in <code>grid</code>.</p><p>The array is stored in <code>result</code> if provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__abstractinterface.jl#L258-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.localalgebra" href="#CtrlVQE.Devices.localalgebra"><code>CtrlVQE.Devices.localalgebra</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">localalgebra(::DeviceType; result=nothing)</code></pre><p>Construct a 4d array ā representing all operators defining an algebra for all qubits.</p><p>The matrix ā[:,:,σ,q] is a local operator acting on the space of a single qubit     (meaning it is an <code>m⨯m</code> matrix, if <code>m</code> is the result of <code>nlevels(device)</code>).</p><p>The array is stored in <code>result</code> or, if not provided, returned from a cache. If <code>result</code> is not provided, the array is of type <code>Complex{eltype(device)}</code>.</p><p><strong>Implementation</strong></p><p>To use the cache, simply include as the first line:</p><pre><code class="nohighlight hljs">isnothing(result) &amp;&amp; return _localalgebra(device)</code></pre><p>If there is nothing yet in the cache,     the <code>_localalgebra</code> function will simply call your method again,     but with an empty array passed as <code>result</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__abstractinterface.jl#L163-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.localdriveoperators-Tuple{CtrlVQE.Devices.LocallyDrivenDevice, Real}" href="#CtrlVQE.Devices.localdriveoperators-Tuple{CtrlVQE.Devices.LocallyDrivenDevice, Real}"><code>CtrlVQE.Devices.localdriveoperators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">localdriveoperators(device, t; kwargs...)</code></pre><p>A matrix list <code>v̄</code>, where <code>v̄[:,:,q]</code> represents     a sum of all drives acting on qubit <code>q</code> in the bare basis.</p><p><strong>Arguments</strong></p><ul><li><code>device::LocallyDrivenDevice</code>: which device is being described.</li><li><code>t::Real</code>: the time each drive operator is evaluated at.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>result</code>: a pre-allocated array of compatible type and shape, used to store the result.</p><p>Omitting <code>result</code> will return an array with type <code>Complex{eltype(device)}</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__local__concreteinterface.jl#L9-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.localdrivepropagators-Tuple{CtrlVQE.Devices.LocallyDrivenDevice, Real, Real}" href="#CtrlVQE.Devices.localdrivepropagators-Tuple{CtrlVQE.Devices.LocallyDrivenDevice, Real, Real}"><code>CtrlVQE.Devices.localdrivepropagators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">localdrivepropagators(device, τ, t; kwargs...)</code></pre><p>A matrix list <code>ū</code>, where <code>ū[:,:,q]</code> is the propagator for a local drive term.</p><p><strong>Arguments</strong></p><ul><li><code>device::LocallyDrivenDevice</code>: which device is being described.</li><li><code>τ::Real</code>: the amount to move forward in time by.       Note that the propagation is only approximate for time-dependent operators.       The smaller <code>τ</code> is, the more accurate the approximation.</li><li><code>t::Real</code>: the time each drive operator is evaluated at.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>result</code>: a pre-allocated array of compatible type and shape, used to store the result.</p><p>Omitting <code>result</code> will return an array with type <code>Complex{eltype(device)}</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__local__concreteinterface.jl#L46-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.localqubitevolvers-Tuple{CtrlVQE.Devices.DeviceType, Real}" href="#CtrlVQE.Devices.localqubitevolvers-Tuple{CtrlVQE.Devices.DeviceType, Real}"><code>CtrlVQE.Devices.localqubitevolvers</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">localqubitevolvers(device, τ; kwargs...)</code></pre><p>A matrix list <code>ū</code>, where each <code>ū[:,:,q]</code> is a propagator for a local qubit hamiltonian.</p><p>This function is identical to <code>localqubitevolvers</code>,     except that the argument <code>t</code> is considered an absolute time so it is never cached.</p><p><strong>Arguments</strong></p><ul><li><code>device::DeviceType</code>: which device is being described.</li><li><code>τ::Real</code>: the amount to move forward in time by.       Note that the propagation is only approximate for time-dependent operators.       The smaller <code>τ</code> is, the more accurate the approximation.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>result</code>: a pre-allocated array of compatible type and shape, used to store the result.</p><p>Omitting <code>result</code> will return an array of type <code>Complex{eltype(device)}</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__opfun__evolution.jl#L105-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.localqubitoperators-Tuple{CtrlVQE.Devices.DeviceType}" href="#CtrlVQE.Devices.localqubitoperators-Tuple{CtrlVQE.Devices.DeviceType}"><code>CtrlVQE.Devices.localqubitoperators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">localqubitoperators(device[, basis]; kwargs...)</code></pre><p>A matrix list <code>h̄</code>, where each <code>h̄[:,:,q]</code> represents     a local qubit hamiltonian in the bare basis.</p><p><strong>Arguments</strong></p><ul><li><code>device::DeviceType</code>: which device is being described.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>result</code>: a pre-allocated array of compatible type and shape, used to store the result.</p><p>Omitting <code>result</code> will return a cached result, with type <code>Complex{eltype(device)}</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__opfun__operator.jl#L180-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.localqubitpropagators-Tuple{CtrlVQE.Devices.DeviceType, Real}" href="#CtrlVQE.Devices.localqubitpropagators-Tuple{CtrlVQE.Devices.DeviceType, Real}"><code>CtrlVQE.Devices.localqubitpropagators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">localqubitpropagators(device, τ; kwargs...)</code></pre><p>A matrix list <code>ū</code>, where each <code>ū[:,:,q]</code> is a propagator     for a local qubit hamiltonian in the bare basis.</p><p><strong>Arguments</strong></p><ul><li><code>device::DeviceType</code>: which device is being described.</li><li><code>τ::Real</code>: the amount to move forward in time by.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>result</code>: a pre-allocated array of compatible type and shape, used to store the result.</p><p>Omitting <code>result</code> will return a cached result, with type <code>Complex{eltype(device)}</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__opfun__propagation.jl#L114-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.ndrives" href="#CtrlVQE.Devices.ndrives"><code>CtrlVQE.Devices.ndrives</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ndrives(device::DeviceType)::Int</code></pre><p>The number of distinct drive channels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__abstractinterface.jl#L123-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.ngrades" href="#CtrlVQE.Devices.ngrades"><code>CtrlVQE.Devices.ngrades</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ngrades(device::DeviceType)::Int</code></pre><p>The number of distinct gradient operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__abstractinterface.jl#L131-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.nlevels" href="#CtrlVQE.Devices.nlevels"><code>CtrlVQE.Devices.nlevels</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nlevels(device::DeviceType)::Int</code></pre><p>The number of physical levels in each &quot;qubit&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__abstractinterface.jl#L139-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.noperators" href="#CtrlVQE.Devices.noperators"><code>CtrlVQE.Devices.noperators</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">noperators(device::DeviceType)::Int</code></pre><p>The number of operators used to define an algebra for each &quot;qubit&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__abstractinterface.jl#L155-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.nqubits" href="#CtrlVQE.Devices.nqubits"><code>CtrlVQE.Devices.nqubits</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nqubits(device::DeviceType)::Int</code></pre><p>The number of qubits in the device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__abstractinterface.jl#L147-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.nstates-Tuple{CtrlVQE.Devices.DeviceType}" href="#CtrlVQE.Devices.nstates-Tuple{CtrlVQE.Devices.DeviceType}"><code>CtrlVQE.Devices.nstates</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nstates(device::DeviceType)</code></pre><p>The total number of states in the physical Hilbert space of the device.</p><p>(This is as opposed to <code>nlevels(device)</code>,     the number of states in the physical Hilbert space of a single independent qubit.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__concreteinterface.jl#L40-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.operator-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType}" href="#CtrlVQE.Devices.operator-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType}"><code>CtrlVQE.Devices.operator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">operator(op, device[, basis]; kwargs...)</code></pre><p>A Hermitian operator describing a <code>device</code>, represented in the given <code>basis</code>.</p><p>For example, to construct the static Hamiltonian of a device in the dressed basis,     call <code>operator(Operators.STATIC, device, Bases.DRESSED)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>op::Operators.OperatorType</code>: which operator to construct (eg. static, drive, etc.).</li><li><code>device::DeviceType</code>: which device is being described.</li><li><code>basis::Bases.BasisType</code>: which basis the operator will be represented in.       Defaults to <code>Bases.BARE</code> when omitted.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>result</code>: a pre-allocated array of compatible type and shape, used to store the result.</p><p>Omitting <code>result</code> returns an array of type <code>Complex{eltype(device)}</code>.   For static operators only, omitting <code>result</code> will return a cached result.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__opfun__operator.jl#L15-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.propagate!-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, Real, AbstractVecOrMat{&lt;:Complex{&lt;:AbstractFloat}}}" href="#CtrlVQE.Devices.propagate!-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, Real, AbstractVecOrMat{&lt;:Complex{&lt;:AbstractFloat}}}"><code>CtrlVQE.Devices.propagate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">propagate!(op, device[, basis], τ, ψ)</code></pre><p>Propagate a state <code>ψ</code> by a small time <code>τ</code> under the Hermitian <code>op</code> describing a <code>device</code>.</p><p><strong>Arguments</strong></p><ul><li><code>op::Operators.OperatorType</code>: which operator to evolve under (eg. static, drive, etc.).</li><li><code>device::DeviceType</code>: which device is being described.</li><li><code>basis::Bases.BasisType</code>: which basis the state <code>ψ</code> is represented in.       Defaults to <code>Bases.BARE</code> when omitted.</li><li><code>τ::Real</code>: the amount to move forward in time by.       Note that the propagation is only approximate for time-dependent operators.       The smaller <code>τ</code> is, the more accurate the approximation.</li><li><code>ψ</code>: Either a vector or a matrix, defined over the full Hilbert space of the device.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__opfun__propagation.jl#L154-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.propagator-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, Real}" href="#CtrlVQE.Devices.propagator-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.DeviceType, Real}"><code>CtrlVQE.Devices.propagator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">propagator(op, device[, basis], τ; kwargs...)</code></pre><p>A unitary propagator describing evolution under a Hermitian operator for a small time τ.</p><p><strong>Arguments</strong></p><ul><li><code>op::Operators.OperatorType</code>: which operator to evolve under (eg. static, drive, etc.).</li><li><code>device::DeviceType</code>: which device is being described.</li><li><code>basis::Bases.BasisType</code>: which basis the operator will be represented in.       Defaults to <code>Bases.BARE</code> when omitted.</li><li><code>τ::Real</code>: the amount to move forward in time by.       Note that the propagation is only approximate for time-dependent operators.       The smaller <code>τ</code> is, the more accurate the approximation.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>result</code>: a pre-allocated array of compatible type and shape, used to store the result.</p><p>Omitting <code>result</code> returns an array of type <code>Complex{eltype(device)}</code>.   For static operators only, omitting <code>result</code> will return a cached result.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__opfun__propagation.jl#L12-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.qubithamiltonian" href="#CtrlVQE.Devices.qubithamiltonian"><code>CtrlVQE.Devices.qubithamiltonian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qubithamiltonian(device::DeviceType, ā, q::Int; result=nothing)</code></pre><p>The static components of the device Hamiltonian local to qubit <code>q</code>.</p><p>This method is a function of algebraic operators given by <code>ā[:,:,σ,q]</code>,     constructed by either the <code>localalgebra</code> or <code>globalalgebra</code> methods.</p><p>The array is stored in <code>result</code> if provided. If <code>result</code> is not provided, the array is of type <code>Complex{eltype(device)}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__abstractinterface.jl#L195-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Devices.staticcoupling" href="#CtrlVQE.Devices.staticcoupling"><code>CtrlVQE.Devices.staticcoupling</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">staticcoupling(device::DeviceType, ā, q::Int; result=nothing)</code></pre><p>The static components of the device Hamiltonian nonlocal to any one qubit.</p><p>This method is a function of algebraic operators given by <code>ā[:,:,σ,q]</code>,     constructed the <code>globalalgebra</code> method.</p><p>The array is stored in <code>result</code> if provided. If <code>result</code> is not provided, the array is of type <code>Complex{eltype(device)}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Devices/__abstractinterface.jl#L209-L220">source</a></section></article><h2 id="Evolutions"><a class="docs-heading-anchor" href="#Evolutions">Evolutions</a><a id="Evolutions-1"></a><a class="docs-heading-anchor-permalink" href="#Evolutions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Evolutions" href="#CtrlVQE.Evolutions"><code>CtrlVQE.Evolutions</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Evolutions</code></pre><p>Algorithms to run time evolution, and related constructs like gradient signals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Evolutions.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Evolutions.EvolutionType" href="#CtrlVQE.Evolutions.EvolutionType"><code>CtrlVQE.Evolutions.EvolutionType</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EvolutionType</code></pre><p>Defines a particular algorithm for performing time evolution.</p><p><strong>Implementation</strong></p><p>Any concrete sub-type <code>A</code> must implement the following methods:</p><ul><li><p><code>workbasis(::A)</code>: which Bases.BasisType the evolution algorithm uses</p></li><li><p><code>evolve!(::A, device, grid, ψ; callback=nothing)</code>:   evolve a state ψ in-place on a time grid</p></li></ul><p>If possible, it should also implement:</p><ul><li>`gradientsignals(::A, device, basis, grid, ψ0, r, Ō; kwargs...):   compute the gradient signals of a device corresponding to multiple observables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Evolutions/__abstractinterface.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Evolutions.evolve" href="#CtrlVQE.Evolutions.evolve"><code>CtrlVQE.Evolutions.evolve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evolve(evolution, device, grid, ψ0; result=nothing, kwargs...)
evolve(evolution, device, basis, grid, ψ0; result=nothing, kwargs...)</code></pre><p>Evolve a quantum computational state under a device Hamiltonian.</p><p>If <code>basis</code> is provided, <code>ψ0</code> is taken to be represented in that basis. Otherwise, the workbasis of <code>evolution</code> is assumed.</p><p>This method simply copies <code>ψ0</code> (to <code>result</code> if provided, or else to a new array),     then calls the mutating function <code>evolve!</code> on the copy. Please see <code>evolve!</code> for detailed documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Evolutions/__concreteinterface.jl#L10-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Evolutions.evolve!" href="#CtrlVQE.Evolutions.evolve!"><code>CtrlVQE.Evolutions.evolve!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evolve!(evolution, device, grid, ψ; callback=nothing)
evolve!(evolution, device, basis, grid, ψ; callback=nothing)</code></pre><p>Evolve a quantum computational state in-place under a device Hamiltonian.</p><p>This method both mutates and returns <code>ψ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>evolution::EvolutionType</code>: which evolution algorithm to use.</li><li><code>device::Devices.DeviceType</code>: specifies which Hamiltonian to evolve under.</li><li><code>basis::Bases.BasisType</code>: which basis <code>ψ</code> is represented in.   Assumed to be the workbasis of <code>evolution</code> when omitted.</li><li><code>grid::Integrations.IntegrationType</code>:   defines the time integration bounds (eg. from 0 to <span>$T$</span>)</li><li><code>ψ::AbstractVector</code>:   the initial statevector, defined on the full Hilbert space of the device.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>callback</code>: a function which is called at each iteration of the time evolution.       The function is passed three arguments:       - <code>i</code>: indexes the iteration       - <code>t</code>: the current time point       - <code>ψ</code>: the current statevector, in the work basis       The function is called after having evolved ψ into |ψ(t)⟩.</li></ul><p><strong>Implementation</strong></p><p>Only the signature omitting <code>basis</code> need be implemented,     so you can assume <code>ψ</code> is represented in whatever basis you return from <code>workbasis</code>.</p><p>The signature including <code>basis</code> will automatically rotate <code>ψ</code> into the <code>workbasis</code>,     call the method you implement, and then rotate back.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Evolutions/__abstractinterface.jl#L31-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Evolutions.gradientsignals" href="#CtrlVQE.Evolutions.gradientsignals"><code>CtrlVQE.Evolutions.gradientsignals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradientsignals(evolution, device, grid, ψ, Ō; kwargs...)
gradientsignals(evolution, device, basis, grid, ψ, Ō; kwargs...)</code></pre><p>The gradient signals associated with a given <code>device</code> Hamiltonian, and an observable <code>O</code>.</p><p>Gradient signals are used to calculate analytical derivatives of a control pulse.</p><p><strong>Arguments</strong></p><ul><li>evolution::EvolutionType: which evolution algorithm to use.</li><li>device::Devices.DeviceType: specifies which Hamiltonian to evolve under.       Also identifies each of the gradient operators used to calculate gradient signals.</li><li><code>basis::Bases.BasisType</code>: which basis <code>ψ</code> is represented in.   Assumed to be the workbasis of <code>evolution</code> when omitted.</li><li><code>grid::Integrations.IntegrationType</code>:   defines the time integration bounds (eg. from 0 to <span>$T$</span>)</li><li><code>ψ::AbstractVector</code>:   the initial statevector, defined on the full Hilbert space of the device.</li><li><code>Ō::Union{LAT.MatrixList,AbstractMatrix}</code>:   a list of Hermitian observables, represented as matrices, or a single such matrix.   Gradients are calculated with respect to the expectation <code>⟨O⟩</code> at time <span>$T$</span>.</li></ul><p>This method signature assumes <code>ψ</code>, <code>Ō</code> are represented in the workbasis of <code>evolution</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>result</code>: an (optional) pre-allocated array to store gradient signals</li><li><code>callback</code>: a function called at each iteration of the gradient signal calculation.       The function is passed three arguments:       - <code>i</code>: indexes the iteration       - <code>t</code>: the current time point       - <code>ψ</code>: the current statevector, in the BARE basis       The function is called after having evolved ψ into |ψ(t)⟩,           but before calculating ϕ̄[i,:]. Evolution here runs backwards.</li></ul><p><strong>Returns</strong></p><p>A 3d array <code>ϕ̄</code>, where each <code>ϕ̄[:,j,k]</code> is the gradient signal <span>$ϕ_j(t)$</span>     defined with respect to the observable <span>$Ô_k$</span>,     or a 2d array when <code>Ō</code> is just a single matrix rather than a matrix list.</p><p><strong>Explanation</strong></p><p>A gradient signal <span>$ϕ_j(t)$</span> is defined with respect to a gradient operator <span>$Â_j$</span>,     an observable <span>$Ô$</span>, a time-dependent state <code>|ψ(t)⟩</code>, and total pulse duration <code>T</code>.</p><p>Let us define the expectation value <span>$E(T) ≡ ⟨ψ(T)|Ô|ψ(T)⟩$</span>.</p><p>Define the co-state <span>$|λ(t)⟩$</span> as the (un-normalized) statevector     which satisfies <span>$E(T)=⟨λ(t)|ψ(t)⟩$</span> for any time <code>t∊[0,T]</code>. The gradient signal is defined as <span>$ϕ_j(t) ≡ ⟨λ(t)|(iÂ_j)|ψ(t)⟩ + h.t.$</span>.</p><p><strong>Implementation</strong></p><p>Only the signature omitting <code>basis</code> need be implemented,     so can assume <code>ψ</code>, <code>Ō</code> are represented in whatever basis you return from <code>workbasis</code>.</p><p>The signature including <code>basis</code> will automatically rotate <code>ψ</code>, <code>Ō</code> into the <code>workbasis</code>     before calling the method you implement.</p><p>Similiarly, you should only implement the method where <code>Ō</code> is a MatrixList. When a single matrix, the (already-implemented) method will reshaped it into a MatrixList,     call the method you implement, and then reshape the resulting array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Evolutions/__abstractinterface.jl#L68-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.Evolutions.workbasis" href="#CtrlVQE.Evolutions.workbasis"><code>CtrlVQE.Evolutions.workbasis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">workbasis(evolution::EvolutionType)::Bases.BasisType</code></pre><p>Which basis the evolution algorithm works in.</p><p>Also defines the default basis to interpret ψ as, in evolution methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/Evolutions/__abstractinterface.jl#L21-L28">source</a></section></article><h2 id="Cost-Functions"><a class="docs-heading-anchor" href="#Cost-Functions">Cost Functions</a><a id="Cost-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Cost-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.CostFunctions" href="#CtrlVQE.CostFunctions"><code>CtrlVQE.CostFunctions</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CostFunctions</code></pre><p>Detailed instructions for how to compute an energy from a set of variational parameters.</p><p>Note that the <code>CostFunctionType</code> defined here refers to a type, not a function. But you can call <code>CostFunctions.cost_function(::CostFunctionType)</code> to get a function. This is the thing you would feed into an optimizer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/CostFunctions.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.CostFunctions.CostFunctionType" href="#CtrlVQE.CostFunctions.CostFunctionType"><code>CtrlVQE.CostFunctions.CostFunctionType</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CostFunctionType{F}</code></pre><p>Encapsulates a cost function, the thing you plug into an optimization algorithm.</p><p><strong>Implementation</strong></p><p>Any concrete sub-type <code>CF</code> must implement the following methods:</p><ul><li><code>cost_function(::CF)</code>:       returns a <code>Function</code> which takes a parameter vector           and returns the output of the cost function       ie. a callable expression (x::Vector) -&gt; f(x)</li><li><code>grad!function(::CF)</code>:       returns a mutating <code>Function</code> which takes a gradient vector (to be mutated)           and a parameter vector, and writes the gradient vector to the first argument.       As a matter of habit, the resulting gradient vector should also be returned.</li><li><code>Base.length(::CF)</code>:       the number of parameters this cost function takes</li></ul><p>If your cost function involves calculating the expectation value of a time-evolved state,     you should implement an <code>EnergyFunction</code> (even if it isn&#39;t strictly an energy). This type has a couple extra requirements to allow energy trajectories over the evolution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/CostFunctions/__abstractinterface.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.CostFunctions.CostFunctionType-Tuple{AbstractVector}" href="#CtrlVQE.CostFunctions.CostFunctionType-Tuple{AbstractVector}"><code>CtrlVQE.CostFunctions.CostFunctionType</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(fn::CostFunctionType)(x̄::AbstractVector)</code></pre><p>Evaluate the value of <code>fn</code> at the point <code>x̄</code>.</p><p>This is syntactic sugar for constructing a dedicated <code>cost_function</code> and calling it. It will not normally take advantage of cached work variables,     so avoid using it in high-performance code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/CostFunctions/__concreteinterface.jl#L15-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.CostFunctions.EnergyFunction" href="#CtrlVQE.CostFunctions.EnergyFunction"><code>CtrlVQE.CostFunctions.EnergyFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EnergyFunction{F}</code></pre><p>Super-type for cost functions calculating the expectation value of a time-evolved state.</p><p><strong>Implementation</strong></p><p>Any concrete sub-type <code>CF</code> must implement     <em>everything</em> required in the <code>CostFunctionType</code> interface,     so consult the documentation for <code>CostFunctionType</code> carefully.</p><p>In additon, the following method must be implemented:</p><ul><li><code>trajectory_callback(::CF, E::AbstractVector; callback=nothing)</code>       returns a <code>Function</code> compatible with Evolutions.evolve callback           ie. a callable expression (i::Int, t::Real, ψ::Vector) -&gt; Nothing       which sets E[i] to the energy of a partially evolved wavefunction ψ.       If <code>callback</code> is provided, the function calls that <code>callback</code> afterwards.</li></ul><p>Finally, the following methods must now accept a keyword argument:</p><ul><li><p><code>cost_function(::CF; callback=nothing)</code>:       When <code>callback</code> is provided, the time evolution must call it at each timestep.</p></li><li><p><code>grad!function(::CF; ϕ=nothing)</code>:       When <code>ϕ</code> is provided, write the gradient signals to it.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/CostFunctions/__energy__abstractinterface.jl#L3-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eltype-Union{Tuple{CtrlVQE.CostFunctions.CostFunctionType{F}}, Tuple{F}} where F" href="#Base.eltype-Union{Tuple{CtrlVQE.CostFunctions.CostFunctionType{F}}, Tuple{F}} where F"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.eltype(fn::CostFunctionType)</code></pre><p>Gives the number type for parameters of this cost function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/CostFunctions/__concreteinterface.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length-Tuple{CtrlVQE.CostFunctions.CostFunctionType}" href="#Base.length-Tuple{CtrlVQE.CostFunctions.CostFunctionType}"><code>Base.length</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.length(fn::CostFunctionType)::Int</code></pre><p>Gives the number of parameters for this cost function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/CostFunctions/__abstractinterface.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.CostFunctions.cost_function" href="#CtrlVQE.CostFunctions.cost_function"><code>CtrlVQE.CostFunctions.cost_function</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cost_function(fn::CostFunctionType)::Function</code></pre><p>Converts the struct <code>fn</code> into a literal function of a parameter vector.</p><p>The function accepts a parameter vector <code>x̄</code>     which should have the type and length given by <code>eltype(fn)</code> and <code>length(fn)</code>. The function returns the value of <code>fn</code> at the point <code>x̄</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/CostFunctions/__abstractinterface.jl#L27-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.CostFunctions.cost_function-Tuple{CtrlVQE.CostFunctions.EnergyFunction}" href="#CtrlVQE.CostFunctions.cost_function-Tuple{CtrlVQE.CostFunctions.EnergyFunction}"><code>CtrlVQE.CostFunctions.cost_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cost_function(fn::EnergyFunction; callback=nothing)</code></pre><p>Same as for <code>CostFunctionType</code> except that whenever the function is called,     the time evolution calls <code>callback</code> (if provided) in each time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/CostFunctions/__energy__abstractinterface.jl#L59-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.CostFunctions.grad!function" href="#CtrlVQE.CostFunctions.grad!function"><code>CtrlVQE.CostFunctions.grad!function</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grad!function(fn::CostFunctionType)::Function</code></pre><p>Constructs a (mutating) function to calculate the gradient of <code>fn</code> at a particular point.</p><p>The function accepts a gradient vector <code>∇f̄</code> (to be mutated) and a parameter vector <code>x̄</code>. Both should have the type and length given by <code>eltype(fn)</code> and <code>length(fn)</code>. After the function is called, <code>∇f̄</code> contains the gradient of <code>fn</code> at the point <code>x̄</code>. As per the Julia guidelines on mutating functions, <code>∇f̄</code> itself should then be returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/CostFunctions/__abstractinterface.jl#L39-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.CostFunctions.grad!function-Tuple{CtrlVQE.CostFunctions.EnergyFunction}" href="#CtrlVQE.CostFunctions.grad!function-Tuple{CtrlVQE.CostFunctions.EnergyFunction}"><code>CtrlVQE.CostFunctions.grad!function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grad!function(fn::EnergyFunction; ϕ=nothing)</code></pre><p>Same as for <code>CostFunctionType</code> except that whenever the function is called,     ϕ (if provided) is updated to contain the gradient signals. The array ϕ should be a 3d array with shape (:,nG,nK),     where nK is the number of observables in the energy function,     nG is the number of gradient operators in the underlying device,     and the remaining dimension is the size of the time grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/CostFunctions/__energy__abstractinterface.jl#L70-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.CostFunctions.grad_function-Union{Tuple{CtrlVQE.CostFunctions.CostFunctionType{F}}, Tuple{F}} where F" href="#CtrlVQE.CostFunctions.grad_function-Union{Tuple{CtrlVQE.CostFunctions.CostFunctionType{F}}, Tuple{F}} where F"><code>CtrlVQE.CostFunctions.grad_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grad_function(fn::CostFunctionType)</code></pre><p>Constructs a <code>Function</code> to calculate the gradient of <code>fn</code> at a particular point.</p><p>The function accepts a parameter vector <code>x̄</code>     which should have the type and length given by <code>eltype(fn)</code> and <code>length(fn)</code>. The function returns the gradient (a vector) of <code>fn</code> at the point <code>x̄</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/CostFunctions/__concreteinterface.jl#L29-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.CostFunctions.nobservables" href="#CtrlVQE.CostFunctions.nobservables"><code>CtrlVQE.CostFunctions.nobservables</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nobservables(fn::EnergyFunction)::Int</code></pre><p>Identify the number of Hermitian observables needed for this energy function.</p><p>For example, to measure the normalized energy,     separate observables are needed for both energy and normalization,     and the results are combined in a non-linear way to produce the final outcome.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/CostFunctions/__energy__abstractinterface.jl#L31-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CtrlVQE.CostFunctions.trajectory_callback" href="#CtrlVQE.CostFunctions.trajectory_callback"><code>CtrlVQE.CostFunctions.trajectory_callback</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trajectory_callback(fn::EnergyFunction, E::AbstractVector; callback=nothing)::Function</code></pre><p>Make a callback to write the energy at each step of a time evolution.</p><p>The callback function should be compatible with <code>Evolutions.evolve</code>     (ie. a callable expression <code>(i::Int, t::Real, ψ::Vector) -&gt; Nothing</code>),     which sets <code>E[1+i]</code> to the energy of a partially evolved wavefunction ψ. Note the <code>1+</code>, due to <code>i</code> indexing a time integration, which starts from 0.</p><p>If <code>callback</code> is provided, the function calls that <code>callback</code> afterwards     (i.e. callback chaining).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/CtrlVQE.jl/blob/bd056054fc1cebb3fa245a44810f4567bc4b0e4e/src/core/CostFunctions/__energy__abstractinterface.jl#L43-L56">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../basics/">« Basic Implementations</a><a class="docs-footer-nextpage" href="../enums/">Enumerations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Tuesday 11 March 2025 19:21">Tuesday 11 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
